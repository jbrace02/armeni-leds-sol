/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana";
exports.ids = ["vendor-chunks/@solana"];
exports.modules = {

/***/ "./node_modules/@solana/web3.js/lib/index.cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@solana/web3.js/lib/index.cjs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"process/browser\");\n\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar ed25519 = __webpack_require__(/*! @noble/curves/ed25519 */ \"@noble/curves/ed25519\");\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js\");\nvar bs58 = __webpack_require__(/*! bs58 */ \"bs58\");\nvar sha256 = __webpack_require__(/*! @noble/hashes/sha256 */ \"@noble/hashes/sha256\");\nvar borsh = __webpack_require__(/*! borsh */ \"borsh\");\nvar BufferLayout = __webpack_require__(/*! @solana/buffer-layout */ \"@solana/buffer-layout\");\nvar bigintBuffer = __webpack_require__(/*! bigint-buffer */ \"bigint-buffer\");\nvar require$$0 = __webpack_require__(/*! util */ \"util\");\nvar require$$0$1 = __webpack_require__(/*! http */ \"http\");\nvar require$$0$2 = __webpack_require__(/*! https */ \"https\");\nvar superstruct = __webpack_require__(/*! superstruct */ \"superstruct\");\nvar RpcClient = __webpack_require__(/*! jayson/lib/client/browser */ \"jayson/lib/client/browser\");\nvar nodeFetch = __webpack_require__(/*! node-fetch */ \"node-fetch\");\nvar rpcWebsockets = __webpack_require__(/*! rpc-websockets */ \"rpc-websockets\");\nvar sha3 = __webpack_require__(/*! @noble/hashes/sha3 */ \"@noble/hashes/sha3\");\nvar secp256k1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"@noble/curves/secp256k1\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nfunction _interopNamespaceCompat(e) {\n    if (e && typeof e === \"object\" && \"default\" in e) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar BN__default = /*#__PURE__*/ _interopDefaultCompat(BN);\nvar bs58__default = /*#__PURE__*/ _interopDefaultCompat(bs58);\nvar BufferLayout__namespace = /*#__PURE__*/ _interopNamespaceCompat(BufferLayout);\nvar require$$0__default = /*#__PURE__*/ _interopDefaultCompat(require$$0);\nvar require$$0__default$1 = /*#__PURE__*/ _interopDefaultCompat(require$$0$1);\nvar require$$0__default$2 = /*#__PURE__*/ _interopDefaultCompat(require$$0$2);\nvar RpcClient__default = /*#__PURE__*/ _interopDefaultCompat(RpcClient);\nvar nodeFetch__namespace = /*#__PURE__*/ _interopNamespaceCompat(nodeFetch);\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = ed25519.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = ed25519.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = ed25519.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        ed25519.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>ed25519.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = ed25519.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return borsh.deserialize(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__default.default.decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new BN__default.default(decoded);\n            } else {\n                this._bn = new BN__default.default(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__default.default.encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer$1 = buffer.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = sha256.sha256(buffer$1);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer$1 = buffer.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer$1 = buffer.Buffer.concat([\n                buffer$1,\n                toBuffer(seed)\n            ]);\n        });\n        buffer$1 = buffer.Buffer.concat([\n            buffer$1,\n            programId.toBuffer(),\n            buffer.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = sha256.sha256(buffer$1);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return BufferLayout__namespace.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return BufferLayout__namespace.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = BufferLayout__namespace.struct([\n        BufferLayout__namespace.u32(\"length\"),\n        BufferLayout__namespace.u32(\"lengthPadding\"),\n        BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return BufferLayout__namespace.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return BufferLayout__namespace.struct([\n        BufferLayout__namespace.ns64(\"unixTimestamp\"),\n        BufferLayout__namespace.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return BufferLayout__namespace.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        BufferLayout__namespace.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return BufferLayout__namespace.struct([\n        BufferLayout__namespace.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__default.default.decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__default.default.encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__default.default.decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = BufferLayout__namespace.struct([\n                BufferLayout__namespace.u8(\"programIdIndex\"),\n                BufferLayout__namespace.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                BufferLayout__namespace.seq(BufferLayout__namespace.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                BufferLayout__namespace.blob(instruction.dataLength.length, \"dataLength\"),\n                BufferLayout__namespace.seq(BufferLayout__namespace.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = BufferLayout__namespace.struct([\n            BufferLayout__namespace.blob(1, \"numRequiredSignatures\"),\n            BufferLayout__namespace.blob(1, \"numReadonlySignedAccounts\"),\n            BufferLayout__namespace.blob(1, \"numReadonlyUnsignedAccounts\"),\n            BufferLayout__namespace.blob(keyCount.length, \"keyCount\"),\n            BufferLayout__namespace.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__default.default.decode(this.recentBlockhash)\n        };\n        let signData = buffer.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer$1) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer$1\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__default.default.encode(buffer.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__default.default.encode(buffer.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = BufferLayout__namespace.struct([\n            BufferLayout__namespace.u8(\"prefix\"),\n            BufferLayout__namespace.struct([\n                BufferLayout__namespace.u8(\"numRequiredSignatures\"),\n                BufferLayout__namespace.u8(\"numReadonlySignedAccounts\"),\n                BufferLayout__namespace.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            BufferLayout__namespace.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            BufferLayout__namespace.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            BufferLayout__namespace.blob(serializedInstructions.length, \"serializedInstructions\"),\n            BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            BufferLayout__namespace.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__default.default.decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = BufferLayout__namespace.struct([\n                BufferLayout__namespace.u8(\"programIdIndex\"),\n                BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                BufferLayout__namespace.blob(encodedDataLength.length, \"encodedDataLength\"),\n                BufferLayout__namespace.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = BufferLayout__namespace.struct([\n                publicKey(\"accountKey\"),\n                BufferLayout__namespace.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__default.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__default.default.encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer$1) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer$1\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__default.default.encode(buffer.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__default.default.encode(DEFAULT_SIGNATURE) ? null : bs58__default.default.decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__default.default.decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = BufferLayout__namespace.struct([\n            BufferLayout__namespace.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            BufferLayout__namespace.seq(signature(), this.signatures.length, \"signatures\"),\n            BufferLayout__namespace.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\nclass SendTransactionError extends Error {\n    constructor({ action, signature, transactionMessage, logs }){\n        const maybeLogsOutput = logs ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n        const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n        let message;\n        switch(action){\n            case \"send\":\n                message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n                break;\n            case \"simulate\":\n                message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n                break;\n            default:\n                {\n                    message = `Unknown action '${((a)=>a)(action)}'`;\n                }\n        }\n        super(message);\n        this.signature = void 0;\n        this.transactionMessage = void 0;\n        this.transactionLogs = void 0;\n        this.signature = signature;\n        this.transactionMessage = transactionMessage;\n        this.transactionLogs = logs ? logs : undefined;\n    }\n    get transactionError() {\n        return {\n            message: this.transactionMessage,\n            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined\n        };\n    }\n    /* @deprecated Use `await getLogs()` instead */ get logs() {\n        const cachedLogs = this.transactionLogs;\n        if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n            return undefined;\n        }\n        return cachedLogs;\n    }\n    async getLogs(connection) {\n        if (!Array.isArray(this.transactionLogs)) {\n            this.transactionLogs = new Promise((resolve, reject)=>{\n                connection.getTransaction(this.signature).then((tx)=>{\n                    if (tx && tx.meta && tx.meta.logMessages) {\n                        const logs = tx.meta.logMessages;\n                        this.transactionLogs = logs;\n                        resolve(logs);\n                    } else {\n                        reject(new Error(\"Log messages not found\"));\n                    }\n                }).catch(reject);\n            });\n        }\n        return await this.transactionLogs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: \"send\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = BufferLayout__namespace.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = BufferLayout__namespace.struct([\n    BufferLayout__namespace.u32(\"version\"),\n    BufferLayout__namespace.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    BufferLayout__namespace.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nconst encodeDecode = (layout)=>{\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return {\n        decode,\n        encode\n    };\n};\nconst bigInt = (length)=>(property)=>{\n        const layout = BufferLayout.blob(length, property);\n        const { encode, decode } = encodeDecode(layout);\n        const bigIntLayout = layout;\n        bigIntLayout.decode = (buffer$1, offset)=>{\n            const src = decode(buffer$1, offset);\n            return bigintBuffer.toBigIntLE(buffer.Buffer.from(src));\n        };\n        bigIntLayout.encode = (bigInt, buffer, offset)=>{\n            const src = bigintBuffer.toBufferLE(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n        return bigIntLayout;\n    };\nconst u64 = bigInt(8);\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = BufferLayout__namespace.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            BufferLayout__namespace.ns64(\"lamports\"),\n            BufferLayout__namespace.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            BufferLayout__namespace.ns64(\"lamports\"),\n            BufferLayout__namespace.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            BufferLayout__namespace.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            BufferLayout__namespace.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            BufferLayout__namespace.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (params.basePubkey != params.fromPubkey) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            BufferLayout__namespace.u32(\"offset\"),\n            BufferLayout__namespace.u32(\"bytesLength\"),\n            BufferLayout__namespace.u32(\"bytesLengthPadding\"),\n            BufferLayout__namespace.seq(BufferLayout__namespace.u8(\"byte\"), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = BufferLayout__namespace.struct([\n                BufferLayout__namespace.u32(\"instruction\")\n            ]);\n            const data = buffer.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ var ms$2 = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0) {\n        return parse(val);\n    } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || \"ms\").toLowerCase();\n    switch(type){\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n            return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n            return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n            return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n            return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n            return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n            return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n    }\n    if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n    }\n    if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n    }\n    if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n    }\n    return ms + \"ms\";\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n    }\n    return ms + \" ms\";\n}\n/**\n * Pluralization helper.\n */ function plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ /**\n * Module dependencies.\n */ var util = require$$0__default.default;\nvar ms$1 = ms$2;\nvar humanizeMs = function(t) {\n    if (typeof t === \"number\") return t;\n    var r = ms$1(t);\n    if (r === undefined) {\n        var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n        console.warn(err.stack);\n    }\n    return r;\n};\nvar constants = {\n    // agent\n    CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n    CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n    INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n    CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n    // socket\n    SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n    SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n    SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n    SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n};\nconst OriginalAgent = require$$0__default$1.default.Agent;\nconst ms = humanizeMs;\nconst debug = require$$0__default.default.debuglog(\"agentkeepalive\");\nconst { INIT_SOCKET: INIT_SOCKET$1, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = constants;\n// OriginalAgent come from\n// - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n// - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n// node <= 10\nlet defaultTimeoutListenerCount = 1;\nconst majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\nif (majorVersion >= 11 && majorVersion <= 12) {\n    defaultTimeoutListenerCount = 2;\n} else if (majorVersion >= 13) {\n    defaultTimeoutListenerCount = 3;\n}\nfunction deprecate(message) {\n    console.log(\"[agentkeepalive:deprecated] %s\", message);\n}\nclass Agent extends OriginalAgent {\n    constructor(options){\n        options = options || {};\n        options.keepAlive = options.keepAlive !== false;\n        // default is keep-alive and 4s free socket timeout\n        // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n        if (options.freeSocketTimeout === undefined) {\n            options.freeSocketTimeout = 4000;\n        }\n        // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.keepAliveTimeout) {\n            deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.keepAliveTimeout;\n            delete options.keepAliveTimeout;\n        }\n        // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.freeSocketKeepAliveTimeout) {\n            deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n            delete options.freeSocketKeepAliveTimeout;\n        }\n        // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n        // By default is double free socket timeout.\n        if (options.timeout === undefined) {\n            // make sure socket default inactivity timeout >= 8s\n            options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n        }\n        // support humanize format\n        options.timeout = ms(options.timeout);\n        options.freeSocketTimeout = ms(options.freeSocketTimeout);\n        options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n        super(options);\n        this[CURRENT_ID] = 0;\n        // create socket success counter\n        this.createSocketCount = 0;\n        this.createSocketCountLastCheck = 0;\n        this.createSocketErrorCount = 0;\n        this.createSocketErrorCountLastCheck = 0;\n        this.closeSocketCount = 0;\n        this.closeSocketCountLastCheck = 0;\n        // socket error event count\n        this.errorSocketCount = 0;\n        this.errorSocketCountLastCheck = 0;\n        // request finished counter\n        this.requestCount = 0;\n        this.requestCountLastCheck = 0;\n        // including free socket timeout counter\n        this.timeoutSocketCount = 0;\n        this.timeoutSocketCountLastCheck = 0;\n        this.on(\"free\", (socket)=>{\n            // https://github.com/nodejs/node/pull/32000\n            // Node.js native agent will check socket timeout eqs agent.options.timeout.\n            // Use the ttl or freeSocketTimeout to overwrite.\n            const timeout = this.calcSocketTimeout(socket);\n            if (timeout > 0 && socket.timeout !== timeout) {\n                socket.setTimeout(timeout);\n            }\n        });\n    }\n    get freeSocketKeepAliveTimeout() {\n        deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n        return this.options.freeSocketTimeout;\n    }\n    get timeout() {\n        deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n        return this.options.timeout;\n    }\n    get socketActiveTTL() {\n        deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n        return this.options.socketActiveTTL;\n    }\n    calcSocketTimeout(socket) {\n        /**\n     * return <= 0: should free socket\n     * return > 0: should update socket timeout\n     * return undefined: not find custom timeout\n     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n        const socketActiveTTL = this.options.socketActiveTTL;\n        if (socketActiveTTL) {\n            // check socketActiveTTL\n            const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n            const diff = socketActiveTTL - aliveTime;\n            if (diff <= 0) {\n                return diff;\n            }\n            if (freeSocketTimeout && diff < freeSocketTimeout) {\n                freeSocketTimeout = diff;\n            }\n        }\n        // set freeSocketTimeout\n        if (freeSocketTimeout) {\n            // set free keepalive timer\n            // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n            // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n            const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n            return customFreeSocketTimeout || freeSocketTimeout;\n        }\n    }\n    keepSocketAlive(socket) {\n        const result = super.keepSocketAlive(socket);\n        // should not keepAlive, do nothing\n        if (!result) return result;\n        const customTimeout = this.calcSocketTimeout(socket);\n        if (typeof customTimeout === \"undefined\") {\n            return true;\n        }\n        if (customTimeout <= 0) {\n            debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n            return false;\n        }\n        if (socket.timeout !== customTimeout) {\n            socket.setTimeout(customTimeout);\n        }\n        return true;\n    }\n    // only call on addRequest\n    reuseSocket(...args) {\n        // reuseSocket(socket, req)\n        super.reuseSocket(...args);\n        const socket = args[0];\n        const req = args[1];\n        req.reusedSocket = true;\n        const agentTimeout = this.options.timeout;\n        if (getSocketTimeout(socket) !== agentTimeout) {\n            // reset timeout before use\n            socket.setTimeout(agentTimeout);\n            debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n        }\n        socket[SOCKET_REQUEST_COUNT]++;\n        debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n    }\n    [CREATE_ID]() {\n        const id = this[CURRENT_ID]++;\n        if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n        return id;\n    }\n    [INIT_SOCKET$1](socket, options) {\n        // bugfix here.\n        // https on node 8, 10 won't set agent.options.timeout by default\n        // TODO: need to fix on node itself\n        if (options.timeout) {\n            const timeout = getSocketTimeout(socket);\n            if (!timeout) {\n                socket.setTimeout(options.timeout);\n            }\n        }\n        if (this.options.keepAlive) {\n            // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n            // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n            socket.setNoDelay(true);\n        }\n        this.createSocketCount++;\n        if (this.options.socketActiveTTL) {\n            socket[SOCKET_CREATED_TIME] = Date.now();\n        }\n        // don't show the hole '-----BEGIN CERTIFICATE----' key string\n        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n        socket[SOCKET_REQUEST_COUNT] = 1;\n        socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n        installListeners(this, socket, options);\n    }\n    createConnection(options, oncreate) {\n        let called = false;\n        const onNewCreate = (err, socket)=>{\n            if (called) return;\n            called = true;\n            if (err) {\n                this.createSocketErrorCount++;\n                return oncreate(err);\n            }\n            this[INIT_SOCKET$1](socket, options);\n            oncreate(err, socket);\n        };\n        const newSocket = super.createConnection(options, onNewCreate);\n        if (newSocket) onNewCreate(null, newSocket);\n        return newSocket;\n    }\n    get statusChanged() {\n        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n        if (changed) {\n            this.createSocketCountLastCheck = this.createSocketCount;\n            this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n            this.closeSocketCountLastCheck = this.closeSocketCount;\n            this.errorSocketCountLastCheck = this.errorSocketCount;\n            this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n            this.requestCountLastCheck = this.requestCount;\n        }\n        return changed;\n    }\n    getCurrentStatus() {\n        return {\n            createSocketCount: this.createSocketCount,\n            createSocketErrorCount: this.createSocketErrorCount,\n            closeSocketCount: this.closeSocketCount,\n            errorSocketCount: this.errorSocketCount,\n            timeoutSocketCount: this.timeoutSocketCount,\n            requestCount: this.requestCount,\n            freeSockets: inspect(this.freeSockets),\n            sockets: inspect(this.sockets),\n            requests: inspect(this.requests)\n        };\n    }\n}\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n    return socket.timeout || socket._idleTimeout;\n}\nfunction installListeners(agent, socket, options) {\n    debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n    // listener socket events: close, timeout, error, free\n    function onFree() {\n        // create and socket.emit('free') logic\n        // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n        // no req on the socket, it should be the new socket\n        if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n        socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n        agent.requestCount++;\n        debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // should reuse on pedding requests?\n        const name = agent.getName(options);\n        if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n            // will be reuse on agent free listener\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        }\n    }\n    socket.on(\"free\", onFree);\n    function onClose(isError) {\n        debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n        agent.closeSocketCount++;\n    }\n    socket.on(\"close\", onClose);\n    // start socket timeout handler\n    function onTimeout() {\n        // onTimeout and emitRequestTimeout(_http_client.js)\n        // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n        const listenerCount = socket.listeners(\"timeout\").length;\n        // node <= 10, default listenerCount is 1, onTimeout\n        // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n        // node >= 13, default listenerCount is 3, onTimeout,\n        //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n        //   and emitRequestTimeout\n        const timeout = getSocketTimeout(socket);\n        const req = socket._httpMessage;\n        const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n        debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n        if (debug.enabled) {\n            debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n        }\n        agent.timeoutSocketCount++;\n        const name = agent.getName(options);\n        if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n            // free socket timeout, destroy quietly\n            socket.destroy();\n            // Remove it from freeSockets list immediately to prevent new requests\n            // from being sent through this socket.\n            agent.removeSocket(socket, options);\n            debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n        } else {\n            // if there is no any request socket timeout handler,\n            // agent need to handle socket timeout itself.\n            //\n            // custom request socket timeout handle logic must follow these rules:\n            //  1. Destroy socket first\n            //  2. Must emit socket 'agentRemove' event tell agent remove socket\n            //     from freeSockets list immediately.\n            //     Otherise you may be get 'socket hang up' error when reuse\n            //     free socket and timeout happen in the same time.\n            if (reqTimeoutListenerCount === 0) {\n                const error = new Error(\"Socket timeout\");\n                error.code = \"ERR_SOCKET_TIMEOUT\";\n                error.timeout = timeout;\n                // must manually call socket.end() or socket.destroy() to end the connection.\n                // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                socket.destroy(error);\n                agent.removeSocket(socket, options);\n                debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n            }\n        }\n    }\n    socket.on(\"timeout\", onTimeout);\n    function onError(err) {\n        const listenerCount = socket.listeners(\"error\").length;\n        debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n        agent.errorSocketCount++;\n        if (listenerCount === 1) {\n            // if socket don't contain error event handler, don't catch it, emit it again\n            debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n            socket.removeListener(\"error\", onError);\n            socket.emit(\"error\", err);\n        }\n    }\n    socket.on(\"error\", onError);\n    function onRemove() {\n        debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // We need this function for cases like HTTP 'upgrade'\n        // (defined by WebSockets) where we need to remove a socket from the\n        // pool because it'll be locked up indefinitely\n        socket.removeListener(\"close\", onClose);\n        socket.removeListener(\"error\", onError);\n        socket.removeListener(\"free\", onFree);\n        socket.removeListener(\"timeout\", onTimeout);\n        socket.removeListener(\"agentRemove\", onRemove);\n    }\n    socket.on(\"agentRemove\", onRemove);\n}\nvar agent = Agent;\nfunction inspect(obj) {\n    const res = {};\n    for(const key in obj){\n        res[key] = obj[key].length;\n    }\n    return res;\n}\nconst OriginalHttpsAgent = require$$0__default$2.default.Agent;\nconst HttpAgent = agent;\nconst { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = constants;\nlet HttpsAgent$1 = class HttpsAgent extends HttpAgent {\n    constructor(options){\n        super(options);\n        this.defaultPort = 443;\n        this.protocol = \"https:\";\n        this.maxCachedSessions = this.options.maxCachedSessions;\n        /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n            this.maxCachedSessions = 100;\n        }\n        this._sessionCache = {\n            map: {},\n            list: []\n        };\n    }\n    createConnection(options, oncreate) {\n        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n        this[INIT_SOCKET](socket, options);\n        return socket;\n    }\n};\n// https://github.com/nodejs/node/blob/master/lib/https.js#L89\nHttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n[\n    \"getName\",\n    \"_getSession\",\n    \"_cacheSession\",\n    // https://github.com/nodejs/node/pull/4982\n    \"_evictSession\"\n].forEach(function(method) {\n    /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n        HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];\n    }\n});\nvar https_agent = HttpsAgent$1;\nagentkeepalive.exports = agent;\nvar HttpsAgent = agentkeepalive.exports.HttpsAgent = https_agent;\nagentkeepalive.exports.constants = constants;\nvar agentkeepaliveExports = agentkeepalive.exports;\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var name in obj){\n        keys.push(name);\n    }\n    return keys;\n};\nfunction stringify(val, isArrayProp) {\n    var i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return \"true\";\n    }\n    if (val === false) {\n        return \"false\";\n    }\n    switch(typeof val){\n        case \"object\":\n            if (val === null) {\n                return null;\n            } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === \"[object Array]\") {\n                    str = \"[\";\n                    max = val.length - 1;\n                    for(i = 0; i < max; i++){\n                        str += stringify(val[i], true) + \",\";\n                    }\n                    if (max > -1) {\n                        str += stringify(val[i], true);\n                    }\n                    return str + \"]\";\n                } else if (toStr === \"[object Object]\") {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = \"\";\n                    i = 0;\n                    while(i < max){\n                        key = keys[i];\n                        propVal = stringify(val[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += \",\";\n                            }\n                            str += JSON.stringify(key) + \":\" + propVal;\n                        }\n                        i++;\n                    }\n                    return \"{\" + str + \"}\";\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case \"function\":\n        case \"undefined\":\n            return isArrayProp ? null : undefined;\n        case \"string\":\n            return JSON.stringify(val);\n        default:\n            return isFinite(val) ? val : null;\n    }\n}\nvar fastStableStringify = function(val) {\n    var returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        return \"\" + returnVal;\n    }\n};\nvar fastStableStringify$1 = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringify);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await nodeFetch__namespace.default(processedInput, init);\n};\nclass RpcWebSocketClient extends rpcWebsockets.CommonClient {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = rpcWebsockets.WebSocket(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = BufferLayout__namespace.struct([\n            BufferLayout__namespace.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: BufferLayout__namespace.struct([\n        BufferLayout__namespace.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        BufferLayout__namespace.nu64(\"lastExtendedSlot\"),\n        BufferLayout__namespace.u8(\"lastExtendedStartIndex\"),\n        BufferLayout__namespace.u8(),\n        // option\n        BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey), superstruct.string(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = superstruct.tuple([\n    superstruct.string(),\n    superstruct.literal(\"base64\")\n]);\nconst BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, (value)=>buffer.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function applyDefaultMemcmpEncodingToFilters(filters) {\n    return filters.map((filter)=>\"memcmp\" in filter ? {\n            ...filter,\n            memcmp: {\n                ...filter.memcmp,\n                encoding: filter.memcmp.encoding ?? \"base58\"\n            }\n        } : filter);\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return superstruct.union([\n        superstruct.type({\n            jsonrpc: superstruct.literal(\"2.0\"),\n            id: superstruct.string(),\n            result\n        }),\n        superstruct.type({\n            jsonrpc: superstruct.literal(\"2.0\"),\n            id: superstruct.string(),\n            error: superstruct.type({\n                code: superstruct.unknown(),\n                message: superstruct.string(),\n                data: superstruct.optional(superstruct.any())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult(superstruct.unknown());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return superstruct.coerce(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: superstruct.create(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult(superstruct.type({\n        context: superstruct.type({\n            slot: superstruct.number()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return superstruct.type({\n        context: superstruct.type({\n            slot: superstruct.number()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__default.default.decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = superstruct.type({\n    foundation: superstruct.number(),\n    foundationTerm: superstruct.number(),\n    initial: superstruct.number(),\n    taper: superstruct.number(),\n    terminal: superstruct.number()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult(superstruct.array(superstruct.nullable(superstruct.type({\n    epoch: superstruct.number(),\n    effectiveSlot: superstruct.number(),\n    amount: superstruct.number(),\n    postBalance: superstruct.number(),\n    commission: superstruct.optional(superstruct.nullable(superstruct.number()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = superstruct.array(superstruct.type({\n    slot: superstruct.number(),\n    prioritizationFee: superstruct.number()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = superstruct.type({\n    total: superstruct.number(),\n    validator: superstruct.number(),\n    foundation: superstruct.number(),\n    epoch: superstruct.number()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = superstruct.type({\n    epoch: superstruct.number(),\n    slotIndex: superstruct.number(),\n    slotsInEpoch: superstruct.number(),\n    absoluteSlot: superstruct.number(),\n    blockHeight: superstruct.optional(superstruct.number()),\n    transactionCount: superstruct.optional(superstruct.number())\n});\nconst GetEpochScheduleResult = superstruct.type({\n    slotsPerEpoch: superstruct.number(),\n    leaderScheduleSlotOffset: superstruct.number(),\n    warmup: superstruct.boolean(),\n    firstNormalEpoch: superstruct.number(),\n    firstNormalSlot: superstruct.number()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = superstruct.nullable(superstruct.union([\n    superstruct.type({}),\n    superstruct.string()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = superstruct.type({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = superstruct.literal(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = superstruct.type({\n    \"solana-core\": superstruct.string(),\n    \"feature-set\": superstruct.optional(superstruct.number())\n});\nconst ParsedInstructionStruct = superstruct.type({\n    program: superstruct.string(),\n    programId: PublicKeyFromString,\n    parsed: superstruct.unknown()\n});\nconst PartiallyDecodedInstructionStruct = superstruct.type({\n    programId: PublicKeyFromString,\n    accounts: superstruct.array(PublicKeyFromString),\n    data: superstruct.string()\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext(superstruct.type({\n    err: superstruct.nullable(superstruct.union([\n        superstruct.type({}),\n        superstruct.string()\n    ])),\n    logs: superstruct.nullable(superstruct.array(superstruct.string())),\n    accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({\n        executable: superstruct.boolean(),\n        owner: superstruct.string(),\n        lamports: superstruct.number(),\n        data: superstruct.array(superstruct.string()),\n        rentEpoch: superstruct.optional(superstruct.number())\n    }))))),\n    unitsConsumed: superstruct.optional(superstruct.number()),\n    returnData: superstruct.optional(superstruct.nullable(superstruct.type({\n        programId: superstruct.string(),\n        data: superstruct.tuple([\n            superstruct.string(),\n            superstruct.literal(\"base64\")\n        ])\n    }))),\n    innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n        index: superstruct.number(),\n        instructions: superstruct.array(superstruct.union([\n            ParsedInstructionStruct,\n            PartiallyDecodedInstructionStruct\n        ]))\n    }))))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext(superstruct.type({\n    byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),\n    range: superstruct.type({\n        firstSlot: superstruct.number(),\n        lastSlot: superstruct.number()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof require$$0$2.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof require$$0$2.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new RpcClient__default.default(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult(superstruct.number());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext(superstruct.type({\n    total: superstruct.number(),\n    circulating: superstruct.number(),\n    nonCirculating: superstruct.number(),\n    nonCirculatingAccounts: superstruct.array(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = superstruct.type({\n    amount: superstruct.string(),\n    uiAmount: superstruct.nullable(superstruct.number()),\n    decimals: superstruct.number(),\n    uiAmountString: superstruct.optional(superstruct.string())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n    address: PublicKeyFromString,\n    amount: superstruct.string(),\n    uiAmount: superstruct.nullable(superstruct.number()),\n    decimals: superstruct.number(),\n    uiAmountString: superstruct.optional(superstruct.string())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n    pubkey: PublicKeyFromString,\n    account: superstruct.type({\n        executable: superstruct.boolean(),\n        owner: PublicKeyFromString,\n        lamports: superstruct.number(),\n        data: BufferFromRawAccountData,\n        rentEpoch: superstruct.number()\n    })\n})));\nconst ParsedAccountDataResult = superstruct.type({\n    program: superstruct.string(),\n    parsed: superstruct.unknown(),\n    space: superstruct.number()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n    pubkey: PublicKeyFromString,\n    account: superstruct.type({\n        executable: superstruct.boolean(),\n        owner: PublicKeyFromString,\n        lamports: superstruct.number(),\n        data: ParsedAccountDataResult,\n        rentEpoch: superstruct.number()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n    lamports: superstruct.number(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = superstruct.type({\n    executable: superstruct.boolean(),\n    owner: PublicKeyFromString,\n    lamports: superstruct.number(),\n    data: BufferFromRawAccountData,\n    rentEpoch: superstruct.number()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = superstruct.type({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = superstruct.coerce(superstruct.union([\n    superstruct.instance(buffer.Buffer),\n    ParsedAccountDataResult\n]), superstruct.union([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return superstruct.create(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = superstruct.type({\n    executable: superstruct.boolean(),\n    owner: PublicKeyFromString,\n    lamports: superstruct.number(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: superstruct.number()\n});\nconst KeyedParsedAccountInfoResult = superstruct.type({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = superstruct.type({\n    state: superstruct.union([\n        superstruct.literal(\"active\"),\n        superstruct.literal(\"inactive\"),\n        superstruct.literal(\"activating\"),\n        superstruct.literal(\"deactivating\")\n    ]),\n    active: superstruct.number(),\n    inactive: superstruct.number()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(superstruct.array(superstruct.type({\n    signature: superstruct.string(),\n    slot: superstruct.number(),\n    err: TransactionErrorResult,\n    memo: superstruct.nullable(superstruct.string()),\n    blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult(superstruct.array(superstruct.type({\n    signature: superstruct.string(),\n    slot: superstruct.number(),\n    err: TransactionErrorResult,\n    memo: superstruct.nullable(superstruct.string()),\n    blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = superstruct.type({\n    subscription: superstruct.number(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = superstruct.type({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = superstruct.type({\n    subscription: superstruct.number(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = superstruct.type({\n    parent: superstruct.number(),\n    slot: superstruct.number(),\n    root: superstruct.number()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = superstruct.type({\n    subscription: superstruct.number(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = superstruct.union([\n    superstruct.type({\n        type: superstruct.union([\n            superstruct.literal(\"firstShredReceived\"),\n            superstruct.literal(\"completed\"),\n            superstruct.literal(\"optimisticConfirmation\"),\n            superstruct.literal(\"root\")\n        ]),\n        slot: superstruct.number(),\n        timestamp: superstruct.number()\n    }),\n    superstruct.type({\n        type: superstruct.literal(\"createdBank\"),\n        parent: superstruct.number(),\n        slot: superstruct.number(),\n        timestamp: superstruct.number()\n    }),\n    superstruct.type({\n        type: superstruct.literal(\"frozen\"),\n        slot: superstruct.number(),\n        timestamp: superstruct.number(),\n        stats: superstruct.type({\n            numTransactionEntries: superstruct.number(),\n            numSuccessfulTransactions: superstruct.number(),\n            numFailedTransactions: superstruct.number(),\n            maxTransactionsPerEntry: superstruct.number()\n        })\n    }),\n    superstruct.type({\n        type: superstruct.literal(\"dead\"),\n        slot: superstruct.number(),\n        timestamp: superstruct.number(),\n        err: superstruct.string()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = superstruct.type({\n    subscription: superstruct.number(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = superstruct.type({\n    subscription: superstruct.number(),\n    result: notificationResultAndContext(superstruct.union([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = superstruct.type({\n    subscription: superstruct.number(),\n    result: superstruct.number()\n});\nconst ContactInfoResult = superstruct.type({\n    pubkey: superstruct.string(),\n    gossip: superstruct.nullable(superstruct.string()),\n    tpu: superstruct.nullable(superstruct.string()),\n    rpc: superstruct.nullable(superstruct.string()),\n    version: superstruct.nullable(superstruct.string())\n});\nconst VoteAccountInfoResult = superstruct.type({\n    votePubkey: superstruct.string(),\n    nodePubkey: superstruct.string(),\n    activatedStake: superstruct.number(),\n    epochVoteAccount: superstruct.boolean(),\n    epochCredits: superstruct.array(superstruct.tuple([\n        superstruct.number(),\n        superstruct.number(),\n        superstruct.number()\n    ])),\n    commission: superstruct.number(),\n    lastVote: superstruct.number(),\n    rootSlot: superstruct.nullable(superstruct.number())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult(superstruct.type({\n    current: superstruct.array(VoteAccountInfoResult),\n    delinquent: superstruct.array(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = superstruct.union([\n    superstruct.literal(\"processed\"),\n    superstruct.literal(\"confirmed\"),\n    superstruct.literal(\"finalized\")\n]);\nconst SignatureStatusResponse = superstruct.type({\n    slot: superstruct.number(),\n    confirmations: superstruct.nullable(superstruct.number()),\n    err: TransactionErrorResult,\n    confirmationStatus: superstruct.optional(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.nullable(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(superstruct.number());\nconst AddressTableLookupStruct = superstruct.type({\n    accountKey: PublicKeyFromString,\n    writableIndexes: superstruct.array(superstruct.number()),\n    readonlyIndexes: superstruct.array(superstruct.number())\n});\nconst ConfirmedTransactionResult = superstruct.type({\n    signatures: superstruct.array(superstruct.string()),\n    message: superstruct.type({\n        accountKeys: superstruct.array(superstruct.string()),\n        header: superstruct.type({\n            numRequiredSignatures: superstruct.number(),\n            numReadonlySignedAccounts: superstruct.number(),\n            numReadonlyUnsignedAccounts: superstruct.number()\n        }),\n        instructions: superstruct.array(superstruct.type({\n            accounts: superstruct.array(superstruct.number()),\n            data: superstruct.string(),\n            programIdIndex: superstruct.number()\n        })),\n        recentBlockhash: superstruct.string(),\n        addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = superstruct.type({\n    pubkey: PublicKeyFromString,\n    signer: superstruct.boolean(),\n    writable: superstruct.boolean(),\n    source: superstruct.optional(superstruct.union([\n        superstruct.literal(\"transaction\"),\n        superstruct.literal(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = superstruct.type({\n    accountKeys: superstruct.array(AnnotatedAccountKey),\n    signatures: superstruct.array(superstruct.string())\n});\nconst ParsedInstructionResult = superstruct.type({\n    parsed: superstruct.unknown(),\n    program: superstruct.string(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = superstruct.type({\n    accounts: superstruct.array(PublicKeyFromString),\n    data: superstruct.string(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = superstruct.union([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = superstruct.union([\n    superstruct.type({\n        parsed: superstruct.unknown(),\n        program: superstruct.string(),\n        programId: superstruct.string()\n    }),\n    superstruct.type({\n        accounts: superstruct.array(superstruct.string()),\n        data: superstruct.string(),\n        programId: superstruct.string()\n    })\n]);\nconst ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return superstruct.create(value, RawInstructionResult);\n    } else {\n        return superstruct.create(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = superstruct.type({\n    signatures: superstruct.array(superstruct.string()),\n    message: superstruct.type({\n        accountKeys: superstruct.array(AnnotatedAccountKey),\n        instructions: superstruct.array(ParsedOrRawInstruction),\n        recentBlockhash: superstruct.string(),\n        addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = superstruct.type({\n    accountIndex: superstruct.number(),\n    mint: superstruct.string(),\n    owner: superstruct.optional(superstruct.string()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = superstruct.type({\n    writable: superstruct.array(PublicKeyFromString),\n    readonly: superstruct.array(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = superstruct.type({\n    err: TransactionErrorResult,\n    fee: superstruct.number(),\n    innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n        index: superstruct.number(),\n        instructions: superstruct.array(superstruct.type({\n            accounts: superstruct.array(superstruct.number()),\n            data: superstruct.string(),\n            programIdIndex: superstruct.number()\n        }))\n    })))),\n    preBalances: superstruct.array(superstruct.number()),\n    postBalances: superstruct.array(superstruct.number()),\n    logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),\n    preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n    postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n    loadedAddresses: superstruct.optional(LoadedAddressesResult),\n    computeUnitsConsumed: superstruct.optional(superstruct.number())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = superstruct.type({\n    err: TransactionErrorResult,\n    fee: superstruct.number(),\n    innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n        index: superstruct.number(),\n        instructions: superstruct.array(ParsedOrRawInstruction)\n    })))),\n    preBalances: superstruct.array(superstruct.number()),\n    postBalances: superstruct.array(superstruct.number()),\n    logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),\n    preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n    postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n    loadedAddresses: superstruct.optional(LoadedAddressesResult),\n    computeUnitsConsumed: superstruct.optional(superstruct.number())\n});\nconst TransactionVersionStruct = superstruct.union([\n    superstruct.literal(0),\n    superstruct.literal(\"legacy\")\n]);\n/** @internal */ const RewardsResult = superstruct.type({\n    pubkey: superstruct.string(),\n    lamports: superstruct.number(),\n    postBalance: superstruct.nullable(superstruct.number()),\n    rewardType: superstruct.nullable(superstruct.string()),\n    commission: superstruct.optional(superstruct.nullable(superstruct.number()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    transactions: superstruct.array(superstruct.type({\n        transaction: ConfirmedTransactionResult,\n        meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n        version: superstruct.optional(TransactionVersionStruct)\n    })),\n    rewards: superstruct.optional(superstruct.array(RewardsResult)),\n    blockTime: superstruct.nullable(superstruct.number()),\n    blockHeight: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    rewards: superstruct.optional(superstruct.array(RewardsResult)),\n    blockTime: superstruct.nullable(superstruct.number()),\n    blockHeight: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    transactions: superstruct.array(superstruct.type({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n        version: superstruct.optional(TransactionVersionStruct)\n    })),\n    rewards: superstruct.optional(superstruct.array(RewardsResult)),\n    blockTime: superstruct.nullable(superstruct.number()),\n    blockHeight: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    transactions: superstruct.array(superstruct.type({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n        version: superstruct.optional(TransactionVersionStruct)\n    })),\n    rewards: superstruct.optional(superstruct.array(RewardsResult)),\n    blockTime: superstruct.nullable(superstruct.number()),\n    blockHeight: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    transactions: superstruct.array(superstruct.type({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n        version: superstruct.optional(TransactionVersionStruct)\n    })),\n    rewards: superstruct.optional(superstruct.array(RewardsResult)),\n    blockTime: superstruct.nullable(superstruct.number()),\n    blockHeight: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    rewards: superstruct.optional(superstruct.array(RewardsResult)),\n    blockTime: superstruct.nullable(superstruct.number()),\n    blockHeight: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    transactions: superstruct.array(superstruct.type({\n        transaction: ConfirmedTransactionResult,\n        meta: superstruct.nullable(ConfirmedTransactionMetaResult)\n    })),\n    rewards: superstruct.optional(superstruct.array(RewardsResult)),\n    blockTime: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    blockhash: superstruct.string(),\n    previousBlockhash: superstruct.string(),\n    parentSlot: superstruct.number(),\n    signatures: superstruct.array(superstruct.string()),\n    blockTime: superstruct.nullable(superstruct.number())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    slot: superstruct.number(),\n    meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n    blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),\n    transaction: ConfirmedTransactionResult,\n    version: superstruct.optional(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n    slot: superstruct.number(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n    blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),\n    version: superstruct.optional(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */ const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(superstruct.type({\n    blockhash: superstruct.string(),\n    feeCalculator: superstruct.type({\n        lamportsPerSignature: superstruct.number()\n    })\n}));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext(superstruct.type({\n    blockhash: superstruct.string(),\n    lastValidBlockHeight: superstruct.number()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext(superstruct.boolean());\nconst PerfSampleResult = superstruct.type({\n    slot: superstruct.number(),\n    numTransactions: superstruct.number(),\n    numSlots: superstruct.number(),\n    samplePeriodSecs: superstruct.number()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult(superstruct.array(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext(superstruct.nullable(superstruct.type({\n    feeCalculator: superstruct.type({\n        lamportsPerSignature: superstruct.number()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult(superstruct.string());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult(superstruct.string());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = superstruct.type({\n    err: TransactionErrorResult,\n    logs: superstruct.array(superstruct.string()),\n    signature: superstruct.string()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = superstruct.type({\n    result: notificationResultAndContext(LogsResult),\n    subscription: superstruct.number()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"0.0.0-development\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify$1(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.nullable(superstruct.number())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = superstruct.create(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = superstruct.create(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", {\n            ...configWithoutEncoding,\n            ...configWithoutEncoding.filters ? {\n                filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)\n            } : null\n        });\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = superstruct.array(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? superstruct.create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : superstruct.create(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__default.default.decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = superstruct.create(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = superstruct.create(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = superstruct.create(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getRecentBlockhash\", args);\n        const res = superstruct.create(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(superstruct.number())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = superstruct.create(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = superstruct.create(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = superstruct.create(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(superstruct.number())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getConfirmedTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n                config.innerInstructions = configOrSigners.innerInstructions;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n            config.innerInstructions = configOrSigners.innerInstructions;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError({\n                action: \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = superstruct.create(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs = undefined;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError({\n                action: skipPreflight ? \"send\" : \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            if (e instanceof Error) {\n                                console.error(`${method} error for argument`, args, e.message);\n                            }\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = superstruct.create(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify$1([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onAccountChange(publicKey, callback, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\", config);\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = superstruct.create(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , config ? config : maybeFilters ? {\n            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = superstruct.create(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = superstruct.create(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = superstruct.create(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = superstruct.create(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = superstruct.create(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            BufferLayout__namespace.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            u64(),\n            BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = BufferLayout__namespace.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            bigintBuffer.toBufferLE(BigInt(params.recentSlot), 8)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = BufferLayout__namespace.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u8(\"instruction\"),\n            BufferLayout__namespace.u32(\"units\"),\n            BufferLayout__namespace.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u8(\"instruction\"),\n            BufferLayout__namespace.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u8(\"instruction\"),\n            BufferLayout__namespace.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([\n    BufferLayout__namespace.u8(\"numSignatures\"),\n    BufferLayout__namespace.u8(\"padding\"),\n    BufferLayout__namespace.u16(\"signatureOffset\"),\n    BufferLayout__namespace.u16(\"signatureInstructionIndex\"),\n    BufferLayout__namespace.u16(\"publicKeyOffset\"),\n    BufferLayout__namespace.u16(\"publicKeyInstructionIndex\"),\n    BufferLayout__namespace.u16(\"messageDataOffset\"),\n    BufferLayout__namespace.u16(\"messageDataSize\"),\n    BufferLayout__namespace.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = secp256k1.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\nsecp256k1.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = secp256k1.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([\n    BufferLayout__namespace.u8(\"numSignatures\"),\n    BufferLayout__namespace.u16(\"signatureOffset\"),\n    BufferLayout__namespace.u8(\"signatureInstructionIndex\"),\n    BufferLayout__namespace.u16(\"ethAddressOffset\"),\n    BufferLayout__namespace.u8(\"ethAddressInstructionIndex\"),\n    BufferLayout__namespace.u16(\"messageDataOffset\"),\n    BufferLayout__namespace.u16(\"messageDataSize\"),\n    BufferLayout__namespace.u8(\"messageInstructionIndex\"),\n    BufferLayout__namespace.blob(20, \"ethAddress\"),\n    BufferLayout__namespace.blob(64, \"signature\"),\n    BufferLayout__namespace.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = BufferLayout__namespace.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            BufferLayout__namespace.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            BufferLayout__namespace.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            BufferLayout__namespace.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            BufferLayout__namespace.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = BufferLayout__namespace.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            BufferLayout__namespace.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            BufferLayout__namespace.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: BufferLayout__namespace.struct([\n            BufferLayout__namespace.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = superstruct.type({\n    name: superstruct.string(),\n    website: superstruct.optional(superstruct.string()),\n    details: superstruct.optional(superstruct.string()),\n    iconUrl: superstruct.optional(superstruct.string()),\n    keybaseUsername: superstruct.optional(superstruct.string())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer$1) {\n        let byteArray = [\n            ...buffer$1\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                superstruct.assert(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = BufferLayout__namespace.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    BufferLayout__namespace.u8(\"commission\"),\n    BufferLayout__namespace.nu64(),\n    // votes.length\n    BufferLayout__namespace.seq(BufferLayout__namespace.struct([\n        BufferLayout__namespace.nu64(\"slot\"),\n        BufferLayout__namespace.u32(\"confirmationCount\")\n    ]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), \"votes\"),\n    BufferLayout__namespace.u8(\"rootSlotValid\"),\n    BufferLayout__namespace.nu64(\"rootSlot\"),\n    BufferLayout__namespace.nu64(),\n    // authorizedVoters.length\n    BufferLayout__namespace.seq(BufferLayout__namespace.struct([\n        BufferLayout__namespace.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), \"authorizedVoters\"),\n    BufferLayout__namespace.struct([\n        BufferLayout__namespace.seq(BufferLayout__namespace.struct([\n            publicKey(\"authorizedPubkey\"),\n            BufferLayout__namespace.nu64(\"epochOfLastAuthorizedSwitch\"),\n            BufferLayout__namespace.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        BufferLayout__namespace.nu64(\"idx\"),\n        BufferLayout__namespace.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    BufferLayout__namespace.nu64(),\n    // epochCredits.length\n    BufferLayout__namespace.seq(BufferLayout__namespace.struct([\n        BufferLayout__namespace.nu64(\"epoch\"),\n        BufferLayout__namespace.nu64(\"credits\"),\n        BufferLayout__namespace.nu64(\"prevCredits\")\n    ]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), \"epochCredits\"),\n    BufferLayout__namespace.struct([\n        BufferLayout__namespace.nu64(\"slot\"),\n        BufferLayout__namespace.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: sendOptions?.skipPreflight ? \"send\" : \"simulate\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\nexports.Account = Account;\nexports.AddressLookupTableAccount = AddressLookupTableAccount;\nexports.AddressLookupTableInstruction = AddressLookupTableInstruction;\nexports.AddressLookupTableProgram = AddressLookupTableProgram;\nexports.Authorized = Authorized;\nexports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS;\nexports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;\nexports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;\nexports.BpfLoader = BpfLoader;\nexports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS;\nexports.ComputeBudgetInstruction = ComputeBudgetInstruction;\nexports.ComputeBudgetProgram = ComputeBudgetProgram;\nexports.Connection = Connection;\nexports.Ed25519Program = Ed25519Program;\nexports.Enum = Enum;\nexports.EpochSchedule = EpochSchedule;\nexports.FeeCalculatorLayout = FeeCalculatorLayout;\nexports.Keypair = Keypair;\nexports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;\nexports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS;\nexports.Loader = Loader;\nexports.Lockup = Lockup;\nexports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;\nexports.Message = Message;\nexports.MessageAccountKeys = MessageAccountKeys;\nexports.MessageV0 = MessageV0;\nexports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH;\nexports.NonceAccount = NonceAccount;\nexports.PACKET_DATA_SIZE = PACKET_DATA_SIZE;\nexports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH;\nexports.PublicKey = PublicKey;\nexports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES;\nexports.SOLANA_SCHEMA = SOLANA_SCHEMA;\nexports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;\nexports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;\nexports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;\nexports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;\nexports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY;\nexports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;\nexports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY;\nexports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;\nexports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;\nexports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY;\nexports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY;\nexports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;\nexports.Secp256k1Program = Secp256k1Program;\nexports.SendTransactionError = SendTransactionError;\nexports.SolanaJSONRPCError = SolanaJSONRPCError;\nexports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;\nexports.StakeAuthorizationLayout = StakeAuthorizationLayout;\nexports.StakeInstruction = StakeInstruction;\nexports.StakeProgram = StakeProgram;\nexports.Struct = Struct;\nexports.SystemInstruction = SystemInstruction;\nexports.SystemProgram = SystemProgram;\nexports.Transaction = Transaction;\nexports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError;\nexports.TransactionExpiredNonceInvalidError = TransactionExpiredNonceInvalidError;\nexports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError;\nexports.TransactionInstruction = TransactionInstruction;\nexports.TransactionMessage = TransactionMessage;\nexports.TransactionStatus = TransactionStatus;\nexports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;\nexports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK;\nexports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;\nexports.ValidatorInfo = ValidatorInfo;\nexports.VersionedMessage = VersionedMessage;\nexports.VersionedTransaction = VersionedTransaction;\nexports.VoteAccount = VoteAccount;\nexports.VoteAuthorizationLayout = VoteAuthorizationLayout;\nexports.VoteInit = VoteInit;\nexports.VoteInstruction = VoteInstruction;\nexports.VoteProgram = VoteProgram;\nexports.clusterApiUrl = clusterApiUrl;\nexports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction;\nexports.sendAndConfirmTransaction = sendAndConfirmTransaction; //# sourceMappingURL=index.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5janMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Q0FJQSxHQUdBOztDQUVBLEdBTU8sTUFBTUEscUJBQXFCQyxRQUFBQSxPQUFPLENBQUNDLEtBQUssQ0FBQ0MsZ0JBQWdCO0FBQ3pELE1BQU1DLGtCQUFrQkE7SUFDN0IsTUFBTUMsZ0JBQWdCSixRQUFBQSxPQUFPLENBQUNDLEtBQUssQ0FBQ0MsZ0JBQWdCO0lBQ3BELE1BQU1HLFlBQVlDLGFBQWFGO0lBQy9CLE1BQU1HLFlBQVksSUFBSUMsV0FBVztJQUNqQ0QsVUFBVUUsR0FBRyxDQUFDTDtJQUNkRyxVQUFVRSxHQUFHLENBQUNKLFdBQVc7SUFDekIsT0FBTztRQUNMQTtRQUNBRTs7QUFFSjtBQUNPLE1BQU1ELGVBQWVOLFFBQUFBLE9BQU8sQ0FBQ00sWUFBWTtBQUN6QyxTQUFTSSxVQUFVTCxTQUFxQjtJQUM3QyxJQUFJO1FBQ0ZMLFFBQUFBLE9BQU8sQ0FBQ1csYUFBYSxDQUFDQyxPQUFPLENBQUNQO1FBQzlCLE9BQU87SUFDVCxFQUFFLE9BQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUNPLE1BQU1RLE9BQU9BLENBQ2xCQyxTQUNBUCxZQUNHUCxRQUFBQSxPQUFPLENBQUNhLElBQUksQ0FBQ0MsU0FBU1AsVUFBVVEsS0FBSyxDQUFDLEdBQUc7QUFDdkMsTUFBTUMsU0FBU2hCLFFBQUFBLE9BQU8sQ0FBQ2dCLE1BQU07QUN4QzdCLE1BQU1DLFdBQVlDLENBQUFBO0lBQ3ZCLElBQUlDLE9BQUFBLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDRixNQUFNO1FBQ3hCLE9BQU9BO0lBQ1QsT0FBTyxJQUFJQSxlQUFlVixZQUFZO1FBQ3BDLE9BQU9XLE9BQUFBLE1BQU0sQ0FBQ0UsSUFBSSxDQUFDSCxJQUFJSSxNQUFNLEVBQUVKLElBQUlLLFVBQVUsRUFBRUws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QzlDNVcsV0FBV0E7Z0JBQ1hvVSxvQkFBb0IsQ0FBWS9GLFNBQUFBLEVBQUFBLEtBQUtDLFNBQVMsQ0FBQzJJLFFBQU87WUFDeEQ7UUFDRjtRQUNBLE1BQU0sSUFBSWhiLE1BQ1IsbUJBQW1CK0QsVUFBUyxXQUFZcU8sS0FBS0MsU0FBUyxDQUFDMkksUUFBTyxFQUNoRTtJQUNGO0lBRUEsT0FBT2pYO0FBQ1Q7QUN6RkE7O0NBRUEsR0FDTyxNQUFNdTNDLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvdXRpbHMvZWQyNTUxOS50cz8zZmE1Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvdXRpbHMvdG8tYnVmZmVyLnRzP2ZjYzIiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy91dGlscy9ib3JzaC1zY2hlbWEudHM/ODJiZiIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3B1YmxpY2tleS50cz8wZTgxIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvYWNjb3VudC50cz9kY2M1Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvYnBmLWxvYWRlci1kZXByZWNhdGVkLnRzPzM0Y2QiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy90cmFuc2FjdGlvbi9jb25zdGFudHMudHM/ZTZjZiIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3RyYW5zYWN0aW9uL2V4cGlyeS1jdXN0b20tZXJyb3JzLnRzP2M3MzQiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9tZXNzYWdlL2FjY291bnQta2V5cy50cz8yYjUzIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvbGF5b3V0LnRzP2JkYTIiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy91dGlscy9zaG9ydHZlYy1lbmNvZGluZy50cz81MzQ0Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvdXRpbHMvYXNzZXJ0LnRzP2Y4OTQiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9tZXNzYWdlL2NvbXBpbGVkLWtleXMudHM/ZWQzNSIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3V0aWxzL2d1YXJkZWQtYXJyYXktdXRpbHMudHM/NDgxMiIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL21lc3NhZ2UvbGVnYWN5LnRzPzQzMDMiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9tZXNzYWdlL3YwLnRzP2JhOGQiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9tZXNzYWdlL3ZlcnNpb25lZC50cz84YzA2Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvdHJhbnNhY3Rpb24vbGVnYWN5LnRzPzM3YjciLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy90cmFuc2FjdGlvbi9tZXNzYWdlLnRzP2IwNGUiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy90cmFuc2FjdGlvbi92ZXJzaW9uZWQudHM/NzgzNCIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3RpbWluZy50cz8wNDIzIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvc3lzdmFyLnRzPzMwMmEiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9lcnJvcnMudHM/ODBkYyIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3V0aWxzL3NlbmQtYW5kLWNvbmZpcm0tdHJhbnNhY3Rpb24udHM/NTg2NyIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3V0aWxzL3NsZWVwLnRzP2E0N2EiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9pbnN0cnVjdGlvbi50cz9lMDU2Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvZmVlLWNhbGN1bGF0b3IudHM/YTkzYSIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL25vbmNlLWFjY291bnQudHM/ODkxZCIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3V0aWxzL2JpZ2ludC50cz84ZWE2Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvcHJvZ3JhbXMvc3lzdGVtLnRzPzlmNzIiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9sb2FkZXIudHM/ZGE5NyIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL2JwZi1sb2FkZXIudHM/MTVhNiIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zQDIuMS4zL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcz8yNmEzIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHVtYW5pemUtbXNAMS4yLjEvbm9kZV9tb2R1bGVzL2h1bWFuaXplLW1zL2luZGV4LmpzP2JjMTUiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hZ2VudGtlZXBhbGl2ZUA0LjUuMC9ub2RlX21vZHVsZXMvYWdlbnRrZWVwYWxpdmUvbGliL2NvbnN0YW50cy5qcz9kYzExIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYWdlbnRrZWVwYWxpdmVANC41LjAvbm9kZV9tb2R1bGVzL2FnZW50a2VlcGFsaXZlL2xpYi9hZ2VudC5qcz80ZmY0Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYWdlbnRrZWVwYWxpdmVANC41LjAvbm9kZV9tb2R1bGVzL2FnZW50a2VlcGFsaXZlL2xpYi9odHRwc19hZ2VudC5qcz9jY2ZkIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYWdlbnRrZWVwYWxpdmVANC41LjAvbm9kZV9tb2R1bGVzL2FnZW50a2VlcGFsaXZlL2luZGV4LmpzPzkyN2MiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXN0YWJsZS1zdHJpbmdpZnlAMS4wLjAvbm9kZV9tb2R1bGVzL2Zhc3Qtc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcz9hNWU0Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvZXBvY2gtc2NoZWR1bGUudHM/MzhhNyIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL2ZldGNoLWltcGwudHM/NDBhYiIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3JwYy13ZWJzb2NrZXQudHM/MTU1OSIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL2FjY291bnQtZGF0YS50cz9mYTNlIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvcHJvZ3JhbXMvYWRkcmVzcy1sb29rdXAtdGFibGUvc3RhdGUudHM/MDczMCIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3V0aWxzL21ha2VXZWJzb2NrZXRVcmwudHM/MzlkZiIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL2Nvbm5lY3Rpb24udHM/ZDYzYiIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL2tleXBhaXIudHM/MTFhNyIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3Byb2dyYW1zL2FkZHJlc3MtbG9va3VwLXRhYmxlL2luZGV4LnRzP2E3ZTkiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9wcm9ncmFtcy9jb21wdXRlLWJ1ZGdldC50cz82NjRhIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvcHJvZ3JhbXMvZWQyNTUxOS50cz82NTE1Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvdXRpbHMvc2VjcDI1NmsxLnRzPzY5NDgiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9wcm9ncmFtcy9zZWNwMjU2azEudHM/MjJlYyIsIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vc3JjL3Byb2dyYW1zL3N0YWtlLnRzPzQyMjQiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy9wcm9ncmFtcy92b3RlLnRzPzRjMDAiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy92YWxpZGF0b3ItaW5mby50cz84OTFjIiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvdm90ZS1hY2NvdW50LnRzPzdkNDYiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy91dGlscy9jbHVzdGVyLnRzP2YwMzQiLCJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uL3NyYy91dGlscy9zZW5kLWFuZC1jb25maXJtLXJhdy10cmFuc2FjdGlvbi50cz9iZTQ1Iiwid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi9zcmMvaW5kZXgudHM/NTJkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2VkMjU1MTl9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5cbi8qKlxuICogQSA2NCBieXRlIHNlY3JldCBrZXksIHRoZSBmaXJzdCAzMiBieXRlcyBvZiB3aGljaCBpcyB0aGVcbiAqIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAqIFJlYWQgbW9yZTogaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dhcm5lci8yMDExLzExLzI5L2VkMjU1MTkta2V5cy9cbiAqL1xudHlwZSBFZDI1NTE5U2VjcmV0S2V5ID0gVWludDhBcnJheTtcblxuLyoqXG4gKiBFZDI1NTE5IEtleXBhaXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFZDI1NTE5S2V5cGFpciB7XG4gIHB1YmxpY0tleTogVWludDhBcnJheTtcbiAgc2VjcmV0S2V5OiBFZDI1NTE5U2VjcmV0S2V5O1xufVxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVQcml2YXRlS2V5ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlS2V5cGFpciA9ICgpOiBFZDI1NTE5S2V5cGFpciA9PiB7XG4gIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByaXZhdGVTY2FsYXIpO1xuICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHNlY3JldEtleS5zZXQocHJpdmF0ZVNjYWxhcik7XG4gIHNlY3JldEtleS5zZXQocHVibGljS2V5LCAzMik7XG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5LFxuICAgIHNlY3JldEtleSxcbiAgfTtcbn07XG5leHBvcnQgY29uc3QgZ2V0UHVibGljS2V5ID0gZWQyNTUxOS5nZXRQdWJsaWNLZXk7XG5leHBvcnQgZnVuY3Rpb24gaXNPbkN1cnZlKHB1YmxpY0tleTogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IHNpZ24gPSAoXG4gIG1lc3NhZ2U6IFBhcmFtZXRlcnM8dHlwZW9mIGVkMjU1MTkuc2lnbj5bMF0sXG4gIHNlY3JldEtleTogRWQyNTUxOVNlY3JldEtleSxcbikgPT4gZWQyNTUxOS5zaWduKG1lc3NhZ2UsIHNlY3JldEtleS5zbGljZSgwLCAzMikpO1xuZXhwb3J0IGNvbnN0IHZlcmlmeSA9IGVkMjU1MTkudmVyaWZ5O1xuIiwiaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5cbmV4cG9ydCBjb25zdCB0b0J1ZmZlciA9IChhcnI6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+KTogQnVmZmVyID0+IHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmIChhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gIH1cbn07XG4iLCJpbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7c2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgZGVzZXJpYWxpemVVbmNoZWNrZWR9IGZyb20gJ2JvcnNoJztcblxuLy8gQ2xhc3Mgd3JhcHBpbmcgYSBwbGFpbiBvYmplY3RcbmV4cG9ydCBjbGFzcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG5cbiAgZW5jb2RlKCk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzKSk7XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlKGRhdGE6IEJ1ZmZlcik6IGFueSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG5cbiAgc3RhdGljIGRlY29kZVVuY2hlY2tlZChkYXRhOiBCdWZmZXIpOiBhbnkge1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVVuY2hlY2tlZChTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxufVxuXG4vLyBDbGFzcyByZXByZXNlbnRpbmcgYSBSdXN0LWNvbXBhdGlibGUgZW51bSwgc2luY2UgZW51bXMgYXJlIG9ubHkgc3RyaW5ncyBvclxuLy8gbnVtYmVycyBpbiBwdXJlIEpTXG5leHBvcnQgY2xhc3MgRW51bSBleHRlbmRzIFN0cnVjdCB7XG4gIGVudW06IHN0cmluZyA9ICcnO1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0gY2FuIG9ubHkgdGFrZSBzaW5nbGUgdmFsdWUnKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykubWFwKGtleSA9PiB7XG4gICAgICB0aGlzLmVudW0gPSBrZXk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFNPTEFOQV9TQ0hFTUE6IE1hcDxGdW5jdGlvbiwgYW55PiA9IG5ldyBNYXAoKTtcbiIsImltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHtzaGEyNTZ9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcblxuaW1wb3J0IHtpc09uQ3VydmV9IGZyb20gJy4vdXRpbHMvZWQyNTUxOSc7XG5pbXBvcnQge1N0cnVjdCwgU09MQU5BX1NDSEVNQX0gZnJvbSAnLi91dGlscy9ib3JzaC1zY2hlbWEnO1xuaW1wb3J0IHt0b0J1ZmZlcn0gZnJvbSAnLi91dGlscy90by1idWZmZXInO1xuXG4vKipcbiAqIE1heGltdW0gbGVuZ3RoIG9mIGRlcml2ZWQgcHVia2V5IHNlZWRcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9TRUVEX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFNpemUgb2YgcHVibGljIGtleSBpbiBieXRlc1xuICovXG5leHBvcnQgY29uc3QgUFVCTElDX0tFWV9MRU5HVEggPSAzMjtcblxuLyoqXG4gKiBWYWx1ZSB0byBiZSBjb252ZXJ0ZWQgaW50byBwdWJsaWMga2V5XG4gKi9cbmV4cG9ydCB0eXBlIFB1YmxpY0tleUluaXREYXRhID1cbiAgfCBudW1iZXJcbiAgfCBzdHJpbmdcbiAgfCBVaW50OEFycmF5XG4gIHwgQXJyYXk8bnVtYmVyPlxuICB8IFB1YmxpY0tleURhdGE7XG5cbi8qKlxuICogSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgUHVibGljS2V5IGNsYXNzXG4gKi9cbmV4cG9ydCB0eXBlIFB1YmxpY0tleURhdGEgPSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JuOiBCTjtcbn07XG5cbmZ1bmN0aW9uIGlzUHVibGljS2V5RGF0YSh2YWx1ZTogUHVibGljS2V5SW5pdERhdGEpOiB2YWx1ZSBpcyBQdWJsaWNLZXlEYXRhIHtcbiAgcmV0dXJuICh2YWx1ZSBhcyBQdWJsaWNLZXlEYXRhKS5fYm4gIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gbG9jYWwgY291bnRlciB1c2VkIGJ5IFB1YmxpY0tleS51bmlxdWUoKVxubGV0IHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgPSAxO1xuXG4vKipcbiAqIEEgcHVibGljIGtleVxuICovXG5leHBvcnQgY2xhc3MgUHVibGljS2V5IGV4dGVuZHMgU3RydWN0IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYm46IEJOO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUHVibGljS2V5IG9iamVjdFxuICAgKiBAcGFyYW0gdmFsdWUgZWQyNTUxOSBwdWJsaWMga2V5IGFzIGJ1ZmZlciBvciBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZTogUHVibGljS2V5SW5pdERhdGEpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgaWYgKGlzUHVibGljS2V5RGF0YSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2JuID0gdmFsdWUuX2JuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBhc3N1bWUgYmFzZSA1OCBlbmNvZGluZyBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBiczU4LmRlY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkZWNvZGVkLmxlbmd0aCAhPSBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm4gPSBuZXcgQk4oZGVjb2RlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTih2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ibi5ieXRlTGVuZ3RoKCkgPiBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIFB1YmxpY0tleSBmb3IgdGVzdHMgYW5kIGJlbmNobWFya3MgdXNpbmcgYSBjb3VudGVyXG4gICAqL1xuICBzdGF0aWMgdW5pcXVlKCk6IFB1YmxpY0tleSB7XG4gICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleSh1bmlxdWVQdWJsaWNLZXlDb3VudGVyKTtcbiAgICB1bmlxdWVQdWJsaWNLZXlDb3VudGVyICs9IDE7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoa2V5LnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcHVibGljIGtleSB2YWx1ZS4gVGhlIGJhc2U1OC1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyBhbGwgb25lcyAoYXMgc2VlbiBiZWxvdylcbiAgICogVGhlIHVuZGVybHlpbmcgQk4gbnVtYmVyIGlzIDMyIGJ5dGVzIHRoYXQgYXJlIGFsbCB6ZXJvc1xuICAgKi9cbiAgc3RhdGljIGRlZmF1bHQ6IFB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwdWJsaWNLZXk6IFB1YmxpY0tleSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9ibi5lcShwdWJsaWNLZXkuX2JuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvQmFzZTU4KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGJzNTguZW5jb2RlKHRoaXMudG9CeXRlcygpKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnl0ZXMoKTogVWludDhBcnJheSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnVmZmVyKCk6IEJ1ZmZlciB7XG4gICAgY29uc3QgYiA9IHRoaXMuX2JuLnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgaWYgKGIubGVuZ3RoID09PSBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuXG4gICAgY29uc3QgemVyb1BhZCA9IEJ1ZmZlci5hbGxvYygzMik7XG4gICAgYi5jb3B5KHplcm9QYWQsIDMyIC0gYi5sZW5ndGgpO1xuICAgIHJldHVybiB6ZXJvUGFkO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBQdWJsaWNLZXkoJHt0aGlzLnRvU3RyaW5nKCl9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqIFRoZSBwcm9ncmFtIElEIHdpbGwgYWxzbyBzZXJ2ZSBhcyB0aGUgb3duZXIgb2YgdGhlIHB1YmxpYyBrZXksIGdpdmluZ1xuICAgKiBpdCBwZXJtaXNzaW9uIHRvIHdyaXRlIGRhdGEgdG8gdGhlIGFjY291bnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVXaXRoU2VlZChcbiAgICBmcm9tUHVibGljS2V5OiBQdWJsaWNLZXksXG4gICAgc2VlZDogc3RyaW5nLFxuICAgIHByb2dyYW1JZDogUHVibGljS2V5LFxuICApOiBQcm9taXNlPFB1YmxpY0tleT4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgZnJvbVB1YmxpY0tleS50b0J1ZmZlcigpLFxuICAgICAgQnVmZmVyLmZyb20oc2VlZCksXG4gICAgICBwcm9ncmFtSWQudG9CdWZmZXIoKSxcbiAgICBdKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHNoYTI1NihidWZmZXIpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwcm9ncmFtIGFkZHJlc3MgZnJvbSBzZWVkcyBhbmQgYSBwcm9ncmFtIElELlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKFxuICAgIHNlZWRzOiBBcnJheTxCdWZmZXIgfCBVaW50OEFycmF5PixcbiAgICBwcm9ncmFtSWQ6IFB1YmxpY0tleSxcbiAgKTogUHVibGljS2V5IHtcbiAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHNlZWRzLmZvckVhY2goZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgIGlmIChzZWVkLmxlbmd0aCA+IE1BWF9TRUVEX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNYXggc2VlZCBsZW5ndGggZXhjZWVkZWRgKTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgdG9CdWZmZXIoc2VlZCldKTtcbiAgICB9KTtcbiAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHByb2dyYW1JZC50b0J1ZmZlcigpLFxuICAgICAgQnVmZmVyLmZyb20oJ1Byb2dyYW1EZXJpdmVkQWRkcmVzcycpLFxuICAgIF0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgaWYgKGlzT25DdXJ2ZShwdWJsaWNLZXlCeXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZWVkcywgYWRkcmVzcyBtdXN0IGZhbGwgb2ZmIHRoZSBjdXJ2ZWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVQcm9ncmFtQWRkcmVzcyhcbiAgICBzZWVkczogQXJyYXk8QnVmZmVyIHwgVWludDhBcnJheT4sXG4gICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXksXG4gICk6IFByb21pc2U8UHVibGljS2V5PiB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3NcbiAgICpcbiAgICogVmFsaWQgcHJvZ3JhbSBhZGRyZXNzZXMgbXVzdCBmYWxsIG9mZiB0aGUgZWQyNTUxOSBjdXJ2ZS4gIFRoaXMgZnVuY3Rpb25cbiAgICogaXRlcmF0ZXMgYSBub25jZSB1bnRpbCBpdCBmaW5kcyBvbmUgdGhhdCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIHNlZWRzXG4gICAqIHJlc3VsdHMgaW4gYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3MuXG4gICAqL1xuICBzdGF0aWMgZmluZFByb2dyYW1BZGRyZXNzU3luYyhcbiAgICBzZWVkczogQXJyYXk8QnVmZmVyIHwgVWludDhBcnJheT4sXG4gICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXksXG4gICk6IFtQdWJsaWNLZXksIG51bWJlcl0ge1xuICAgIGxldCBub25jZSA9IDI1NTtcbiAgICBsZXQgYWRkcmVzcztcbiAgICB3aGlsZSAobm9uY2UgIT0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VlZHNXaXRoTm9uY2UgPSBzZWVkcy5jb25jYXQoQnVmZmVyLmZyb20oW25vbmNlXSkpO1xuICAgICAgICBhZGRyZXNzID0gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHNXaXRoTm9uY2UsIHByb2dyYW1JZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBub25jZS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYWRkcmVzcywgbm9uY2VdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGEgdmlhYmxlIHByb2dyYW0gYWRkcmVzcyBub25jZWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgZmluZFByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZFByb2dyYW1BZGRyZXNzKFxuICAgIHNlZWRzOiBBcnJheTxCdWZmZXIgfCBVaW50OEFycmF5PixcbiAgICBwcm9ncmFtSWQ6IFB1YmxpY0tleSxcbiAgKTogUHJvbWlzZTxbUHVibGljS2V5LCBudW1iZXJdPiB7XG4gICAgcmV0dXJuIHRoaXMuZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGF0IGEgcHVia2V5IGlzIG9uIHRoZSBlZDI1NTE5IGN1cnZlLlxuICAgKi9cbiAgc3RhdGljIGlzT25DdXJ2ZShwdWJrZXlEYXRhOiBQdWJsaWNLZXlJbml0RGF0YSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHB1YmtleSA9IG5ldyBQdWJsaWNLZXkocHVia2V5RGF0YSk7XG4gICAgcmV0dXJuIGlzT25DdXJ2ZShwdWJrZXkudG9CeXRlcygpKTtcbiAgfVxufVxuXG5TT0xBTkFfU0NIRU1BLnNldChQdWJsaWNLZXksIHtcbiAga2luZDogJ3N0cnVjdCcsXG4gIGZpZWxkczogW1snX2JuJywgJ3UyNTYnXV0sXG59KTtcbiIsImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuXG5pbXBvcnQge2dlbmVyYXRlUHJpdmF0ZUtleSwgZ2V0UHVibGljS2V5fSBmcm9tICcuL3V0aWxzL2VkMjU1MTknO1xuaW1wb3J0IHt0b0J1ZmZlcn0gZnJvbSAnLi91dGlscy90by1idWZmZXInO1xuaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4vcHVibGlja2V5JztcblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleSBwYWlyIChwdWJsaWMgYW5kIHNlY3JldCBrZXlzKS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2MS4xMC4wLCBwbGVhc2UgdXNlIHtAbGluayBLZXlwYWlyfSBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgQWNjb3VudCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfcHVibGljS2V5OiBCdWZmZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfc2VjcmV0S2V5OiBCdWZmZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBY2NvdW50IG9iamVjdFxuICAgKlxuICAgKiBJZiB0aGUgc2VjcmV0S2V5IHBhcmFtZXRlciBpcyBub3QgcHJvdmlkZWQgYSBuZXcga2V5IHBhaXIgaXMgcmFuZG9tbHlcbiAgICogY3JlYXRlZCBmb3IgdGhlIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBTZWNyZXQga2V5IGZvciB0aGUgYWNjb3VudFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2VjcmV0S2V5PzogVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4pIHtcbiAgICBpZiAoc2VjcmV0S2V5KSB7XG4gICAgICBjb25zdCBzZWNyZXRLZXlCdWZmZXIgPSB0b0J1ZmZlcihzZWNyZXRLZXkpO1xuICAgICAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDMyLCA2NCk7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMCwgMzIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSB0b0J1ZmZlcihnZW5lcmF0ZVByaXZhdGVLZXkoKSk7XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSB0b0J1ZmZlcihnZXRQdWJsaWNLZXkodGhpcy5fc2VjcmV0S2V5KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IGZvciB0aGlzIGFjY291bnRcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKTogUHVibGljS2V5IHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSAqKnVuZW5jcnlwdGVkKiogc2VjcmV0IGtleSBmb3IgdGhpcyBhY2NvdW50LiBUaGUgZmlyc3QgMzIgYnl0ZXNcbiAgICogaXMgdGhlIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAgICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICAgKi9cbiAgZ2V0IHNlY3JldEtleSgpOiBCdWZmZXIge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLl9zZWNyZXRLZXksIHRoaXMuX3B1YmxpY0tleV0sIDY0KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4vcHVibGlja2V5JztcblxuZXhwb3J0IGNvbnN0IEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleShcbiAgJ0JQRkxvYWRlcjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnLFxuKTtcbiIsIi8qKlxuICogTWF4aW11bSBvdmVyLXRoZS13aXJlIHNpemUgb2YgYSBUcmFuc2FjdGlvblxuICpcbiAqIDEyODAgaXMgSVB2NiBtaW5pbXVtIE1UVVxuICogNDAgYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIElQdjYgaGVhZGVyXG4gKiA4IGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBmcmFnbWVudCBoZWFkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IFBBQ0tFVF9EQVRBX1NJWkUgPSAxMjgwIC0gNDAgLSA4O1xuXG5leHBvcnQgY29uc3QgVkVSU0lPTl9QUkVGSVhfTUFTSyA9IDB4N2Y7XG5cbmV4cG9ydCBjb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG4iLCJleHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzaWduYXR1cmU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzaWduYXR1cmU6IHN0cmluZykge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiBibG9jayBoZWlnaHQgZXhjZWVkZWQuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IucHJvdG90eXBlLFxuICAnbmFtZScsXG4gIHtcbiAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcicsXG4gIH0sXG4pO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzaWduYXR1cmU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzaWduYXR1cmU6IHN0cmluZywgdGltZW91dFNlY29uZHM6IG51bWJlcikge1xuICAgIHN1cGVyKFxuICAgICAgYFRyYW5zYWN0aW9uIHdhcyBub3QgY29uZmlybWVkIGluICR7dGltZW91dFNlY29uZHMudG9GaXhlZChcbiAgICAgICAgMixcbiAgICAgICl9IHNlY29uZHMuIEl0IGlzIGAgK1xuICAgICAgICAndW5rbm93biBpZiBpdCBzdWNjZWVkZWQgb3IgZmFpbGVkLiBDaGVjayBzaWduYXR1cmUgJyArXG4gICAgICAgIGAke3NpZ25hdHVyZX0gdXNpbmcgdGhlIFNvbGFuYSBFeHBsb3JlciBvciBDTEkgdG9vbHMuYCxcbiAgICApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3InLFxufSk7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgU2lnbmF0dXJlICR7c2lnbmF0dXJlfSBoYXMgZXhwaXJlZDogdGhlIG5vbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcicsXG59KTtcbiIsImltcG9ydCB7TG9hZGVkQWRkcmVzc2VzfSBmcm9tICcuLi9jb25uZWN0aW9uJztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0IHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge01lc3NhZ2VDb21waWxlZEluc3RydWN0aW9ufSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IHR5cGUgQWNjb3VudEtleXNGcm9tTG9va3VwcyA9IExvYWRlZEFkZHJlc3NlcztcblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VBY2NvdW50S2V5cyB7XG4gIHN0YXRpY0FjY291bnRLZXlzOiBBcnJheTxQdWJsaWNLZXk+O1xuICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzPzogQWNjb3VudEtleXNGcm9tTG9va3VwcztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGF0aWNBY2NvdW50S2V5czogQXJyYXk8UHVibGljS2V5PixcbiAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzPzogQWNjb3VudEtleXNGcm9tTG9va3VwcyxcbiAgKSB7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gIH1cblxuICBrZXlTZWdtZW50cygpOiBBcnJheTxBcnJheTxQdWJsaWNLZXk+PiB7XG4gICAgY29uc3Qga2V5U2VnbWVudHMgPSBbdGhpcy5zdGF0aWNBY2NvdW50S2V5c107XG4gICAgaWYgKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAga2V5U2VnbWVudHMucHVzaCh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUpO1xuICAgICAga2V5U2VnbWVudHMucHVzaCh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5U2VnbWVudHM7XG4gIH1cblxuICBnZXQoaW5kZXg6IG51bWJlcik6IFB1YmxpY0tleSB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChjb25zdCBrZXlTZWdtZW50IG9mIHRoaXMua2V5U2VnbWVudHMoKSkge1xuICAgICAgaWYgKGluZGV4IDwga2V5U2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGtleVNlZ21lbnRbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggLT0ga2V5U2VnbWVudC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5sZW5ndGg7XG4gIH1cblxuICBjb21waWxlSW5zdHJ1Y3Rpb25zKFxuICAgIGluc3RydWN0aW9uczogQXJyYXk8VHJhbnNhY3Rpb25JbnN0cnVjdGlvbj4sXG4gICk6IEFycmF5PE1lc3NhZ2VDb21waWxlZEluc3RydWN0aW9uPiB7XG4gICAgLy8gQmFpbCBlYXJseSBpZiBhbnkgYWNjb3VudCBpbmRleGVzIHdvdWxkIG92ZXJmbG93IGEgdThcbiAgICBjb25zdCBVOF9NQVggPSAyNTU7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gVThfTUFYICsgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IGluZGV4IG92ZXJmbG93IGVuY291bnRlcmVkIGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGtleUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5U2VnbWVudHMoKVxuICAgICAgLmZsYXQoKVxuICAgICAgLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAga2V5SW5kZXhNYXAuc2V0KGtleS50b0Jhc2U1OCgpLCBpbmRleCk7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IGZpbmRLZXlJbmRleCA9IChrZXk6IFB1YmxpY0tleSkgPT4ge1xuICAgICAgY29uc3Qga2V5SW5kZXggPSBrZXlJbmRleE1hcC5nZXQoa2V5LnRvQmFzZTU4KCkpO1xuICAgICAgaWYgKGtleUluZGV4ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRW5jb3VudGVyZWQgYW4gdW5rbm93biBpbnN0cnVjdGlvbiBhY2NvdW50IGtleSBkdXJpbmcgY29tcGlsYXRpb24nLFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGtleUluZGV4O1xuICAgIH07XG5cbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLm1hcCgoaW5zdHJ1Y3Rpb24pOiBNZXNzYWdlQ29tcGlsZWRJbnN0cnVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZmluZEtleUluZGV4KGluc3RydWN0aW9uLnByb2dyYW1JZCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+XG4gICAgICAgICAgZmluZEtleUluZGV4KG1ldGEucHVia2V5KSxcbiAgICAgICAgKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5cbmltcG9ydCB7Vm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnc30gZnJvbSAnLi9wcm9ncmFtcy92b3RlJztcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgcHVibGljIGtleVxuICovXG5leHBvcnQgY29uc3QgcHVibGljS2V5ID0gKHByb3BlcnR5OiBzdHJpbmcgPSAncHVibGljS2V5JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LmJsb2IoMzIsIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHNpZ25hdHVyZVxuICovXG5leHBvcnQgY29uc3Qgc2lnbmF0dXJlID0gKHByb3BlcnR5OiBzdHJpbmcgPSAnc2lnbmF0dXJlJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LmJsb2IoNjQsIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIDY0Yml0IHVuc2lnbmVkIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCB1aW50NjQgPSAocHJvcGVydHk6IHN0cmluZyA9ICd1aW50NjQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYig4LCBwcm9wZXJ0eSk7XG59O1xuXG5pbnRlcmZhY2UgSVJ1c3RTdHJpbmdTaGltXG4gIGV4dGVuZHMgT21pdDxcbiAgICBCdWZmZXJMYXlvdXQuU3RydWN0dXJlPFxuICAgICAgUmVhZG9ubHk8e1xuICAgICAgICBsZW5ndGg6IG51bWJlcjtcbiAgICAgICAgbGVuZ3RoUGFkZGluZzogbnVtYmVyO1xuICAgICAgICBjaGFyczogVWludDhBcnJheTtcbiAgICAgIH0+XG4gICAgPixcbiAgICAnZGVjb2RlJyB8ICdlbmNvZGUnIHwgJ3JlcGxpY2F0ZSdcbiAgPiB7XG4gIGFsbG9jOiAoc3RyOiBzdHJpbmcpID0+IG51bWJlcjtcbiAgZGVjb2RlOiAoYjogVWludDhBcnJheSwgb2Zmc2V0PzogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIGVuY29kZTogKHN0cjogc3RyaW5nLCBiOiBVaW50OEFycmF5LCBvZmZzZXQ/OiBudW1iZXIpID0+IG51bWJlcjtcbiAgcmVwbGljYXRlOiAocHJvcGVydHk6IHN0cmluZykgPT4gdGhpcztcbn1cblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgUnVzdCBTdHJpbmcgdHlwZVxuICovXG5leHBvcnQgY29uc3QgcnVzdFN0cmluZyA9IChcbiAgcHJvcGVydHk6IHN0cmluZyA9ICdzdHJpbmcnLFxuKTogQnVmZmVyTGF5b3V0LkxheW91dDxzdHJpbmc+ID0+IHtcbiAgY29uc3QgcnNsID0gQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgICBSZWFkb25seTx7XG4gICAgICBsZW5ndGg/OiBudW1iZXI7XG4gICAgICBsZW5ndGhQYWRkaW5nPzogbnVtYmVyO1xuICAgICAgY2hhcnM6IFVpbnQ4QXJyYXk7XG4gICAgfT5cbiAgPihcbiAgICBbXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGgnKSxcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2xlbmd0aFBhZGRpbmcnKSxcbiAgICAgIEJ1ZmZlckxheW91dC5ibG9iKEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdjaGFycycpLFxuICAgIF0sXG4gICAgcHJvcGVydHksXG4gICk7XG4gIGNvbnN0IF9kZWNvZGUgPSByc2wuZGVjb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgX2VuY29kZSA9IHJzbC5lbmNvZGUuYmluZChyc2wpO1xuXG4gIGNvbnN0IHJzbFNoaW0gPSByc2wgYXMgdW5rbm93biBhcyBJUnVzdFN0cmluZ1NoaW07XG5cbiAgcnNsU2hpbS5kZWNvZGUgPSAoYjogVWludDhBcnJheSwgb2Zmc2V0PzogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IF9kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gZGF0YVsnY2hhcnMnXS50b1N0cmluZygpO1xuICB9O1xuXG4gIHJzbFNoaW0uZW5jb2RlID0gKHN0cjogc3RyaW5nLCBiOiBVaW50OEFycmF5LCBvZmZzZXQ/OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgY2hhcnM6IEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKSxcbiAgICB9O1xuICAgIHJldHVybiBfZW5jb2RlKGRhdGEsIGIsIG9mZnNldCk7XG4gIH07XG5cbiAgcnNsU2hpbS5hbGxvYyA9IChzdHI6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArXG4gICAgICBCdWZmZXIuZnJvbShzdHIsICd1dGY4JykubGVuZ3RoXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gcnNsU2hpbTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhbiBBdXRob3JpemVkIG9iamVjdFxuICovXG5leHBvcnQgY29uc3QgYXV0aG9yaXplZCA9IChwcm9wZXJ0eTogc3RyaW5nID0gJ2F1dGhvcml6ZWQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0PFxuICAgIFJlYWRvbmx5PHtcbiAgICAgIHN0YWtlcjogVWludDhBcnJheTtcbiAgICAgIHdpdGhkcmF3ZXI6IFVpbnQ4QXJyYXk7XG4gICAgfT5cbiAgPihbcHVibGljS2V5KCdzdGFrZXInKSwgcHVibGljS2V5KCd3aXRoZHJhd2VyJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBMb2NrdXAgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCBsb2NrdXAgPSAocHJvcGVydHk6IHN0cmluZyA9ICdsb2NrdXAnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0PFxuICAgIFJlYWRvbmx5PHtcbiAgICAgIGN1c3RvZGlhbjogVWludDhBcnJheTtcbiAgICAgIGVwb2NoOiBudW1iZXI7XG4gICAgICB1bml4VGltZXN0YW1wOiBudW1iZXI7XG4gICAgfT5cbiAgPihcbiAgICBbXG4gICAgICBCdWZmZXJMYXlvdXQubnM2NCgndW5peFRpbWVzdGFtcCcpLFxuICAgICAgQnVmZmVyTGF5b3V0Lm5zNjQoJ2Vwb2NoJyksXG4gICAgICBwdWJsaWNLZXkoJ2N1c3RvZGlhbicpLFxuICAgIF0sXG4gICAgcHJvcGVydHksXG4gICk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUluaXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCB2b3RlSW5pdCA9IChwcm9wZXJ0eTogc3RyaW5nID0gJ3ZvdGVJbml0JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgICBSZWFkb25seTx7XG4gICAgICBhdXRob3JpemVkVm90ZXI6IFVpbnQ4QXJyYXk7XG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlcjogVWludDhBcnJheTtcbiAgICAgIGNvbW1pc3Npb246IG51bWJlcjtcbiAgICAgIG5vZGVQdWJrZXk6IFVpbnQ4QXJyYXk7XG4gICAgfT5cbiAgPihcbiAgICBbXG4gICAgICBwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSxcbiAgICAgIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyksXG4gICAgICBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRXaXRoZHJhd2VyJyksXG4gICAgICBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKSxcbiAgICBdLFxuICAgIHByb3BlcnR5LFxuICApO1xufTtcblxuLyoqXG4gKiAgTGF5b3V0IGZvciBhIFZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3Mgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzID0gKFxuICBwcm9wZXJ0eTogc3RyaW5nID0gJ3ZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MnLFxuKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0PFZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M+KFxuICAgIFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ3ZvdGVBdXRob3JpemF0aW9uVHlwZScpLFxuICAgICAgcHVibGljS2V5KCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5JyksXG4gICAgICBydXN0U3RyaW5nKCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQnKSxcbiAgICAgIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLFxuICAgIF0sXG4gICAgcHJvcGVydHksXG4gICk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsb2ModHlwZTogYW55LCBmaWVsZHM6IGFueSk6IG51bWJlciB7XG4gIGNvbnN0IGdldEl0ZW1BbGxvYyA9IChpdGVtOiBhbnkpOiBudW1iZXIgPT4ge1xuICAgIGlmIChpdGVtLnNwYW4gPj0gMCkge1xuICAgICAgcmV0dXJuIGl0ZW0uc3BhbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlbS5hbGxvYyhmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH0gZWxzZSBpZiAoJ2NvdW50JyBpbiBpdGVtICYmICdlbGVtZW50TGF5b3V0JyBpbiBpdGVtKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpdGVtLnByb3BlcnR5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQubGVuZ3RoICogZ2V0SXRlbUFsbG9jKGl0ZW0uZWxlbWVudExheW91dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnZmllbGRzJyBpbiBpdGVtKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgYFN0cnVjdHVyZWAgd2hvc2Ugc2l6ZSBuZWVkcyB0byBiZSByZWN1cnNpdmVseSBtZWFzdXJlZC5cbiAgICAgIHJldHVybiBnZXRBbGxvYyh7bGF5b3V0OiBpdGVtfSwgZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9XG4gICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGFsbG9jYXRlZCBzaXplIG9mIGxheW91dFxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIGxldCBhbGxvYyA9IDA7XG4gIHR5cGUubGF5b3V0LmZpZWxkcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcbiAgICBhbGxvYyArPSBnZXRJdGVtQWxsb2MoaXRlbSk7XG4gIH0pO1xuXG4gIHJldHVybiBhbGxvYztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWNvZGVMZW5ndGgoYnl0ZXM6IEFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICBsZXQgbGVuID0gMDtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSBieXRlcy5zaGlmdCgpIGFzIG51bWJlcjtcbiAgICBsZW4gfD0gKGVsZW0gJiAweDdmKSA8PCAoc2l6ZSAqIDcpO1xuICAgIHNpemUgKz0gMTtcbiAgICBpZiAoKGVsZW0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVMZW5ndGgoYnl0ZXM6IEFycmF5PG51bWJlcj4sIGxlbjogbnVtYmVyKSB7XG4gIGxldCByZW1fbGVuID0gbGVuO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSByZW1fbGVuICYgMHg3ZjtcbiAgICByZW1fbGVuID4+PSA3O1xuICAgIGlmIChyZW1fbGVuID09IDApIHtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbSB8PSAweDgwO1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChcbiAgY29uZGl0aW9uOiB1bmtub3duLFxuICBtZXNzYWdlPzogc3RyaW5nLFxuKTogYXNzZXJ0cyBjb25kaXRpb24ge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cbiIsImltcG9ydCB7TWVzc2FnZUhlYWRlciwgTWVzc2FnZUFkZHJlc3NUYWJsZUxvb2t1cH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQge0FjY291bnRLZXlzRnJvbUxvb2t1cHN9IGZyb20gJy4vYWNjb3VudC1rZXlzJztcbmltcG9ydCB7QWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudH0gZnJvbSAnLi4vcHJvZ3JhbXMnO1xuaW1wb3J0IHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQge1B1YmxpY0tleX0gZnJvbSAnLi4vcHVibGlja2V5JztcblxuZXhwb3J0IHR5cGUgQ29tcGlsZWRLZXlNZXRhID0ge1xuICBpc1NpZ25lcjogYm9vbGVhbjtcbiAgaXNXcml0YWJsZTogYm9vbGVhbjtcbiAgaXNJbnZva2VkOiBib29sZWFuO1xufTtcblxudHlwZSBLZXlNZXRhTWFwID0gTWFwPHN0cmluZywgQ29tcGlsZWRLZXlNZXRhPjtcblxuZXhwb3J0IGNsYXNzIENvbXBpbGVkS2V5cyB7XG4gIHBheWVyOiBQdWJsaWNLZXk7XG4gIGtleU1ldGFNYXA6IEtleU1ldGFNYXA7XG5cbiAgY29uc3RydWN0b3IocGF5ZXI6IFB1YmxpY0tleSwga2V5TWV0YU1hcDogS2V5TWV0YU1hcCkge1xuICAgIHRoaXMucGF5ZXIgPSBwYXllcjtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSBrZXlNZXRhTWFwO1xuICB9XG5cbiAgc3RhdGljIGNvbXBpbGUoXG4gICAgaW5zdHJ1Y3Rpb25zOiBBcnJheTxUcmFuc2FjdGlvbkluc3RydWN0aW9uPixcbiAgICBwYXllcjogUHVibGljS2V5LFxuICApOiBDb21waWxlZEtleXMge1xuICAgIGNvbnN0IGtleU1ldGFNYXA6IEtleU1ldGFNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZ2V0T3JJbnNlcnREZWZhdWx0ID0gKHB1YmtleTogUHVibGljS2V5KTogQ29tcGlsZWRLZXlNZXRhID0+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBwdWJrZXkudG9CYXNlNTgoKTtcbiAgICAgIGxldCBrZXlNZXRhID0ga2V5TWV0YU1hcC5nZXQoYWRkcmVzcyk7XG4gICAgICBpZiAoa2V5TWV0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleU1ldGEgPSB7XG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGlzSW52b2tlZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGtleU1ldGFNYXAuc2V0KGFkZHJlc3MsIGtleU1ldGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleU1ldGE7XG4gICAgfTtcblxuICAgIGNvbnN0IHBheWVyS2V5TWV0YSA9IGdldE9ySW5zZXJ0RGVmYXVsdChwYXllcik7XG4gICAgcGF5ZXJLZXlNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICBwYXllcktleU1ldGEuaXNXcml0YWJsZSA9IHRydWU7XG5cbiAgICBmb3IgKGNvbnN0IGl4IG9mIGluc3RydWN0aW9ucykge1xuICAgICAgZ2V0T3JJbnNlcnREZWZhdWx0KGl4LnByb2dyYW1JZCkuaXNJbnZva2VkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudE1ldGEgb2YgaXgua2V5cykge1xuICAgICAgICBjb25zdCBrZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KGFjY291bnRNZXRhLnB1YmtleSk7XG4gICAgICAgIGtleU1ldGEuaXNTaWduZXIgfHw9IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgICBrZXlNZXRhLmlzV3JpdGFibGUgfHw9IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21waWxlZEtleXMocGF5ZXIsIGtleU1ldGFNYXApO1xuICB9XG5cbiAgZ2V0TWVzc2FnZUNvbXBvbmVudHMoKTogW01lc3NhZ2VIZWFkZXIsIEFycmF5PFB1YmxpY0tleT5dIHtcbiAgICBjb25zdCBtYXBFbnRyaWVzID0gWy4uLnRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCldO1xuICAgIGFzc2VydChtYXBFbnRyaWVzLmxlbmd0aCA8PSAyNTYsICdNYXggc3RhdGljIGFjY291bnQga2V5cyBsZW5ndGggZXhjZWVkZWQnKTtcblxuICAgIGNvbnN0IHdyaXRhYmxlU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKFxuICAgICAgKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSxcbiAgICApO1xuICAgIGNvbnN0IHJlYWRvbmx5U2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKFxuICAgICAgKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUsXG4gICAgKTtcbiAgICBjb25zdCB3cml0YWJsZU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcihcbiAgICAgIChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlLFxuICAgICk7XG4gICAgY29uc3QgcmVhZG9ubHlOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoXG4gICAgICAoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUsXG4gICAgKTtcblxuICAgIGNvbnN0IGhlYWRlcjogTWVzc2FnZUhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogd3JpdGFibGVTaWduZXJzLmxlbmd0aCArIHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiByZWFkb25seU5vblNpZ25lcnMubGVuZ3RoLFxuICAgIH07XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzXG4gICAge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB3cml0YWJsZVNpZ25lcnMubGVuZ3RoID4gMCxcbiAgICAgICAgJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSB3cml0YWJsZSBzaWduZXIga2V5JyxcbiAgICAgICk7XG4gICAgICBjb25zdCBbcGF5ZXJBZGRyZXNzXSA9IHdyaXRhYmxlU2lnbmVyc1swXTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGF5ZXJBZGRyZXNzID09PSB0aGlzLnBheWVyLnRvQmFzZTU4KCksXG4gICAgICAgICdFeHBlY3RlZCBmaXJzdCB3cml0YWJsZSBzaWduZXIga2V5IHRvIGJlIHRoZSBmZWUgcGF5ZXInLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFtcbiAgICAgIC4uLndyaXRhYmxlU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksXG4gICAgICAuLi5yZWFkb25seVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLFxuICAgICAgLi4ud3JpdGFibGVOb25TaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSxcbiAgICAgIC4uLnJlYWRvbmx5Tm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksXG4gICAgXTtcblxuICAgIHJldHVybiBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c107XG4gIH1cblxuICBleHRyYWN0VGFibGVMb29rdXAoXG4gICAgbG9va3VwVGFibGU6IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQsXG4gICk6IFtNZXNzYWdlQWRkcmVzc1RhYmxlTG9va3VwLCBBY2NvdW50S2V5c0Zyb21Mb29rdXBzXSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgW3dyaXRhYmxlSW5kZXhlcywgZHJhaW5lZFdyaXRhYmxlS2V5c10gPVxuICAgICAgdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUoXG4gICAgICAgIGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3NlcyxcbiAgICAgICAga2V5TWV0YSA9PlxuICAgICAgICAgICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiBrZXlNZXRhLmlzV3JpdGFibGUsXG4gICAgICApO1xuICAgIGNvbnN0IFtyZWFkb25seUluZGV4ZXMsIGRyYWluZWRSZWFkb25seUtleXNdID1cbiAgICAgIHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKFxuICAgICAgICBsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsXG4gICAgICAgIGtleU1ldGEgPT5cbiAgICAgICAgICAha2V5TWV0YS5pc1NpZ25lciAmJiAha2V5TWV0YS5pc0ludm9rZWQgJiYgIWtleU1ldGEuaXNXcml0YWJsZSxcbiAgICAgICk7XG5cbiAgICAvLyBEb24ndCBleHRyYWN0IGxvb2t1cCBpZiBubyBrZXlzIHdlcmUgZm91bmRcbiAgICBpZiAod3JpdGFibGVJbmRleGVzLmxlbmd0aCA9PT0gMCAmJiByZWFkb25seUluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgYWNjb3VudEtleTogbG9va3VwVGFibGUua2V5LFxuICAgICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlcyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHdyaXRhYmxlOiBkcmFpbmVkV3JpdGFibGVLZXlzLFxuICAgICAgICByZWFkb25seTogZHJhaW5lZFJlYWRvbmx5S2V5cyxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUoXG4gICAgbG9va3VwVGFibGVFbnRyaWVzOiBBcnJheTxQdWJsaWNLZXk+LFxuICAgIGtleU1ldGFGaWx0ZXI6IChrZXlNZXRhOiBDb21waWxlZEtleU1ldGEpID0+IGJvb2xlYW4sXG4gICk6IFtBcnJheTxudW1iZXI+LCBBcnJheTxQdWJsaWNLZXk+XSB7XG4gICAgY29uc3QgbG9va3VwVGFibGVJbmRleGVzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgZHJhaW5lZEtleXMgPSBuZXcgQXJyYXkoKTtcblxuICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIGtleU1ldGFdIG9mIHRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChrZXlNZXRhRmlsdGVyKGtleU1ldGEpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXggPSBsb29rdXBUYWJsZUVudHJpZXMuZmluZEluZGV4KGVudHJ5ID0+XG4gICAgICAgICAgZW50cnkuZXF1YWxzKGtleSksXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZUluZGV4ID49IDApIHtcbiAgICAgICAgICBhc3NlcnQobG9va3VwVGFibGVJbmRleCA8IDI1NiwgJ01heCBsb29rdXAgdGFibGUgaW5kZXggZXhjZWVkZWQnKTtcbiAgICAgICAgICBsb29rdXBUYWJsZUluZGV4ZXMucHVzaChsb29rdXBUYWJsZUluZGV4KTtcbiAgICAgICAgICBkcmFpbmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgdGhpcy5rZXlNZXRhTWFwLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbG9va3VwVGFibGVJbmRleGVzLCBkcmFpbmVkS2V5c107XG4gIH1cbn1cbiIsImNvbnN0IEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSA9ICdSZWFjaGVkIGVuZCBvZiBidWZmZXIgdW5leHBlY3RlZGx5JztcblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NoaWZ0YCwgYnV0IHRocm93cyBpZiB0aGUgYXJyYXkgaXMgemVyby1sZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBndWFyZGVkU2hpZnQ8VD4oYnl0ZUFycmF5OiBUW10pOiBUIHtcbiAgaWYgKGJ5dGVBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNoaWZ0KCkgYXMgVDtcbn1cblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NwbGljZWAsIGJ1dCB0aHJvd3MgaWYgdGhlIHNlY3Rpb24gYmVpbmcgc3BsaWNlZCBvdXQgZXh0ZW5kcyBwYXN0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd1YXJkZWRTcGxpY2U8VD4oXG4gIGJ5dGVBcnJheTogVFtdLFxuICAuLi5hcmdzOlxuICAgIHwgW3N0YXJ0OiBudW1iZXIsIGRlbGV0ZUNvdW50PzogbnVtYmVyXVxuICAgIHwgW3N0YXJ0OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW11dXG4pOiBUW10ge1xuICBjb25zdCBbc3RhcnRdID0gYXJncztcbiAgaWYgKFxuICAgIGFyZ3MubGVuZ3RoID09PSAyIC8vIEltcGxpZXMgdGhhdCBgZGVsZXRlQ291bnRgIHdhcyBzdXBwbGllZFxuICAgICAgPyBzdGFydCArIChhcmdzWzFdID8/IDApID4gYnl0ZUFycmF5Lmxlbmd0aFxuICAgICAgOiBzdGFydCA+PSBieXRlQXJyYXkubGVuZ3RoXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc3BsaWNlKFxuICAgIC4uLihhcmdzIGFzIFBhcmFtZXRlcnM8dHlwZW9mIEFycmF5LnByb3RvdHlwZS5zcGxpY2U+KSxcbiAgKTtcbn1cbiIsImltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcblxuaW1wb3J0IHtQdWJsaWNLZXksIFBVQkxJQ19LRVlfTEVOR1RIfSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0IHR5cGUge0Jsb2NraGFzaH0gZnJvbSAnLi4vYmxvY2toYXNoJztcbmltcG9ydCAqIGFzIExheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IHtQQUNLRVRfREFUQV9TSVpFLCBWRVJTSU9OX1BSRUZJWF9NQVNLfSBmcm9tICcuLi90cmFuc2FjdGlvbi9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgc2hvcnR2ZWMgZnJvbSAnLi4vdXRpbHMvc2hvcnR2ZWMtZW5jb2RpbmcnO1xuaW1wb3J0IHt0b0J1ZmZlcn0gZnJvbSAnLi4vdXRpbHMvdG8tYnVmZmVyJztcbmltcG9ydCB7XG4gIE1lc3NhZ2VIZWFkZXIsXG4gIE1lc3NhZ2VBZGRyZXNzVGFibGVMb29rdXAsXG4gIE1lc3NhZ2VDb21waWxlZEluc3RydWN0aW9uLFxufSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7VHJhbnNhY3Rpb25JbnN0cnVjdGlvbn0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHtDb21waWxlZEtleXN9IGZyb20gJy4vY29tcGlsZWQta2V5cyc7XG5pbXBvcnQge01lc3NhZ2VBY2NvdW50S2V5c30gZnJvbSAnLi9hY2NvdW50LWtleXMnO1xuaW1wb3J0IHtndWFyZGVkU2hpZnQsIGd1YXJkZWRTcGxpY2V9IGZyb20gJy4uL3V0aWxzL2d1YXJkZWQtYXJyYXktdXRpbHMnO1xuXG4vKipcbiAqIEFuIGluc3RydWN0aW9uIHRvIGV4ZWN1dGUgYnkgYSBwcm9ncmFtXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2dyYW1JZEluZGV4XG4gKiBAcHJvcGVydHkge251bWJlcltdfSBhY2NvdW50c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGRhdGFcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGlsZWRJbnN0cnVjdGlvbiA9IHtcbiAgLyoqIEluZGV4IGludG8gdGhlIHRyYW5zYWN0aW9uIGtleXMgYXJyYXkgaW5kaWNhdGluZyB0aGUgcHJvZ3JhbSBhY2NvdW50IHRoYXQgZXhlY3V0ZXMgdGhpcyBpbnN0cnVjdGlvbiAqL1xuICBwcm9ncmFtSWRJbmRleDogbnVtYmVyO1xuICAvKiogT3JkZXJlZCBpbmRpY2VzIGludG8gdGhlIHRyYW5zYWN0aW9uIGtleXMgYXJyYXkgaW5kaWNhdGluZyB3aGljaCBhY2NvdW50cyB0byBwYXNzIHRvIHRoZSBwcm9ncmFtICovXG4gIGFjY291bnRzOiBudW1iZXJbXTtcbiAgLyoqIFRoZSBwcm9ncmFtIGlucHV0IGRhdGEgZW5jb2RlZCBhcyBiYXNlIDU4ICovXG4gIGRhdGE6IHN0cmluZztcbn07XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUFyZ3MgPSB7XG4gIC8qKiBUaGUgbWVzc2FnZSBoZWFkZXIsIGlkZW50aWZ5aW5nIHNpZ25lZCBhbmQgcmVhZC1vbmx5IGBhY2NvdW50S2V5c2AgKi9cbiAgaGVhZGVyOiBNZXNzYWdlSGVhZGVyO1xuICAvKiogQWxsIHRoZSBhY2NvdW50IGtleXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uICovXG4gIGFjY291bnRLZXlzOiBzdHJpbmdbXSB8IFB1YmxpY0tleVtdO1xuICAvKiogVGhlIGhhc2ggb2YgYSByZWNlbnQgbGVkZ2VyIGJsb2NrICovXG4gIHJlY2VudEJsb2NraGFzaDogQmxvY2toYXNoO1xuICAvKiogSW5zdHJ1Y3Rpb25zIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBpbiBzZXF1ZW5jZSBhbmQgY29tbWl0dGVkIGluIG9uZSBhdG9taWMgdHJhbnNhY3Rpb24gaWYgYWxsIHN1Y2NlZWQuICovXG4gIGluc3RydWN0aW9uczogQ29tcGlsZWRJbnN0cnVjdGlvbltdO1xufTtcblxuZXhwb3J0IHR5cGUgQ29tcGlsZUxlZ2FjeUFyZ3MgPSB7XG4gIHBheWVyS2V5OiBQdWJsaWNLZXk7XG4gIGluc3RydWN0aW9uczogQXJyYXk8VHJhbnNhY3Rpb25JbnN0cnVjdGlvbj47XG4gIHJlY2VudEJsb2NraGFzaDogQmxvY2toYXNoO1xufTtcblxuLyoqXG4gKiBMaXN0IG9mIGluc3RydWN0aW9ucyB0byBiZSBwcm9jZXNzZWQgYXRvbWljYWxseVxuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZSB7XG4gIGhlYWRlcjogTWVzc2FnZUhlYWRlcjtcbiAgYWNjb3VudEtleXM6IFB1YmxpY0tleVtdO1xuICByZWNlbnRCbG9ja2hhc2g6IEJsb2NraGFzaDtcbiAgaW5zdHJ1Y3Rpb25zOiBDb21waWxlZEluc3RydWN0aW9uW107XG5cbiAgcHJpdmF0ZSBpbmRleFRvUHJvZ3JhbUlkczogTWFwPG51bWJlciwgUHVibGljS2V5PiA9IG5ldyBNYXA8XG4gICAgbnVtYmVyLFxuICAgIFB1YmxpY0tleVxuICA+KCk7XG5cbiAgY29uc3RydWN0b3IoYXJnczogTWVzc2FnZUFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSBhcmdzLmFjY291bnRLZXlzLm1hcChhY2NvdW50ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudCkpO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLmluc3RydWN0aW9ucy5mb3JFYWNoKGl4ID0+XG4gICAgICB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnNldChcbiAgICAgICAgaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIHRoaXMuYWNjb3VudEtleXNbaXgucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgZ2V0IHZlcnNpb24oKTogJ2xlZ2FjeScge1xuICAgIHJldHVybiAnbGVnYWN5JztcbiAgfVxuXG4gIGdldCBzdGF0aWNBY2NvdW50S2V5cygpOiBBcnJheTxQdWJsaWNLZXk+IHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cztcbiAgfVxuXG4gIGdldCBjb21waWxlZEluc3RydWN0aW9ucygpOiBBcnJheTxNZXNzYWdlQ29tcGlsZWRJbnN0cnVjdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9ucy5tYXAoXG4gICAgICAoaXgpOiBNZXNzYWdlQ29tcGlsZWRJbnN0cnVjdGlvbiA9PiAoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSksXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgZ2V0IGFkZHJlc3NUYWJsZUxvb2t1cHMoKTogQXJyYXk8TWVzc2FnZUFkZHJlc3NUYWJsZUxvb2t1cD4ge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldEFjY291bnRLZXlzKCk6IE1lc3NhZ2VBY2NvdW50S2V5cyB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXModGhpcy5zdGF0aWNBY2NvdW50S2V5cyk7XG4gIH1cblxuICBzdGF0aWMgY29tcGlsZShhcmdzOiBDb21waWxlTGVnYWN5QXJncyk6IE1lc3NhZ2Uge1xuICAgIGNvbnN0IGNvbXBpbGVkS2V5cyA9IENvbXBpbGVkS2V5cy5jb21waWxlKGFyZ3MuaW5zdHJ1Y3Rpb25zLCBhcmdzLnBheWVyS2V5KTtcbiAgICBjb25zdCBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c10gPSBjb21waWxlZEtleXMuZ2V0TWVzc2FnZUNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IG5ldyBNZXNzYWdlQWNjb3VudEtleXMoc3RhdGljQWNjb3VudEtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IGFjY291bnRLZXlzLmNvbXBpbGVJbnN0cnVjdGlvbnMoYXJncy5pbnN0cnVjdGlvbnMpLm1hcChcbiAgICAgIChpeDogTWVzc2FnZUNvbXBpbGVkSW5zdHJ1Y3Rpb24pOiBDb21waWxlZEluc3RydWN0aW9uID0+ICh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudHM6IGl4LmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICBkYXRhOiBiczU4LmVuY29kZShpeC5kYXRhKSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIGFjY291bnRLZXlzOiBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgfSk7XG4gIH1cblxuICBpc0FjY291bnRTaWduZXIoaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuXG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBudW1TaWduZWRBY2NvdW50cyA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bnNpZ25lZEFjY291bnRJbmRleCA9IGluZGV4IC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1VbnNpZ25lZEFjY291bnRzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9XG4gICAgICAgIG51bVVuc2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gdW5zaWduZWRBY2NvdW50SW5kZXggPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPVxuICAgICAgICBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gaW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgIH1cbiAgfVxuXG4gIGlzUHJvZ3JhbUlkKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoaW5kZXgpO1xuICB9XG5cbiAgcHJvZ3JhbUlkcygpOiBQdWJsaWNLZXlbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnZhbHVlcygpXTtcbiAgfVxuXG4gIG5vblByb2dyYW1JZHMoKTogUHVibGljS2V5W10ge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcigoXywgaW5kZXgpID0+ICF0aGlzLmlzUHJvZ3JhbUlkKGluZGV4KSk7XG4gIH1cblxuICBzZXJpYWxpemUoKTogQnVmZmVyIHtcbiAgICBjb25zdCBudW1LZXlzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGg7XG5cbiAgICBsZXQga2V5Q291bnQ6IG51bWJlcltdID0gW107XG4gICAgc2hvcnR2ZWMuZW5jb2RlTGVuZ3RoKGtleUNvdW50LCBudW1LZXlzKTtcblxuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7YWNjb3VudHMsIHByb2dyYW1JZEluZGV4fSA9IGluc3RydWN0aW9uO1xuICAgICAgY29uc3QgZGF0YSA9IEFycmF5LmZyb20oYnM1OC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSkpO1xuXG4gICAgICBsZXQga2V5SW5kaWNlc0NvdW50OiBudW1iZXJbXSA9IFtdO1xuICAgICAgc2hvcnR2ZWMuZW5jb2RlTGVuZ3RoKGtleUluZGljZXNDb3VudCwgYWNjb3VudHMubGVuZ3RoKTtcblxuICAgICAgbGV0IGRhdGFDb3VudDogbnVtYmVyW10gPSBbXTtcbiAgICAgIHNob3J0dmVjLmVuY29kZUxlbmd0aChkYXRhQ291bnQsIGRhdGEubGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGtleUluZGljZXNDb3VudDogQnVmZmVyLmZyb20oa2V5SW5kaWNlc0NvdW50KSxcbiAgICAgICAga2V5SW5kaWNlczogYWNjb3VudHMsXG4gICAgICAgIGRhdGFMZW5ndGg6IEJ1ZmZlci5mcm9tKGRhdGFDb3VudCksXG4gICAgICAgIGRhdGEsXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgbGV0IGluc3RydWN0aW9uQ291bnQ6IG51bWJlcltdID0gW107XG4gICAgc2hvcnR2ZWMuZW5jb2RlTGVuZ3RoKGluc3RydWN0aW9uQ291bnQsIGluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGxldCBpbnN0cnVjdGlvbkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBCdWZmZXIuZnJvbShpbnN0cnVjdGlvbkNvdW50KS5jb3B5KGluc3RydWN0aW9uQnVmZmVyKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggPSBpbnN0cnVjdGlvbkNvdW50Lmxlbmd0aDtcblxuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgICAgICAgUmVhZG9ubHk8e1xuICAgICAgICAgIGRhdGE6IG51bWJlcltdO1xuICAgICAgICAgIGRhdGFMZW5ndGg6IFVpbnQ4QXJyYXk7XG4gICAgICAgICAga2V5SW5kaWNlczogbnVtYmVyW107XG4gICAgICAgICAga2V5SW5kaWNlc0NvdW50OiBVaW50OEFycmF5O1xuICAgICAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXI7XG4gICAgICAgIH0+XG4gICAgICA+KFtcbiAgICAgICAgQnVmZmVyTGF5b3V0LnU4KCdwcm9ncmFtSWRJbmRleCcpLFxuXG4gICAgICAgIEJ1ZmZlckxheW91dC5ibG9iKFxuICAgICAgICAgIGluc3RydWN0aW9uLmtleUluZGljZXNDb3VudC5sZW5ndGgsXG4gICAgICAgICAgJ2tleUluZGljZXNDb3VudCcsXG4gICAgICAgICksXG4gICAgICAgIEJ1ZmZlckxheW91dC5zZXEoXG4gICAgICAgICAgQnVmZmVyTGF5b3V0LnU4KCdrZXlJbmRleCcpLFxuICAgICAgICAgIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLFxuICAgICAgICAgICdrZXlJbmRpY2VzJyxcbiAgICAgICAgKSxcbiAgICAgICAgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24uZGF0YUxlbmd0aC5sZW5ndGgsICdkYXRhTGVuZ3RoJyksXG4gICAgICAgIEJ1ZmZlckxheW91dC5zZXEoXG4gICAgICAgICAgQnVmZmVyTGF5b3V0LnU4KCd1c2VyZGF0dW0nKSxcbiAgICAgICAgICBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAnZGF0YScsXG4gICAgICAgICksXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZShcbiAgICAgICAgaW5zdHJ1Y3Rpb24sXG4gICAgICAgIGluc3RydWN0aW9uQnVmZmVyLFxuICAgICAgICBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCxcbiAgICAgICk7XG4gICAgICBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBpbnN0cnVjdGlvbkJ1ZmZlci5zbGljZSgwLCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCk7XG5cbiAgICBjb25zdCBzaWduRGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBSZWFkb25seTx7XG4gICAgICAgIGtleUNvdW50OiBVaW50OEFycmF5O1xuICAgICAgICBrZXlzOiBVaW50OEFycmF5W107XG4gICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IFVpbnQ4QXJyYXk7XG4gICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogVWludDhBcnJheTtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBVaW50OEFycmF5O1xuICAgICAgICByZWNlbnRCbG9ja2hhc2g6IFVpbnQ4QXJyYXk7XG4gICAgICB9PlxuICAgID4oW1xuICAgICAgQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLFxuICAgICAgQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSxcbiAgICAgIEJ1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKSxcbiAgICAgIEJ1ZmZlckxheW91dC5ibG9iKGtleUNvdW50Lmxlbmd0aCwgJ2tleUNvdW50JyksXG4gICAgICBCdWZmZXJMYXlvdXQuc2VxKExheW91dC5wdWJsaWNLZXkoJ2tleScpLCBudW1LZXlzLCAna2V5cycpLFxuICAgICAgTGF5b3V0LnB1YmxpY0tleSgncmVjZW50QmxvY2toYXNoJyksXG4gICAgXSk7XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlc10pLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogQnVmZmVyLmZyb20oW1xuICAgICAgICB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgXSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IEJ1ZmZlci5mcm9tKFtcbiAgICAgICAgdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzLFxuICAgICAgXSksXG4gICAgICBrZXlDb3VudDogQnVmZmVyLmZyb20oa2V5Q291bnQpLFxuICAgICAga2V5czogdGhpcy5hY2NvdW50S2V5cy5tYXAoa2V5ID0+IHRvQnVmZmVyKGtleS50b0J5dGVzKCkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpLFxuICAgIH07XG5cbiAgICBsZXQgc2lnbkRhdGEgPSBCdWZmZXIuYWxsb2MoMjA0OCk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2lnbkRhdGFMYXlvdXQuZW5jb2RlKHRyYW5zYWN0aW9uLCBzaWduRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIuY29weShzaWduRGF0YSwgbGVuZ3RoKTtcbiAgICByZXR1cm4gc2lnbkRhdGEuc2xpY2UoMCwgbGVuZ3RoICsgaW5zdHJ1Y3Rpb25CdWZmZXIubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21waWxlZCBtZXNzYWdlIGludG8gYSBNZXNzYWdlIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcjogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4pOiBNZXNzYWdlIHtcbiAgICAvLyBTbGljZSB1cCB3aXJlIGRhdGFcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG5cbiAgICBjb25zdCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBpZiAoXG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMgIT09XG4gICAgICAobnVtUmVxdWlyZWRTaWduYXR1cmVzICYgVkVSU0lPTl9QUkVGSVhfTUFTSylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1ZlcnNpb25lZCBtZXNzYWdlcyBtdXN0IGJlIGRlc2VyaWFsaXplZCB3aXRoIFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUoKScsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcblxuICAgIGNvbnN0IGFjY291bnRDb3VudCA9IHNob3J0dmVjLmRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBhY2NvdW50S2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjb3VudENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnQgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgYWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KEJ1ZmZlci5mcm9tKGFjY291bnQpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjZW50QmxvY2toYXNoID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKTtcblxuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBzaG9ydHZlYy5kZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zOiBDb21waWxlZEluc3RydWN0aW9uW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRDb3VudCA9IHNob3J0dmVjLmRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgYWNjb3VudENvdW50KTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBzaG9ydHZlYy5kZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGFTbGljZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBkYXRhTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBiczU4LmVuY29kZShCdWZmZXIuZnJvbShkYXRhU2xpY2UpKTtcbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBkYXRhLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZUFyZ3MgPSB7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMsXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmVuY29kZShCdWZmZXIuZnJvbShyZWNlbnRCbG9ja2hhc2gpKSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgaW5zdHJ1Y3Rpb25zLFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICB9XG59XG4iLCJpbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuXG5pbXBvcnQgKiBhcyBMYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCB7QmxvY2toYXNofSBmcm9tICcuLi9ibG9ja2hhc2gnO1xuaW1wb3J0IHtcbiAgTWVzc2FnZUhlYWRlcixcbiAgTWVzc2FnZUFkZHJlc3NUYWJsZUxvb2t1cCxcbiAgTWVzc2FnZUNvbXBpbGVkSW5zdHJ1Y3Rpb24sXG59IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHtQdWJsaWNLZXksIFBVQkxJQ19LRVlfTEVOR1RIfSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0ICogYXMgc2hvcnR2ZWMgZnJvbSAnLi4vdXRpbHMvc2hvcnR2ZWMtZW5jb2RpbmcnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IHtQQUNLRVRfREFUQV9TSVpFLCBWRVJTSU9OX1BSRUZJWF9NQVNLfSBmcm9tICcuLi90cmFuc2FjdGlvbi9jb25zdGFudHMnO1xuaW1wb3J0IHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge0FkZHJlc3NMb29rdXBUYWJsZUFjY291bnR9IGZyb20gJy4uL3Byb2dyYW1zJztcbmltcG9ydCB7Q29tcGlsZWRLZXlzfSBmcm9tICcuL2NvbXBpbGVkLWtleXMnO1xuaW1wb3J0IHtBY2NvdW50S2V5c0Zyb21Mb29rdXBzLCBNZXNzYWdlQWNjb3VudEtleXN9IGZyb20gJy4vYWNjb3VudC1rZXlzJztcbmltcG9ydCB7Z3VhcmRlZFNoaWZ0LCBndWFyZGVkU3BsaWNlfSBmcm9tICcuLi91dGlscy9ndWFyZGVkLWFycmF5LXV0aWxzJztcblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5leHBvcnQgdHlwZSBNZXNzYWdlVjBBcmdzID0ge1xuICAvKiogVGhlIG1lc3NhZ2UgaGVhZGVyLCBpZGVudGlmeWluZyBzaWduZWQgYW5kIHJlYWQtb25seSBgYWNjb3VudEtleXNgICovXG4gIGhlYWRlcjogTWVzc2FnZUhlYWRlcjtcbiAgLyoqIFRoZSBzdGF0aWMgYWNjb3VudCBrZXlzIHVzZWQgYnkgdGhpcyB0cmFuc2FjdGlvbiAqL1xuICBzdGF0aWNBY2NvdW50S2V5czogUHVibGljS2V5W107XG4gIC8qKiBUaGUgaGFzaCBvZiBhIHJlY2VudCBsZWRnZXIgYmxvY2sgKi9cbiAgcmVjZW50QmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gIC8qKiBJbnN0cnVjdGlvbnMgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGluIHNlcXVlbmNlIGFuZCBjb21taXR0ZWQgaW4gb25lIGF0b21pYyB0cmFuc2FjdGlvbiBpZiBhbGwgc3VjY2VlZC4gKi9cbiAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IE1lc3NhZ2VDb21waWxlZEluc3RydWN0aW9uW107XG4gIC8qKiBJbnN0cnVjdGlvbnMgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGluIHNlcXVlbmNlIGFuZCBjb21taXR0ZWQgaW4gb25lIGF0b21pYyB0cmFuc2FjdGlvbiBpZiBhbGwgc3VjY2VlZC4gKi9cbiAgYWRkcmVzc1RhYmxlTG9va3VwczogTWVzc2FnZUFkZHJlc3NUYWJsZUxvb2t1cFtdO1xufTtcblxuZXhwb3J0IHR5cGUgQ29tcGlsZVYwQXJncyA9IHtcbiAgcGF5ZXJLZXk6IFB1YmxpY0tleTtcbiAgaW5zdHJ1Y3Rpb25zOiBBcnJheTxUcmFuc2FjdGlvbkluc3RydWN0aW9uPjtcbiAgcmVjZW50QmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gIGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzPzogQXJyYXk8QWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudD47XG59O1xuXG5leHBvcnQgdHlwZSBHZXRBY2NvdW50S2V5c0FyZ3MgPVxuICB8IHtcbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHM/OiBBY2NvdW50S2V5c0Zyb21Mb29rdXBzIHwgbnVsbDtcbiAgICB9XG4gIHwge1xuICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHM/OiBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50W10gfCBudWxsO1xuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlVjAge1xuICBoZWFkZXI6IE1lc3NhZ2VIZWFkZXI7XG4gIHN0YXRpY0FjY291bnRLZXlzOiBBcnJheTxQdWJsaWNLZXk+O1xuICByZWNlbnRCbG9ja2hhc2g6IEJsb2NraGFzaDtcbiAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IEFycmF5PE1lc3NhZ2VDb21waWxlZEluc3RydWN0aW9uPjtcbiAgYWRkcmVzc1RhYmxlTG9va3VwczogQXJyYXk8TWVzc2FnZUFkZHJlc3NUYWJsZUxvb2t1cD47XG5cbiAgY29uc3RydWN0b3IoYXJnczogTWVzc2FnZVYwQXJncykge1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IGFyZ3Muc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gYXJncy5jb21waWxlZEluc3RydWN0aW9ucztcbiAgICB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSBhcmdzLmFkZHJlc3NUYWJsZUxvb2t1cHM7XG4gIH1cblxuICBnZXQgdmVyc2lvbigpOiAwIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCk6IG51bWJlciB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvdW50ICs9IGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIGdldEFjY291bnRLZXlzKGFyZ3M/OiBHZXRBY2NvdW50S2V5c0FyZ3MpOiBNZXNzYWdlQWNjb3VudEtleXMge1xuICAgIGxldCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzOiBBY2NvdW50S2V5c0Zyb21Mb29rdXBzIHwgdW5kZWZpbmVkO1xuICAgIGlmIChcbiAgICAgIGFyZ3MgJiZcbiAgICAgICdhY2NvdW50S2V5c0Zyb21Mb29rdXBzJyBpbiBhcmdzICYmXG4gICAgICBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHNcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5udW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzICE9XG4gICAgICAgIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGggK1xuICAgICAgICAgIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2Ugb2YgYSBtaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGFjY291bnQga2V5cyBmcm9tIGxvb2t1cHMnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYXJncyAmJlxuICAgICAgJ2FkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzJyBpbiBhcmdzICYmXG4gICAgICBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzXG4gICAgKSB7XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhcbiAgICAgICAgYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBhZGRyZXNzIHRhYmxlIGxvb2t1cHMgd2VyZSBub3QgcmVzb2x2ZWQnLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXMoXG4gICAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyxcbiAgICApO1xuICB9XG5cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaW5kZXggPCB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gIH1cblxuICBpc0FjY291bnRXcml0YWJsZShpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgY29uc3QgbnVtU3RhdGljQWNjb3VudEtleXMgPSB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPj0gbnVtU3RhdGljQWNjb3VudEtleXMpIHtcbiAgICAgIGNvbnN0IGxvb2t1cEFjY291bnRLZXlzSW5kZXggPSBpbmRleCAtIG51bVN0YXRpY0FjY291bnRLZXlzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyA9IHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5yZWR1Y2UoXG4gICAgICAgIChjb3VudCwgbG9va3VwKSA9PiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLFxuICAgICAgICAwLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBsb29rdXBBY2NvdW50S2V5c0luZGV4IDwgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cztcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IG51bVN0YXRpY0FjY291bnRLZXlzIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPVxuICAgICAgICBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID1cbiAgICAgICAgbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cblxuICByZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhcbiAgICBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50czogQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudFtdLFxuICApOiBBY2NvdW50S2V5c0Zyb21Mb29rdXBzIHtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzOiBBY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdLFxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IHRhYmxlTG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgdGFibGVBY2NvdW50ID0gYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMuZmluZChhY2NvdW50ID0+XG4gICAgICAgIGFjY291bnQua2V5LmVxdWFscyh0YWJsZUxvb2t1cC5hY2NvdW50S2V5KSxcbiAgICAgICk7XG4gICAgICBpZiAoIXRhYmxlQWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgZm9yIHRhYmxlIGtleSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLndyaXRhYmxlSW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaChcbiAgICAgICAgICAgIHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLnJlYWRvbmx5SW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaChcbiAgICAgICAgICAgIHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG5cbiAgc3RhdGljIGNvbXBpbGUoYXJnczogQ29tcGlsZVYwQXJncyk6IE1lc3NhZ2VWMCB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuXG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBBcnJheTxNZXNzYWdlQWRkcmVzc1RhYmxlTG9va3VwPigpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzRnJvbUxvb2t1cHM6IEFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB7XG4gICAgICB3cml0YWJsZTogbmV3IEFycmF5KCksXG4gICAgICByZWFkb25seTogbmV3IEFycmF5KCksXG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cFRhYmxlIG9mIGxvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgIGlmIChleHRyYWN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3NUYWJsZUxvb2t1cCwge3dyaXRhYmxlLCByZWFkb25seX1dID0gZXh0cmFjdFJlc3VsdDtcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCguLi53cml0YWJsZSk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCguLi5yZWFkb25seSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKFxuICAgICAgc3RhdGljQWNjb3VudEtleXMsXG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLFxuICAgICk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKFxuICAgICAgYXJncy5pbnN0cnVjdGlvbnMsXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMsXG4gICAgfSk7XG4gIH1cblxuICBzZXJpYWxpemUoKTogVWludDhBcnJheSB7XG4gICAgY29uc3QgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXk8bnVtYmVyPigpO1xuICAgIHNob3J0dmVjLmVuY29kZUxlbmd0aChcbiAgICAgIGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCxcbiAgICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLFxuICAgICk7XG5cbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5zZXJpYWxpemVJbnN0cnVjdGlvbnMoKTtcbiAgICBjb25zdCBlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoID0gQXJyYXk8bnVtYmVyPigpO1xuICAgIHNob3J0dmVjLmVuY29kZUxlbmd0aChcbiAgICAgIGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgsXG4gICAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCxcbiAgICApO1xuXG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMgPSB0aGlzLnNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKTtcbiAgICBjb25zdCBlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCA9IEFycmF5PG51bWJlcj4oKTtcbiAgICBzaG9ydHZlYy5lbmNvZGVMZW5ndGgoXG4gICAgICBlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCxcbiAgICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgsXG4gICAgKTtcblxuICAgIGNvbnN0IG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0PHtcbiAgICAgIHByZWZpeDogbnVtYmVyO1xuICAgICAgaGVhZGVyOiBNZXNzYWdlSGVhZGVyO1xuICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IFVpbnQ4QXJyYXk7XG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogQXJyYXk8VWludDhBcnJheT47XG4gICAgICByZWNlbnRCbG9ja2hhc2g6IFVpbnQ4QXJyYXk7XG4gICAgICBpbnN0cnVjdGlvbnNMZW5ndGg6IFVpbnQ4QXJyYXk7XG4gICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zOiBVaW50OEFycmF5O1xuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogVWludDhBcnJheTtcbiAgICAgIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzOiBVaW50OEFycmF5O1xuICAgIH0+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51OCgncHJlZml4JyksXG4gICAgICBCdWZmZXJMYXlvdXQuc3RydWN0PE1lc3NhZ2VIZWFkZXI+KFxuICAgICAgICBbXG4gICAgICAgICAgQnVmZmVyTGF5b3V0LnU4KCdudW1SZXF1aXJlZFNpZ25hdHVyZXMnKSxcbiAgICAgICAgICBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSxcbiAgICAgICAgICBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cycpLFxuICAgICAgICBdLFxuICAgICAgICAnaGVhZGVyJyxcbiAgICAgICksXG4gICAgICBCdWZmZXJMYXlvdXQuYmxvYihcbiAgICAgICAgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLmxlbmd0aCxcbiAgICAgICAgJ3N0YXRpY0FjY291bnRLZXlzTGVuZ3RoJyxcbiAgICAgICksXG4gICAgICBCdWZmZXJMYXlvdXQuc2VxKFxuICAgICAgICBMYXlvdXQucHVibGljS2V5KCksXG4gICAgICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLFxuICAgICAgICAnc3RhdGljQWNjb3VudEtleXMnLFxuICAgICAgKSxcbiAgICAgIExheW91dC5wdWJsaWNLZXkoJ3JlY2VudEJsb2NraGFzaCcpLFxuICAgICAgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSxcbiAgICAgIEJ1ZmZlckxheW91dC5ibG9iKFxuICAgICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCxcbiAgICAgICAgJ3NlcmlhbGl6ZWRJbnN0cnVjdGlvbnMnLFxuICAgICAgKSxcbiAgICAgIEJ1ZmZlckxheW91dC5ibG9iKFxuICAgICAgICBlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aC5sZW5ndGgsXG4gICAgICAgICdhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoJyxcbiAgICAgICksXG4gICAgICBCdWZmZXJMYXlvdXQuYmxvYihcbiAgICAgICAgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLFxuICAgICAgICAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnLFxuICAgICAgKSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgY29uc3QgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoXG4gICAgICB7XG4gICAgICAgIHByZWZpeDogTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYLFxuICAgICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgICBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoKSxcbiAgICAgICAgc3RhdGljQWNjb3VudEtleXM6IHRoaXMuc3RhdGljQWNjb3VudEtleXMubWFwKGtleSA9PiBrZXkudG9CeXRlcygpKSxcbiAgICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaCksXG4gICAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCksXG4gICAgICAgIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMsXG4gICAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGg6IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgIGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLFxuICAgICAgICApLFxuICAgICAgICBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyxcbiAgICAgIH0sXG4gICAgICBzZXJpYWxpemVkTWVzc2FnZSxcbiAgICApO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWVzc2FnZS5zbGljZSgwLCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCk7XG4gIH1cblxuICBwcml2YXRlIHNlcmlhbGl6ZUluc3RydWN0aW9ucygpOiBVaW50OEFycmF5IHtcbiAgICBsZXQgc2VyaWFsaXplZExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3QgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gQXJyYXk8bnVtYmVyPigpO1xuICAgICAgc2hvcnR2ZWMuZW5jb2RlTGVuZ3RoKFxuICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgsXG4gICAgICAgIGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVuY29kZWREYXRhTGVuZ3RoID0gQXJyYXk8bnVtYmVyPigpO1xuICAgICAgc2hvcnR2ZWMuZW5jb2RlTGVuZ3RoKGVuY29kZWREYXRhTGVuZ3RoLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCk7XG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdDx7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXI7XG4gICAgICAgIGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aDogVWludDhBcnJheTtcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IG51bWJlcltdO1xuICAgICAgICBlbmNvZGVkRGF0YUxlbmd0aDogVWludDhBcnJheTtcbiAgICAgICAgZGF0YTogVWludDhBcnJheTtcbiAgICAgIH0+KFtcbiAgICAgICAgQnVmZmVyTGF5b3V0LnU4KCdwcm9ncmFtSWRJbmRleCcpLFxuICAgICAgICBCdWZmZXJMYXlvdXQuYmxvYihcbiAgICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgubGVuZ3RoLFxuICAgICAgICAgICdlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgnLFxuICAgICAgICApLFxuICAgICAgICBCdWZmZXJMYXlvdXQuc2VxKFxuICAgICAgICAgIEJ1ZmZlckxheW91dC51OCgpLFxuICAgICAgICAgIGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCxcbiAgICAgICAgICAnYWNjb3VudEtleUluZGV4ZXMnLFxuICAgICAgICApLFxuICAgICAgICBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkRGF0YUxlbmd0aC5sZW5ndGgsICdlbmNvZGVkRGF0YUxlbmd0aCcpLFxuICAgICAgICBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKSxcbiAgICAgIF0pO1xuXG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZShcbiAgICAgICAge1xuICAgICAgICAgIHByb2dyYW1JZEluZGV4OiBpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLFxuICAgICAgICAgICksXG4gICAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICAgIGVuY29kZWREYXRhTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YUxlbmd0aCksXG4gICAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplZEluc3RydWN0aW9ucyxcbiAgICAgICAgc2VyaWFsaXplZExlbmd0aCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cblxuICBwcml2YXRlIHNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKTogVWludDhBcnJheSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoID0gQXJyYXk8bnVtYmVyPigpO1xuICAgICAgc2hvcnR2ZWMuZW5jb2RlTGVuZ3RoKFxuICAgICAgICBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLFxuICAgICAgICBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGggPSBBcnJheTxudW1iZXI+KCk7XG4gICAgICBzaG9ydHZlYy5lbmNvZGVMZW5ndGgoXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgsXG4gICAgICAgIGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdDx7XG4gICAgICAgIGFjY291bnRLZXk6IFVpbnQ4QXJyYXk7XG4gICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IFVpbnQ4QXJyYXk7XG4gICAgICAgIHdyaXRhYmxlSW5kZXhlczogbnVtYmVyW107XG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IFVpbnQ4QXJyYXk7XG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogbnVtYmVyW107XG4gICAgICB9PihbXG4gICAgICAgIExheW91dC5wdWJsaWNLZXkoJ2FjY291bnRLZXknKSxcbiAgICAgICAgQnVmZmVyTGF5b3V0LmJsb2IoXG4gICAgICAgICAgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aC5sZW5ndGgsXG4gICAgICAgICAgJ2VuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgnLFxuICAgICAgICApLFxuICAgICAgICBCdWZmZXJMYXlvdXQuc2VxKFxuICAgICAgICAgIEJ1ZmZlckxheW91dC51OCgpLFxuICAgICAgICAgIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLFxuICAgICAgICAgICd3cml0YWJsZUluZGV4ZXMnLFxuICAgICAgICApLFxuICAgICAgICBCdWZmZXJMYXlvdXQuYmxvYihcbiAgICAgICAgICBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoLmxlbmd0aCxcbiAgICAgICAgICAnZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCcsXG4gICAgICAgICksXG4gICAgICAgIEJ1ZmZlckxheW91dC5zZXEoXG4gICAgICAgICAgQnVmZmVyTGF5b3V0LnU4KCksXG4gICAgICAgICAgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgsXG4gICAgICAgICAgJ3JlYWRvbmx5SW5kZXhlcycsXG4gICAgICAgICksXG4gICAgICBdKTtcblxuICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQuZW5jb2RlKFxuICAgICAgICB7XG4gICAgICAgICAgYWNjb3VudEtleTogbG9va3VwLmFjY291bnRLZXkudG9CeXRlcygpLFxuICAgICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCxcbiAgICAgICAgICApLFxuICAgICAgICAgIHdyaXRhYmxlSW5kZXhlczogbG9va3VwLndyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgICBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgsXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLFxuICAgICAgICBzZXJpYWxpemVkTGVuZ3RoLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cblxuICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2U6IFVpbnQ4QXJyYXkpOiBNZXNzYWdlVjAge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZE1lc3NhZ2VdO1xuXG4gICAgY29uc3QgcHJlZml4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcbiAgICBhc3NlcnQoXG4gICAgICBwcmVmaXggIT09IG1hc2tlZFByZWZpeCxcbiAgICAgIGBFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSBidXQgcmVjZWl2ZWQgbGVnYWN5IG1lc3NhZ2VgLFxuICAgICk7XG5cbiAgICBjb25zdCB2ZXJzaW9uID0gbWFza2VkUHJlZml4O1xuICAgIGFzc2VydChcbiAgICAgIHZlcnNpb24gPT09IDAsXG4gICAgICBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2Ugd2l0aCB2ZXJzaW9uIDAgYnV0IGZvdW5kIHZlcnNpb24gJHt2ZXJzaW9ufWAsXG4gICAgKTtcblxuICAgIGNvbnN0IGhlYWRlcjogTWVzc2FnZUhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgfTtcblxuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gW107XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXNMZW5ndGggPSBzaG9ydHZlYy5kZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLnB1c2goXG4gICAgICAgIG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY2VudEJsb2NraGFzaCA9IGJzNTguZW5jb2RlKFxuICAgICAgZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSxcbiAgICApO1xuXG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25Db3VudCA9IHNob3J0dmVjLmRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zOiBNZXNzYWdlQ29tcGlsZWRJbnN0cnVjdGlvbltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IHNob3J0dmVjLmRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKFxuICAgICAgICBieXRlQXJyYXksXG4gICAgICAgIDAsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzTGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBzaG9ydHZlYy5kZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCkpO1xuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZGF0YSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCA9IHNob3J0dmVjLmRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHM6IE1lc3NhZ2VBZGRyZXNzVGFibGVMb29rdXBbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnRLZXkgPSBuZXcgUHVibGljS2V5KFxuICAgICAgICBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IHNob3J0dmVjLmRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzID0gZ3VhcmRlZFNwbGljZShcbiAgICAgICAgYnl0ZUFycmF5LFxuICAgICAgICAwLFxuICAgICAgICB3cml0YWJsZUluZGV4ZXNMZW5ndGgsXG4gICAgICApO1xuICAgICAgY29uc3QgcmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gc2hvcnR2ZWMuZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKFxuICAgICAgICBieXRlQXJyYXksXG4gICAgICAgIDAsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlc0xlbmd0aCxcbiAgICAgICk7XG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzLnB1c2goe1xuICAgICAgICBhY2NvdW50S2V5LFxuICAgICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQge1ZFUlNJT05fUFJFRklYX01BU0t9IGZyb20gJy4uL3RyYW5zYWN0aW9uL2NvbnN0YW50cyc7XG5pbXBvcnQge01lc3NhZ2V9IGZyb20gJy4vbGVnYWN5JztcbmltcG9ydCB7TWVzc2FnZVYwfSBmcm9tICcuL3YwJztcblxuZXhwb3J0IHR5cGUgVmVyc2lvbmVkTWVzc2FnZSA9IE1lc3NhZ2UgfCBNZXNzYWdlVjA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5leHBvcnQgY29uc3QgVmVyc2lvbmVkTWVzc2FnZSA9IHtcbiAgZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihzZXJpYWxpemVkTWVzc2FnZTogVWludDhBcnJheSk6ICdsZWdhY3knIHwgbnVtYmVyIHtcbiAgICBjb25zdCBwcmVmaXggPSBzZXJpYWxpemVkTWVzc2FnZVswXTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuXG4gICAgLy8gaWYgdGhlIGhpZ2hlc3QgYml0IG9mIHRoZSBwcmVmaXggaXMgbm90IHNldCwgdGhlIG1lc3NhZ2UgaXMgbm90IHZlcnNpb25lZFxuICAgIGlmIChtYXNrZWRQcmVmaXggPT09IHByZWZpeCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cblxuICAgIC8vIHRoZSBsb3dlciA3IGJpdHMgb2YgdGhlIHByZWZpeCBpbmRpY2F0ZSB0aGUgbWVzc2FnZSB2ZXJzaW9uXG4gICAgcmV0dXJuIG1hc2tlZFByZWZpeDtcbiAgfSxcblxuICBkZXNlcmlhbGl6ZTogKHNlcmlhbGl6ZWRNZXNzYWdlOiBVaW50OEFycmF5KTogVmVyc2lvbmVkTWVzc2FnZSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9XG4gICAgICBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgcmV0dXJuIE1lc3NhZ2UuZnJvbShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBNZXNzYWdlVjAuZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUcmFuc2FjdGlvbiBtZXNzYWdlIHZlcnNpb24gJHt2ZXJzaW9ufSBkZXNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZGAsXG4gICAgICApO1xuICAgIH1cbiAgfSxcbn07XG4iLCJpbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuXG5pbXBvcnQge1BBQ0tFVF9EQVRBX1NJWkUsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Q29ubmVjdGlvbn0gZnJvbSAnLi4vY29ubmVjdGlvbic7XG5pbXBvcnQge01lc3NhZ2V9IGZyb20gJy4uL21lc3NhZ2UnO1xuaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4uL3B1YmxpY2tleSc7XG5pbXBvcnQgKiBhcyBzaG9ydHZlYyBmcm9tICcuLi91dGlscy9zaG9ydHZlYy1lbmNvZGluZyc7XG5pbXBvcnQge3RvQnVmZmVyfSBmcm9tICcuLi91dGlscy90by1idWZmZXInO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IHR5cGUge1NpZ25lcn0gZnJvbSAnLi4va2V5cGFpcic7XG5pbXBvcnQgdHlwZSB7QmxvY2toYXNofSBmcm9tICcuLi9ibG9ja2hhc2gnO1xuaW1wb3J0IHR5cGUge0NvbXBpbGVkSW5zdHJ1Y3Rpb259IGZyb20gJy4uL21lc3NhZ2UnO1xuaW1wb3J0IHtzaWduLCB2ZXJpZnl9IGZyb20gJy4uL3V0aWxzL2VkMjU1MTknO1xuaW1wb3J0IHtndWFyZGVkU3BsaWNlfSBmcm9tICcuLi91dGlscy9ndWFyZGVkLWFycmF5LXV0aWxzJztcblxuLyoqIEBpbnRlcm5hbCAqL1xudHlwZSBNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyA9IHtcbiAgaW52YWxpZD86IFB1YmxpY0tleVtdO1xuICBtaXNzaW5nPzogUHVibGljS2V5W107XG59O1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBhcyBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uU2lnbmF0dXJlID0gc3RyaW5nO1xuXG5leHBvcnQgY29uc3QgZW51bSBUcmFuc2FjdGlvblN0YXR1cyB7XG4gIEJMT0NLSEVJR0hUX0VYQ0VFREVELFxuICBQUk9DRVNTRUQsXG4gIFRJTUVEX09VVCxcbiAgTk9OQ0VfSU5WQUxJRCxcbn1cblxuLyoqXG4gKiBEZWZhdWx0IChlbXB0eSkgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IERFRkFVTFRfU0lHTkFUVVJFID0gQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5cbi8qKlxuICogQWNjb3VudCBtZXRhZGF0YSB1c2VkIHRvIGRlZmluZSBpbnN0cnVjdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgQWNjb3VudE1ldGEgPSB7XG4gIC8qKiBBbiBhY2NvdW50J3MgcHVibGljIGtleSAqL1xuICBwdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFRydWUgaWYgYW4gaW5zdHJ1Y3Rpb24gcmVxdWlyZXMgYSB0cmFuc2FjdGlvbiBzaWduYXR1cmUgbWF0Y2hpbmcgYHB1YmtleWAgKi9cbiAgaXNTaWduZXI6IGJvb2xlYW47XG4gIC8qKiBUcnVlIGlmIHRoZSBgcHVia2V5YCBjYW4gYmUgbG9hZGVkIGFzIGEgcmVhZC13cml0ZSBhY2NvdW50LiAqL1xuICBpc1dyaXRhYmxlOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gb2JqZWN0IGZpZWxkcyB0aGF0IG1heSBiZSBpbml0aWFsaXplZCBhdCBjb25zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkN0b3JGaWVsZHMgPSB7XG4gIGtleXM6IEFycmF5PEFjY291bnRNZXRhPjtcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXk7XG4gIGRhdGE/OiBCdWZmZXI7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBUcmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICovXG5leHBvcnQgdHlwZSBTZXJpYWxpemVDb25maWcgPSB7XG4gIC8qKiBSZXF1aXJlIGFsbCB0cmFuc2FjdGlvbiBzaWduYXR1cmVzIGJlIHByZXNlbnQgKGRlZmF1bHQ6IHRydWUpICovXG4gIHJlcXVpcmVBbGxTaWduYXR1cmVzPzogYm9vbGVhbjtcbiAgLyoqIFZlcmlmeSBwcm92aWRlZCBzaWduYXR1cmVzIChkZWZhdWx0OiB0cnVlKSAqL1xuICB2ZXJpZnlTaWduYXR1cmVzPzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkpTT04ge1xuICBrZXlzOiB7XG4gICAgcHVia2V5OiBzdHJpbmc7XG4gICAgaXNTaWduZXI6IGJvb2xlYW47XG4gICAgaXNXcml0YWJsZTogYm9vbGVhbjtcbiAgfVtdO1xuICBwcm9ncmFtSWQ6IHN0cmluZztcbiAgZGF0YTogbnVtYmVyW107XG59XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAqIEJvb2xlYW4gcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgcHVia2V5IG5lZWRzIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBrZXlzOiBBcnJheTxBY2NvdW50TWV0YT47XG5cbiAgLyoqXG4gICAqIFByb2dyYW0gSWQgdG8gZXhlY3V0ZVxuICAgKi9cbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXk7XG5cbiAgLyoqXG4gICAqIFByb2dyYW0gaW5wdXRcbiAgICovXG4gIGRhdGE6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkcykge1xuICAgIHRoaXMucHJvZ3JhbUlkID0gb3B0cy5wcm9ncmFtSWQ7XG4gICAgdGhpcy5rZXlzID0gb3B0cy5rZXlzO1xuICAgIGlmIChvcHRzLmRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG9wdHMuZGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkpTT04ge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMubWFwKCh7cHVia2V5LCBpc1NpZ25lciwgaXNXcml0YWJsZX0pID0+ICh7XG4gICAgICAgIHB1YmtleTogcHVia2V5LnRvSlNPTigpLFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZSxcbiAgICAgIH0pKSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQudG9KU09OKCksXG4gICAgICBkYXRhOiBbLi4udGhpcy5kYXRhXSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGFpciBvZiBzaWduYXR1cmUgYW5kIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleVxuICovXG5leHBvcnQgdHlwZSBTaWduYXR1cmVQdWJrZXlQYWlyID0ge1xuICBzaWduYXR1cmU6IEJ1ZmZlciB8IG51bGw7XG4gIHB1YmxpY0tleTogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uQ3RvckZpZWxkc19ERVBSRUNBVEVEID0ge1xuICAvKiogT3B0aW9uYWwgbm9uY2UgaW5mb3JtYXRpb24gdXNlZCBmb3Igb2ZmbGluZSBub25jZSdkIHRyYW5zYWN0aW9ucyAqL1xuICBub25jZUluZm8/OiBOb25jZUluZm9ybWF0aW9uIHwgbnVsbDtcbiAgLyoqIFRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgKi9cbiAgZmVlUGF5ZXI/OiBQdWJsaWNLZXkgfCBudWxsO1xuICAvKiogT25lIG9yIG1vcmUgc2lnbmF0dXJlcyAqL1xuICBzaWduYXR1cmVzPzogQXJyYXk8U2lnbmF0dXJlUHVia2V5UGFpcj47XG4gIC8qKiBBIHJlY2VudCBibG9ja2hhc2ggKi9cbiAgcmVjZW50QmxvY2toYXNoPzogQmxvY2toYXNoO1xufTtcblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk7IGFuIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nXG4vLyBmb3JjZWQgdG8gb3Zlci1leHBvcnQgdHlwZXMgYnkgdGhlIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yNTgyMFxuZXhwb3J0IHR5cGUgVHJhbnNhY3Rpb25DdG9yRmllbGRzID0gVHJhbnNhY3Rpb25DdG9yRmllbGRzX0RFUFJFQ0FURUQ7XG5cbi8qKlxuICogQmxvY2toYXNoLWJhc2VkIHRyYW5zYWN0aW9ucyBoYXZlIGEgbGlmZXRpbWUgdGhhdCBhcmUgZGVmaW5lZCBieVxuICogdGhlIGJsb2NraGFzaCB0aGV5IGluY2x1ZGUuIEFueSB0cmFuc2FjdGlvbiB3aG9zZSBibG9ja2hhc2ggaXNcbiAqIHRvbyBvbGQgd2lsbCBiZSByZWplY3RlZC5cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yID0ge1xuICAvKiogVGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciAqL1xuICBmZWVQYXllcj86IFB1YmxpY0tleSB8IG51bGw7XG4gIC8qKiBPbmUgb3IgbW9yZSBzaWduYXR1cmVzICovXG4gIHNpZ25hdHVyZXM/OiBBcnJheTxTaWduYXR1cmVQdWJrZXlQYWlyPjtcbiAgLyoqIEEgcmVjZW50IGJsb2NraGFzaCAqL1xuICBibG9ja2hhc2g6IEJsb2NraGFzaDtcbiAgLyoqIHRoZSBsYXN0IGJsb2NrIGNoYWluIGNhbiBhZHZhbmNlIHRvIGJlZm9yZSB0eCBpcyBkZWNsYXJlZCBleHBpcmVkICovXG4gIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIFVzZSB0aGVzZSBvcHRpb25zIHRvIGNvbnN0cnVjdCBhIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uTm9uY2VDdG9yID0ge1xuICAvKiogVGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciAqL1xuICBmZWVQYXllcj86IFB1YmxpY0tleSB8IG51bGw7XG4gIG1pbkNvbnRleHRTbG90OiBudW1iZXI7XG4gIG5vbmNlSW5mbzogTm9uY2VJbmZvcm1hdGlvbjtcbiAgLyoqIE9uZSBvciBtb3JlIHNpZ25hdHVyZXMgKi9cbiAgc2lnbmF0dXJlcz86IEFycmF5PFNpZ25hdHVyZVB1YmtleVBhaXI+O1xufTtcblxuLyoqXG4gKiBOb25jZSBpbmZvcm1hdGlvbiB0byBiZSB1c2VkIHRvIGJ1aWxkIGFuIG9mZmxpbmUgVHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCB0eXBlIE5vbmNlSW5mb3JtYXRpb24gPSB7XG4gIC8qKiBUaGUgY3VycmVudCBibG9ja2hhc2ggc3RvcmVkIGluIHRoZSBub25jZSAqL1xuICBub25jZTogQmxvY2toYXNoO1xuICAvKiogQWR2YW5jZU5vbmNlQWNjb3VudCBJbnN0cnVjdGlvbiAqL1xuICBub25jZUluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkpTT04ge1xuICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZyB8IG51bGw7XG4gIGZlZVBheWVyOiBzdHJpbmcgfCBudWxsO1xuICBub25jZUluZm86IHtcbiAgICBub25jZTogc3RyaW5nO1xuICAgIG5vbmNlSW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25KU09OO1xuICB9IHwgbnVsbDtcbiAgaW5zdHJ1Y3Rpb25zOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uSlNPTltdO1xuICBzaWduZXJzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogU2lnbmF0dXJlcyBmb3IgdGhlIHRyYW5zYWN0aW9uLiAgVHlwaWNhbGx5IGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlXG4gICAqIGBzaWduKClgIG1ldGhvZFxuICAgKi9cbiAgc2lnbmF0dXJlczogQXJyYXk8U2lnbmF0dXJlUHVia2V5UGFpcj4gPSBbXTtcblxuICAvKipcbiAgICogVGhlIGZpcnN0IChwYXllcikgVHJhbnNhY3Rpb24gc2lnbmF0dXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXIgfCBudWxsfSBCdWZmZXIgb2YgcGF5ZXIncyBzaWduYXR1cmVcbiAgICovXG4gIGdldCBzaWduYXR1cmUoKTogQnVmZmVyIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllclxuICAgKi9cbiAgZmVlUGF5ZXI/OiBQdWJsaWNLZXk7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0cnVjdGlvbnMgdG8gYXRvbWljYWxseSBleGVjdXRlXG4gICAqL1xuICBpbnN0cnVjdGlvbnM6IEFycmF5PFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24+ID0gW107XG5cbiAgLyoqXG4gICAqIEEgcmVjZW50IHRyYW5zYWN0aW9uIGlkLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAqL1xuICByZWNlbnRCbG9ja2hhc2g/OiBCbG9ja2hhc2g7XG5cbiAgLyoqXG4gICAqIHRoZSBsYXN0IGJsb2NrIGNoYWluIGNhbiBhZHZhbmNlIHRvIGJlZm9yZSB0eCBpcyBkZWNsYXJlZCBleHBpcmVkXG4gICAqICovXG4gIGxhc3RWYWxpZEJsb2NrSGVpZ2h0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBOb25jZSBpbmZvcm1hdGlvbi4gSWYgcG9wdWxhdGVkLCB0cmFuc2FjdGlvbiB3aWxsIHVzZSBhIGR1cmFibGVcbiAgICogTm9uY2UgaGFzaCBpbnN0ZWFkIG9mIGEgcmVjZW50QmxvY2toYXNoLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAqL1xuICBub25jZUluZm8/OiBOb25jZUluZm9ybWF0aW9uO1xuXG4gIC8qKlxuICAgKiBJZiB0aGlzIGlzIGEgbm9uY2UgdHJhbnNhY3Rpb24gdGhpcyByZXByZXNlbnRzIHRoZSBtaW5pbXVtIHNsb3QgZnJvbSB3aGljaFxuICAgKiB0byBldmFsdWF0ZSBpZiB0aGUgbm9uY2UgaGFzIGFkdmFuY2VkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25maXJtIHRoZVxuICAgKiB0cmFuc2FjdGlvbi4gVGhpcyBwcm90ZWN0cyBhZ2FpbnN0IGEgY2FzZSB3aGVyZSB0aGUgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uXG4gICAqIGxvZ2ljIGxvYWRzIHRoZSBub25jZSBhY2NvdW50IGZyb20gYW4gb2xkIHNsb3QgYW5kIGFzc3VtZXMgdGhlIG1pc21hdGNoIGluXG4gICAqIG5vbmNlIHZhbHVlIGltcGxpZXMgdGhhdCB0aGUgbm9uY2UgaGFzIGJlZW4gYWR2YW5jZWQuXG4gICAqL1xuICBtaW5Ob25jZUNvbnRleHRTbG90PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9tZXNzYWdlPzogTWVzc2FnZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfanNvbj86IFRyYW5zYWN0aW9uSlNPTjtcblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB3aXRoIGEgYmxvY2toYXNoIGFuZCBsYXN0VmFsaWRCbG9ja0hlaWdodFxuICBjb25zdHJ1Y3RvcihvcHRzPzogVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yKTtcblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB1c2luZyBhIGR1cmFibGUgbm9uY2VcbiAgY29uc3RydWN0b3Iob3B0cz86IFRyYW5zYWN0aW9uTm9uY2VDdG9yKTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYFRyYW5zYWN0aW9uQ3RvckZpZWxkc2AgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqIFBsZWFzZSBzdXBwbHkgYSBgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yYCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cz86IFRyYW5zYWN0aW9uQ3RvckZpZWxkc19ERVBSRUNBVEVEKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGVtcHR5IFRyYW5zYWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBvcHRzPzpcbiAgICAgIHwgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yXG4gICAgICB8IFRyYW5zYWN0aW9uTm9uY2VDdG9yXG4gICAgICB8IFRyYW5zYWN0aW9uQ3RvckZpZWxkc19ERVBSRUNBVEVELFxuICApIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdHMuZmVlUGF5ZXIpIHtcbiAgICAgIHRoaXMuZmVlUGF5ZXIgPSBvcHRzLmZlZVBheWVyO1xuICAgIH1cbiAgICBpZiAob3B0cy5zaWduYXR1cmVzKSB7XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBvcHRzLnNpZ25hdHVyZXM7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ25vbmNlSW5mbycpKSB7XG4gICAgICBjb25zdCB7bWluQ29udGV4dFNsb3QsIG5vbmNlSW5mb30gPSBvcHRzIGFzIFRyYW5zYWN0aW9uTm9uY2VDdG9yO1xuICAgICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gbWluQ29udGV4dFNsb3Q7XG4gICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpXG4gICAgKSB7XG4gICAgICBjb25zdCB7YmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodH0gPVxuICAgICAgICBvcHRzIGFzIFRyYW5zYWN0aW9uQmxvY2toYXNoQ3RvcjtcbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7cmVjZW50QmxvY2toYXNoLCBub25jZUluZm99ID1cbiAgICAgICAgb3B0cyBhcyBUcmFuc2FjdGlvbkN0b3JGaWVsZHNfREVQUkVDQVRFRDtcbiAgICAgIGlmIChub25jZUluZm8pIHtcbiAgICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgICB9XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHJlY2VudEJsb2NraGFzaDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKTogVHJhbnNhY3Rpb25KU09OIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCB8fCBudWxsLFxuICAgICAgZmVlUGF5ZXI6IHRoaXMuZmVlUGF5ZXIgPyB0aGlzLmZlZVBheWVyLnRvSlNPTigpIDogbnVsbCxcbiAgICAgIG5vbmNlSW5mbzogdGhpcy5ub25jZUluZm9cbiAgICAgICAgPyB7XG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZUluZm8ubm9uY2UsXG4gICAgICAgICAgICBub25jZUluc3RydWN0aW9uOiB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLnRvSlNPTigpLFxuICAgICAgICAgIH1cbiAgICAgICAgOiBudWxsLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udG9KU09OKCkpLFxuICAgICAgc2lnbmVyczogdGhpcy5zaWduYXR1cmVzLm1hcCgoe3B1YmxpY0tleX0pID0+IHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b0pTT04oKTtcbiAgICAgIH0pLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkIG9uZSBvciBtb3JlIGluc3RydWN0aW9ucyB0byB0aGlzIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8IFRyYW5zYWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25DdG9yRmllbGRzID59IGl0ZW1zIC0gSW5zdHJ1Y3Rpb25zIHRvIGFkZCB0byB0aGUgVHJhbnNhY3Rpb25cbiAgICovXG4gIGFkZChcbiAgICAuLi5pdGVtczogQXJyYXk8XG4gICAgICBUcmFuc2FjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkc1xuICAgID5cbiAgKTogVHJhbnNhY3Rpb24ge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5zdHJ1Y3Rpb25zJyk7XG4gICAgfVxuXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XG4gICAgICBpZiAoJ2luc3RydWN0aW9ucycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLmNvbmNhdChpdGVtLmluc3RydWN0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKCdkYXRhJyBpbiBpdGVtICYmICdwcm9ncmFtSWQnIGluIGl0ZW0gJiYgJ2tleXMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaXRlbSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgY29tcGlsZU1lc3NhZ2UoKTogTWVzc2FnZSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5fbWVzc2FnZSAmJlxuICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb24pXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICB9XG5cbiAgICBsZXQgcmVjZW50QmxvY2toYXNoO1xuICAgIGxldCBpbnN0cnVjdGlvbnM6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXTtcbiAgICBpZiAodGhpcy5ub25jZUluZm8pIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMubm9uY2VJbmZvLm5vbmNlO1xuICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25zWzBdICE9IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24sIC4uLnRoaXMuaW5zdHJ1Y3Rpb25zXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLnJlY2VudEJsb2NraGFzaDtcbiAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBpZiAoIXJlY2VudEJsb2NraGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiByZWNlbnRCbG9ja2hhc2ggcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA8IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gaW5zdHJ1Y3Rpb25zIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgbGV0IGZlZVBheWVyOiBQdWJsaWNLZXk7XG4gICAgaWYgKHRoaXMuZmVlUGF5ZXIpIHtcbiAgICAgIGZlZVBheWVyID0gdGhpcy5mZWVQYXllcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXkpIHtcbiAgICAgIC8vIFVzZSBpbXBsaWNpdCBmZWUgcGF5ZXJcbiAgICAgIGZlZVBheWVyID0gdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmZWUgcGF5ZXIgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGluc3RydWN0aW9uc1tpXS5wcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGluZGV4ICR7aX0gaGFzIHVuZGVmaW5lZCBwcm9ncmFtIGlkYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtSWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGFjY291bnRNZXRhczogQWNjb3VudE1ldGFbXSA9IFtdO1xuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGluc3RydWN0aW9uLmtleXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICAgIGFjY291bnRNZXRhcy5wdXNoKHsuLi5hY2NvdW50TWV0YX0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGluc3RydWN0aW9uLnByb2dyYW1JZC50b1N0cmluZygpO1xuICAgICAgaWYgKCFwcm9ncmFtSWRzLmluY2x1ZGVzKHByb2dyYW1JZCkpIHtcbiAgICAgICAgcHJvZ3JhbUlkcy5wdXNoKHByb2dyYW1JZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBcHBlbmQgcHJvZ3JhbUlEIGFjY291bnQgbWV0YXNcbiAgICBwcm9ncmFtSWRzLmZvckVhY2gocHJvZ3JhbUlkID0+IHtcbiAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBuZXcgUHVibGljS2V5KHByb2dyYW1JZCksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEN1bGwgZHVwbGljYXRlIGFjY291bnQgbWV0YXNcbiAgICBjb25zdCB1bmlxdWVNZXRhczogQWNjb3VudE1ldGFbXSA9IFtdO1xuICAgIGFjY291bnRNZXRhcy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgIGNvbnN0IHB1YmtleVN0cmluZyA9IGFjY291bnRNZXRhLnB1YmtleS50b1N0cmluZygpO1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS50b1N0cmluZygpID09PSBwdWJrZXlTdHJpbmc7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlID1cbiAgICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSB8fCBhY2NvdW50TWV0YS5pc1dyaXRhYmxlO1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPVxuICAgICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciB8fCBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzLnB1c2goYWNjb3VudE1ldGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydC4gUHJpb3JpdGl6aW5nIGZpcnN0IGJ5IHNpZ25lciwgdGhlbiBieSB3cml0YWJsZVxuICAgIHVuaXF1ZU1ldGFzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh4LmlzU2lnbmVyICE9PSB5LmlzU2lnbmVyKSB7XG4gICAgICAgIC8vIFNpZ25lcnMgYWx3YXlzIGNvbWUgYmVmb3JlIG5vbi1zaWduZXJzXG4gICAgICAgIHJldHVybiB4LmlzU2lnbmVyID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgaWYgKHguaXNXcml0YWJsZSAhPT0geS5pc1dyaXRhYmxlKSB7XG4gICAgICAgIC8vIFdyaXRhYmxlIGFjY291bnRzIGFsd2F5cyBjb21lIGJlZm9yZSByZWFkLW9ubHkgYWNjb3VudHNcbiAgICAgICAgcmV0dXJuIHguaXNXcml0YWJsZSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwgc29ydCBieSBwdWJrZXksIHN0cmluZ3dpc2UuXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiAnYmVzdCBmaXQnLFxuICAgICAgICB1c2FnZTogJ3NvcnQnLFxuICAgICAgICBzZW5zaXRpdml0eTogJ3ZhcmlhbnQnLFxuICAgICAgICBpZ25vcmVQdW5jdHVhdGlvbjogZmFsc2UsXG4gICAgICAgIG51bWVyaWM6IGZhbHNlLFxuICAgICAgICBjYXNlRmlyc3Q6ICdsb3dlcicsXG4gICAgICB9IGFzIEludGwuQ29sbGF0b3JPcHRpb25zO1xuICAgICAgcmV0dXJuIHgucHVia2V5XG4gICAgICAgIC50b0Jhc2U1OCgpXG4gICAgICAgIC5sb2NhbGVDb21wYXJlKHkucHVia2V5LnRvQmFzZTU4KCksICdlbicsIG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gTW92ZSBmZWUgcGF5ZXIgdG8gdGhlIGZyb250XG4gICAgY29uc3QgZmVlUGF5ZXJJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoZmVlUGF5ZXIpO1xuICAgIH0pO1xuICAgIGlmIChmZWVQYXllckluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IFtwYXllck1ldGFdID0gdW5pcXVlTWV0YXMuc3BsaWNlKGZlZVBheWVySW5kZXgsIDEpO1xuICAgICAgcGF5ZXJNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgIHBheWVyTWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQocGF5ZXJNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdCh7XG4gICAgICAgIHB1YmtleTogZmVlUGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWxsb3cgdW5rbm93biBzaWduZXJzXG4gICAgZm9yIChjb25zdCBzaWduYXR1cmUgb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bmlxdWVJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhzaWduYXR1cmUucHVibGljS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKCF1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIpIHtcbiAgICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdUcmFuc2FjdGlvbiByZWZlcmVuY2VzIGEgc2lnbmF0dXJlIHRoYXQgaXMgdW5uZWNlc3NhcnksICcgK1xuICAgICAgICAgICAgICAnb25seSB0aGUgZmVlIHBheWVyIGFuZCBpbnN0cnVjdGlvbiBzaWduZXIgYWNjb3VudHMgc2hvdWxkIHNpZ24gYSB0cmFuc2FjdGlvbi4gJyArXG4gICAgICAgICAgICAgICdUaGlzIGJlaGF2aW9yIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiByZWxlYXNlLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSAwO1xuXG4gICAgLy8gU3BsaXQgb3V0IHNpZ25pbmcgZnJvbSBub24tc2lnbmluZyBrZXlzIGFuZCBjb3VudCBoZWFkZXIgdmFsdWVzXG4gICAgY29uc3Qgc2lnbmVkS2V5czogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB1bnNpZ25lZEtleXM6IHN0cmluZ1tdID0gW107XG4gICAgdW5pcXVlTWV0YXMuZm9yRWFjaCgoe3B1YmtleSwgaXNTaWduZXIsIGlzV3JpdGFibGV9KSA9PiB7XG4gICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzICs9IDE7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5zaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBzaWduZWRLZXlzLmNvbmNhdCh1bnNpZ25lZEtleXMpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zOiBDb21waWxlZEluc3RydWN0aW9uW10gPSBpbnN0cnVjdGlvbnMubWFwKFxuICAgICAgaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgICBjb25zdCB7ZGF0YSwgcHJvZ3JhbUlkfSA9IGluc3RydWN0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByb2dyYW1JZEluZGV4OiBhY2NvdW50S2V5cy5pbmRleE9mKHByb2dyYW1JZC50b1N0cmluZygpKSxcbiAgICAgICAgICBhY2NvdW50czogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PlxuICAgICAgICAgICAgYWNjb3VudEtleXMuaW5kZXhPZihtZXRhLnB1YmtleS50b1N0cmluZygpKSxcbiAgICAgICAgICApLFxuICAgICAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29tcGlsZWRJbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBpbnZhcmlhbnQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXggPj0gMCk7XG4gICAgICBpbnN0cnVjdGlvbi5hY2NvdW50cy5mb3JFYWNoKGtleUluZGV4ID0+IGludmFyaWFudChrZXlJbmRleCA+PSAwKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzLFxuICAgICAgfSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9jb21waWxlKCk6IE1lc3NhZ2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNvbXBpbGVNZXNzYWdlKCk7XG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IG1lc3NhZ2UuYWNjb3VudEtleXMuc2xpY2UoXG4gICAgICAwLFxuICAgICAgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA9PT0gc2lnbmVkS2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5zaWduYXR1cmVzLmV2ZXJ5KChwYWlyLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc2lnbmVkS2V5c1tpbmRleF0uZXF1YWxzKHBhaXIucHVibGljS2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodmFsaWQpIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5LFxuICAgIH0pKTtcblxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBpbGUoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVzdGltYXRlZCBmZWUgYXNzb2NpYXRlZCB3aXRoIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gUlBDIEVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXIgfCBudWxsPn0gVGhlIGVzdGltYXRlZCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVkRmVlKGNvbm5lY3Rpb246IENvbm5lY3Rpb24pOiBQcm9taXNlPG51bWJlciB8IG51bGw+IHtcbiAgICByZXR1cm4gKGF3YWl0IGNvbm5lY3Rpb24uZ2V0RmVlRm9yTWVzc2FnZSh0aGlzLmNvbXBpbGVNZXNzYWdlKCkpKS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBwdWJsaWMga2V5cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2lnbiB0aGUgVHJhbnNhY3Rpb24uXG4gICAqIFRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogU2lnbmF0dXJlcyBjYW4gYmUgYWRkZWQgd2l0aCBlaXRoZXIgYHBhcnRpYWxTaWduYCBvciBgYWRkU2lnbmF0dXJlYFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYwLjg0LjAuIE9ubHkgdGhlIGZlZSBwYXllciBuZWVkcyB0byBiZVxuICAgKiBzcGVjaWZpZWQgYW5kIGl0IGNhbiBiZSBzZXQgaW4gdGhlIFRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIG9yIHdpdGggdGhlXG4gICAqIGBmZWVQYXllcmAgcHJvcGVydHkuXG4gICAqL1xuICBzZXRTaWduZXJzKC4uLnNpZ25lcnM6IEFycmF5PFB1YmxpY0tleT4pIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmVyc1xuICAgICAgLmZpbHRlcihwdWJsaWNLZXkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBwdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5tYXAocHVibGljS2V5ID0+ICh7c2lnbmF0dXJlOiBudWxsLCBwdWJsaWNLZXl9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLnNpZ25lcnM6IEFycmF5PFNpZ25lcj4pIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSB1bmlxdWVTaWduZXJzLm1hcChzaWduZXIgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleTogc2lnbmVyLnB1YmxpY0tleSxcbiAgICB9KSk7XG5cbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnVuaXF1ZVNpZ25lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGFjY291bnRzLiBBbGwgYWNjb3VudHMgbXVzdFxuICAgKiBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQWxsIHRoZSBjYXZlYXRzIGZyb20gdGhlIGBzaWduYCBtZXRob2QgYXBwbHkgdG8gYHBhcnRpYWxTaWduYFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHBhcnRpYWxTaWduKC4uLnNpZ25lcnM6IEFycmF5PFNpZ25lcj4pIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnVuaXF1ZVNpZ25lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3BhcnRpYWxTaWduKG1lc3NhZ2U6IE1lc3NhZ2UsIC4uLnNpZ25lcnM6IEFycmF5PFNpZ25lcj4pIHtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgc2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKHNpZ25EYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICAgIHRoaXMuX2FkZFNpZ25hdHVyZShzaWduZXIucHVibGljS2V5LCB0b0J1ZmZlcihzaWduYXR1cmUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXh0ZXJuYWxseSBjcmVhdGVkIHNpZ25hdHVyZSB0byBhIHRyYW5zYWN0aW9uLiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGNvcnJlc3BvbmQgdG8gZWl0aGVyIHRoZSBmZWUgcGF5ZXIgb3IgYSBzaWduZXIgYWNjb3VudCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVia2V5IFB1YmxpYyBrZXkgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZSBBbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGFkZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBhZGRTaWduYXR1cmUocHVia2V5OiBQdWJsaWNLZXksIHNpZ25hdHVyZTogQnVmZmVyKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpOyAvLyBFbnN1cmUgc2lnbmF0dXJlcyBhcnJheSBpcyBwb3B1bGF0ZWRcbiAgICB0aGlzLl9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2FkZFNpZ25hdHVyZShwdWJrZXk6IFB1YmxpY0tleSwgc2lnbmF0dXJlOiBCdWZmZXIpIHtcbiAgICBpbnZhcmlhbnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnNpZ25hdHVyZXMuZmluZEluZGV4KHNpZ3BhaXIgPT5cbiAgICAgIHB1YmtleS5lcXVhbHMoc2lncGFpci5wdWJsaWNLZXkpLFxuICAgICk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHtwdWJrZXkudG9TdHJpbmcoKX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLnNpZ25hdHVyZXNbaW5kZXhdLnNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHNpZ25hdHVyZXMgb2YgYSBUcmFuc2FjdGlvblxuICAgKiBPcHRpb25hbCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGlmIHdlJ3JlIGV4cGVjdGluZyBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBvciBhIHBhcnRpYWxseSBzaWduZWQgb25lLlxuICAgKiBJZiBubyBib29sZWFuIGlzIHByb3ZpZGVkLCB3ZSBleHBlY3QgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZUFsbFNpZ25hdHVyZXM9dHJ1ZV0gUmVxdWlyZSBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlcyhyZXF1aXJlQWxsU2lnbmF0dXJlczogYm9vbGVhbiA9IHRydWUpOiBib29sZWFuIHtcbiAgICBjb25zdCBzaWduYXR1cmVFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhcbiAgICAgIHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpLFxuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXMsXG4gICAgKTtcbiAgICByZXR1cm4gIXNpZ25hdHVyZUVycm9ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhcbiAgICBtZXNzYWdlOiBVaW50OEFycmF5LFxuICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBib29sZWFuLFxuICApOiBNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgZXJyb3JzOiBNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qge3NpZ25hdHVyZSwgcHVibGljS2V5fSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGlmIChzaWduYXR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgICAgICAgKGVycm9ycy5taXNzaW5nIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleS50b0J5dGVzKCkpKSB7XG4gICAgICAgICAgKGVycm9ycy5pbnZhbGlkIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMuaW52YWxpZCB8fCBlcnJvcnMubWlzc2luZyA/IGVycm9ycyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIFRyYW5zYWN0aW9uIGluIHRoZSB3aXJlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtjb25maWddIENvbmZpZyBvZiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn0gU2lnbmF0dXJlIG9mIHRyYW5zYWN0aW9uIGluIHdpcmUgZm9ybWF0LlxuICAgKi9cbiAgc2VyaWFsaXplKGNvbmZpZz86IFNlcmlhbGl6ZUNvbmZpZyk6IEJ1ZmZlciB7XG4gICAgY29uc3Qge3JlcXVpcmVBbGxTaWduYXR1cmVzLCB2ZXJpZnlTaWduYXR1cmVzfSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7cmVxdWlyZUFsbFNpZ25hdHVyZXM6IHRydWUsIHZlcmlmeVNpZ25hdHVyZXM6IHRydWV9LFxuICAgICAgY29uZmlnLFxuICAgICk7XG5cbiAgICBjb25zdCBzaWduRGF0YSA9IHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpO1xuICAgIGlmICh2ZXJpZnlTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCBzaWdFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhcbiAgICAgICAgc2lnbkRhdGEsXG4gICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzLFxuICAgICAgKTtcbiAgICAgIGlmIChzaWdFcnJvcnMpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZC4nO1xuICAgICAgICBpZiAoc2lnRXJyb3JzLmludmFsaWQpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbkludmFsaWQgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtcbiAgICAgICAgICAgIHNpZ0Vycm9ycy5pbnZhbGlkLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSdcbiAgICAgICAgICB9IFtcXGAke3NpZ0Vycm9ycy5pbnZhbGlkLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnRXJyb3JzLm1pc3NpbmcpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbk1pc3Npbmcgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtcbiAgICAgICAgICAgIHNpZ0Vycm9ycy5taXNzaW5nLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSdcbiAgICAgICAgICB9IFtcXGAke3NpZ0Vycm9ycy5taXNzaW5nLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoc2lnbkRhdGE6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gICAgY29uc3Qge3NpZ25hdHVyZXN9ID0gdGhpcztcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudDogbnVtYmVyW10gPSBbXTtcbiAgICBzaG9ydHZlYy5lbmNvZGVMZW5ndGgoc2lnbmF0dXJlQ291bnQsIHNpZ25hdHVyZXMubGVuZ3RoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkxlbmd0aCA9XG4gICAgICBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0ICsgc2lnbkRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IEJ1ZmZlci5hbGxvYyh0cmFuc2FjdGlvbkxlbmd0aCk7XG4gICAgaW52YXJpYW50KHNpZ25hdHVyZXMubGVuZ3RoIDwgMjU2KTtcbiAgICBCdWZmZXIuZnJvbShzaWduYXR1cmVDb3VudCkuY29weSh3aXJlVHJhbnNhY3Rpb24sIDApO1xuICAgIHNpZ25hdHVyZXMuZm9yRWFjaCgoe3NpZ25hdHVyZX0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGludmFyaWFudChzaWduYXR1cmUubGVuZ3RoID09PSA2NCwgYHNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhgKTtcbiAgICAgICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlKS5jb3B5KFxuICAgICAgICAgIHdpcmVUcmFuc2FjdGlvbixcbiAgICAgICAgICBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBpbmRleCAqIDY0LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNpZ25EYXRhLmNvcHkoXG4gICAgICB3aXJlVHJhbnNhY3Rpb24sXG4gICAgICBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0LFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgd2lyZVRyYW5zYWN0aW9uLmxlbmd0aCA8PSBQQUNLRVRfREFUQV9TSVpFLFxuICAgICAgYFRyYW5zYWN0aW9uIHRvbyBsYXJnZTogJHt3aXJlVHJhbnNhY3Rpb24ubGVuZ3RofSA+ICR7UEFDS0VUX0RBVEFfU0laRX1gLFxuICAgICk7XG4gICAgcmV0dXJuIHdpcmVUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBrZXlzKCk6IEFycmF5PFB1YmxpY0tleT4ge1xuICAgIGludmFyaWFudCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5rZXlzLm1hcChrZXlPYmogPT4ga2V5T2JqLnB1YmtleSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcHJvZ3JhbUlkKCk6IFB1YmxpY0tleSB7XG4gICAgaW52YXJpYW50KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLnByb2dyYW1JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBkYXRhKCk6IEJ1ZmZlciB7XG4gICAgaW52YXJpYW50KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSB3aXJlIHRyYW5zYWN0aW9uIGludG8gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj59IGJ1ZmZlciBTaWduYXR1cmUgb2Ygd2lyZSBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXI6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+KTogVHJhbnNhY3Rpb24ge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcblxuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gc2hvcnR2ZWMuZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChiczU4LmVuY29kZShCdWZmZXIuZnJvbShzaWduYXR1cmUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLnBvcHVsYXRlKE1lc3NhZ2UuZnJvbShieXRlQXJyYXkpLCBzaWduYXR1cmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZSBUcmFuc2FjdGlvbiBvYmplY3QgZnJvbSBtZXNzYWdlIGFuZCBzaWduYXR1cmVzXG4gICAqXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIG9mIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc2lnbmF0dXJlcyBMaXN0IG9mIHNpZ25hdHVyZXMgdG8gYXNzaWduIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRoZSBwb3B1bGF0ZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHN0YXRpYyBwb3B1bGF0ZShcbiAgICBtZXNzYWdlOiBNZXNzYWdlLFxuICAgIHNpZ25hdHVyZXM6IEFycmF5PHN0cmluZz4gPSBbXSxcbiAgKTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbWVzc2FnZS5yZWNlbnRCbG9ja2hhc2g7XG4gICAgaWYgKG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyA+IDApIHtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbWVzc2FnZS5hY2NvdW50S2V5c1swXTtcbiAgICB9XG4gICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzaWdQdWJrZXlQYWlyID0ge1xuICAgICAgICBzaWduYXR1cmU6XG4gICAgICAgICAgc2lnbmF0dXJlID09IGJzNTguZW5jb2RlKERFRkFVTFRfU0lHTkFUVVJFKVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGJzNTguZGVjb2RlKHNpZ25hdHVyZSksXG4gICAgICAgIHB1YmxpY0tleTogbWVzc2FnZS5hY2NvdW50S2V5c1tpbmRleF0sXG4gICAgICB9O1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5wdXNoKHNpZ1B1YmtleVBhaXIpO1xuICAgIH0pO1xuXG4gICAgbWVzc2FnZS5pbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBrZXlzID0gaW5zdHJ1Y3Rpb24uYWNjb3VudHMubWFwKGFjY291bnQgPT4ge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBtZXNzYWdlLmFjY291bnRLZXlzW2FjY291bnRdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjpcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMuc29tZShcbiAgICAgICAgICAgICAga2V5T2JqID0+IGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCksXG4gICAgICAgICAgICApIHx8IG1lc3NhZ2UuaXNBY2NvdW50U2lnbmVyKGFjY291bnQpLFxuICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudCksXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2goXG4gICAgICAgIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICBrZXlzLFxuICAgICAgICAgIHByb2dyYW1JZDogbWVzc2FnZS5hY2NvdW50S2V5c1tpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleF0sXG4gICAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0cmFuc2FjdGlvbi5fanNvbiA9IHRyYW5zYWN0aW9uLnRvSlNPTigpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQge0FjY291bnRLZXlzRnJvbUxvb2t1cHN9IGZyb20gJy4uL21lc3NhZ2UvYWNjb3VudC1rZXlzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7dG9CdWZmZXJ9IGZyb20gJy4uL3V0aWxzL3RvLWJ1ZmZlcic7XG5pbXBvcnQge0Jsb2NraGFzaH0gZnJvbSAnLi4vYmxvY2toYXNoJztcbmltcG9ydCB7TWVzc2FnZSwgTWVzc2FnZVYwLCBWZXJzaW9uZWRNZXNzYWdlfSBmcm9tICcuLi9tZXNzYWdlJztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0IHtBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50fSBmcm9tICcuLi9wcm9ncmFtcyc7XG5pbXBvcnQge0FjY291bnRNZXRhLCBUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuL2xlZ2FjeSc7XG5cbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uTWVzc2FnZUFyZ3MgPSB7XG4gIHBheWVyS2V5OiBQdWJsaWNLZXk7XG4gIGluc3RydWN0aW9uczogQXJyYXk8VHJhbnNhY3Rpb25JbnN0cnVjdGlvbj47XG4gIHJlY2VudEJsb2NraGFzaDogQmxvY2toYXNoO1xufTtcblxuZXhwb3J0IHR5cGUgRGVjb21waWxlQXJncyA9XG4gIHwge1xuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwczogQWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICB9XG4gIHwge1xuICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHM6IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRbXTtcbiAgICB9O1xuXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25NZXNzYWdlIHtcbiAgcGF5ZXJLZXk6IFB1YmxpY0tleTtcbiAgaW5zdHJ1Y3Rpb25zOiBBcnJheTxUcmFuc2FjdGlvbkluc3RydWN0aW9uPjtcbiAgcmVjZW50QmxvY2toYXNoOiBCbG9ja2hhc2g7XG5cbiAgY29uc3RydWN0b3IoYXJnczogVHJhbnNhY3Rpb25NZXNzYWdlQXJncykge1xuICAgIHRoaXMucGF5ZXJLZXkgPSBhcmdzLnBheWVyS2V5O1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvbXBpbGUoXG4gICAgbWVzc2FnZTogVmVyc2lvbmVkTWVzc2FnZSxcbiAgICBhcmdzPzogRGVjb21waWxlQXJncyxcbiAgKTogVHJhbnNhY3Rpb25NZXNzYWdlIHtcbiAgICBjb25zdCB7aGVhZGVyLCBjb21waWxlZEluc3RydWN0aW9ucywgcmVjZW50QmxvY2toYXNofSA9IG1lc3NhZ2U7XG5cbiAgICBjb25zdCB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzLFxuICAgIH0gPSBoZWFkZXI7XG5cbiAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID1cbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPiAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuXG4gICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID1cbiAgICAgIG1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoIC1cbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA+PSAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuXG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBtZXNzYWdlLmdldEFjY291bnRLZXlzKGFyZ3MpO1xuICAgIGNvbnN0IHBheWVyS2V5ID0gYWNjb3VudEtleXMuZ2V0KDApO1xuICAgIGlmIChwYXllcktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdGYWlsZWQgdG8gZGVjb21waWxlIG1lc3NhZ2UgYmVjYXVzZSBubyBhY2NvdW50IGtleXMgd2VyZSBmb3VuZCcsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RydWN0aW9uczogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbltdID0gW107XG4gICAgZm9yIChjb25zdCBjb21waWxlZEl4IG9mIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBrZXlzOiBBY2NvdW50TWV0YVtdID0gW107XG5cbiAgICAgIGZvciAoY29uc3Qga2V5SW5kZXggb2YgY29tcGlsZWRJeC5hY2NvdW50S2V5SW5kZXhlcykge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBhY2NvdW50S2V5cy5nZXQoa2V5SW5kZXgpO1xuICAgICAgICBpZiAocHVia2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGZpbmQga2V5IGZvciBhY2NvdW50IGtleSBpbmRleCAke2tleUluZGV4fWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzU2lnbmVyID0ga2V5SW5kZXggPCBudW1SZXF1aXJlZFNpZ25hdHVyZXM7XG5cbiAgICAgICAgbGV0IGlzV3JpdGFibGU7XG4gICAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5SW5kZXggPCBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID1cbiAgICAgICAgICAgIGtleUluZGV4IC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzV3JpdGFibGUgPVxuICAgICAgICAgICAga2V5SW5kZXggLSBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggPFxuICAgICAgICAgICAgLy8gYWNjb3VudEtleXNGcm9tTG9va3VwcyBjYW5ub3QgYmUgdW5kZWZpbmVkIGJlY2F1c2Ugd2UgYWxyZWFkeSBmb3VuZCBhIHB1YmtleSBmb3IgdGhpcyBpbmRleCBhYm92ZVxuICAgICAgICAgICAgYWNjb3VudEtleXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyEud3JpdGFibGUubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGtleUluZGV4IDwgaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICBpc1dyaXRhYmxlLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvZ3JhbUlkID0gYWNjb3VudEtleXMuZ2V0KGNvbXBpbGVkSXgucHJvZ3JhbUlkSW5kZXgpO1xuICAgICAgaWYgKHByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGZpbmQgcHJvZ3JhbSBpZCBmb3IgcHJvZ3JhbSBpZCBpbmRleCAke2NvbXBpbGVkSXgucHJvZ3JhbUlkSW5kZXh9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goXG4gICAgICAgIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgICAgZGF0YTogdG9CdWZmZXIoY29tcGlsZWRJeC5kYXRhKSxcbiAgICAgICAgICBrZXlzLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbk1lc3NhZ2Uoe1xuICAgICAgcGF5ZXJLZXksXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgfSk7XG4gIH1cblxuICBjb21waWxlVG9MZWdhY3lNZXNzYWdlKCk6IE1lc3NhZ2Uge1xuICAgIHJldHVybiBNZXNzYWdlLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBpbGVUb1YwTWVzc2FnZShcbiAgICBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cz86IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRbXSxcbiAgKTogTWVzc2FnZVYwIHtcbiAgICByZXR1cm4gTWVzc2FnZVYwLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcblxuaW1wb3J0IHtTaWduZXJ9IGZyb20gJy4uL2tleXBhaXInO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IHtWZXJzaW9uZWRNZXNzYWdlfSBmcm9tICcuLi9tZXNzYWdlL3ZlcnNpb25lZCc7XG5pbXBvcnQge1NJR05BVFVSRV9MRU5HVEhfSU5fQllURVN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIHNob3J0dmVjIGZyb20gJy4uL3V0aWxzL3Nob3J0dmVjLWVuY29kaW5nJztcbmltcG9ydCAqIGFzIExheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IHtzaWdufSBmcm9tICcuLi91dGlscy9lZDI1NTE5JztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0IHtndWFyZGVkU3BsaWNlfSBmcm9tICcuLi91dGlscy9ndWFyZGVkLWFycmF5LXV0aWxzJztcblxuZXhwb3J0IHR5cGUgVHJhbnNhY3Rpb25WZXJzaW9uID0gJ2xlZ2FjeScgfCAwO1xuXG4vKipcbiAqIFZlcnNpb25lZCB0cmFuc2FjdGlvbiBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgVmVyc2lvbmVkVHJhbnNhY3Rpb24ge1xuICBzaWduYXR1cmVzOiBBcnJheTxVaW50OEFycmF5PjtcbiAgbWVzc2FnZTogVmVyc2lvbmVkTWVzc2FnZTtcblxuICBnZXQgdmVyc2lvbigpOiBUcmFuc2FjdGlvblZlcnNpb24ge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudmVyc2lvbjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IFZlcnNpb25lZE1lc3NhZ2UsIHNpZ25hdHVyZXM/OiBBcnJheTxVaW50OEFycmF5Pikge1xuICAgIGlmIChzaWduYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgc2lnbmF0dXJlcy5sZW5ndGggPT09IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgJ0V4cGVjdGVkIHNpZ25hdHVyZXMgbGVuZ3RoIHRvIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcycsXG4gICAgICApO1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFNpZ25hdHVyZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzOyBpKyspIHtcbiAgICAgICAgZGVmYXVsdFNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBkZWZhdWx0U2lnbmF0dXJlcztcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKTtcblxuICAgIGNvbnN0IGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoID0gQXJyYXk8bnVtYmVyPigpO1xuICAgIHNob3J0dmVjLmVuY29kZUxlbmd0aChlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8e1xuICAgICAgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGg6IFVpbnQ4QXJyYXk7XG4gICAgICBzaWduYXR1cmVzOiBBcnJheTxVaW50OEFycmF5PjtcbiAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlOiBVaW50OEFycmF5O1xuICAgIH0+KFtcbiAgICAgIEJ1ZmZlckxheW91dC5ibG9iKFxuICAgICAgICBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aC5sZW5ndGgsXG4gICAgICAgICdlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCcsXG4gICAgICApLFxuICAgICAgQnVmZmVyTGF5b3V0LnNlcShcbiAgICAgICAgTGF5b3V0LnNpZ25hdHVyZSgpLFxuICAgICAgICB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLFxuICAgICAgICAnc2lnbmF0dXJlcycsXG4gICAgICApLFxuICAgICAgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZE1lc3NhZ2UubGVuZ3RoLCAnc2VyaWFsaXplZE1lc3NhZ2UnKSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCA9IHRyYW5zYWN0aW9uTGF5b3V0LmVuY29kZShcbiAgICAgIHtcbiAgICAgICAgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoKSxcbiAgICAgICAgc2lnbmF0dXJlczogdGhpcy5zaWduYXR1cmVzLFxuICAgICAgICBzZXJpYWxpemVkTWVzc2FnZSxcbiAgICAgIH0sXG4gICAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb24sXG4gICAgKTtcblxuICAgIHJldHVybiBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoMCwgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoKTtcbiAgfVxuXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkVHJhbnNhY3Rpb246IFVpbnQ4QXJyYXkpOiBWZXJzaW9uZWRUcmFuc2FjdGlvbiB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkVHJhbnNhY3Rpb25dO1xuXG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IHNpZ25hdHVyZXNMZW5ndGggPSBzaG9ydHZlYy5kZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZXNMZW5ndGg7IGkrKykge1xuICAgICAgc2lnbmF0dXJlcy5wdXNoKFxuICAgICAgICBuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZShuZXcgVWludDhBcnJheShieXRlQXJyYXkpKTtcbiAgICByZXR1cm4gbmV3IFZlcnNpb25lZFRyYW5zYWN0aW9uKG1lc3NhZ2UsIHNpZ25hdHVyZXMpO1xuICB9XG5cbiAgc2lnbihzaWduZXJzOiBBcnJheTxTaWduZXI+KSB7XG4gICAgY29uc3QgbWVzc2FnZURhdGEgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZShcbiAgICAgIDAsXG4gICAgICB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICApO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+XG4gICAgICAgIHB1YmtleS5lcXVhbHMoc2lnbmVyLnB1YmxpY0tleSksXG4gICAgICApO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBzaWduZXJJbmRleCA+PSAwLFxuICAgICAgICBgQ2Fubm90IHNpZ24gd2l0aCBub24gc2lnbmVyIGtleSAke3NpZ25lci5wdWJsaWNLZXkudG9CYXNlNTgoKX1gLFxuICAgICAgKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduKG1lc3NhZ2VEYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICB9XG4gIH1cblxuICBhZGRTaWduYXR1cmUocHVibGljS2V5OiBQdWJsaWNLZXksIHNpZ25hdHVyZTogVWludDhBcnJheSkge1xuICAgIGFzc2VydChzaWduYXR1cmUuYnl0ZUxlbmd0aCA9PT0gNjQsICdTaWduYXR1cmUgbXVzdCBiZSA2NCBieXRlcyBsb25nJyk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZShcbiAgICAgIDAsXG4gICAgICB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICApO1xuICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+XG4gICAgICBwdWJrZXkuZXF1YWxzKHB1YmxpY0tleSksXG4gICAgKTtcbiAgICBhc3NlcnQoXG4gICAgICBzaWduZXJJbmRleCA+PSAwLFxuICAgICAgYENhbiBub3QgYWRkIHNpZ25hdHVyZTsgXFxgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1cXGAgaXMgbm90IHJlcXVpcmVkIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvbmAsXG4gICAgKTtcbiAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbmF0dXJlO1xuICB9XG59XG4iLCIvLyBUT0RPOiBUaGVzZSBjb25zdGFudHMgc2hvdWxkIGJlIHJlbW92ZWQgaW4gZmF2b3Igb2YgcmVhZGluZyB0aGVtIG91dCBvZiBhXG4vLyBTeXNjYWxsIGFjY291bnRcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IE5VTV9USUNLU19QRVJfU0VDT05EID0gMTYwO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9USUNLU19QRVJfU0xPVCA9IDY0O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgTlVNX1NMT1RTX1BFUl9TRUNPTkQgPVxuICBOVU1fVElDS1NfUEVSX1NFQ09ORCAvIERFRkFVTFRfVElDS1NfUEVSX1NMT1Q7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBNU19QRVJfU0xPVCA9IDEwMDAgLyBOVU1fU0xPVFNfUEVSX1NFQ09ORDtcbiIsImltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuL3B1YmxpY2tleSc7XG5cbmV4cG9ydCBjb25zdCBTWVNWQVJfQ0xPQ0tfUFVCS0VZID0gbmV3IFB1YmxpY0tleShcbiAgJ1N5c3ZhckMxb2NrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnLFxuKTtcblxuZXhwb3J0IGNvbnN0IFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KFxuICAnU3lzdmFyRXBvY2hTY2hlZHUxZTExMTExMTExMTExMTExMTExMTExMTExMScsXG4pO1xuXG5leHBvcnQgY29uc3QgU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KFxuICAnU3lzdmFyMW5zdHJ1Y3Rpb25zMTExMTExMTExMTExMTExMTExMTExMTExMScsXG4pO1xuXG5leHBvcnQgY29uc3QgU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KFxuICAnU3lzdmFyUmVjZW50QjFvY2tIYXNoZXMxMTExMTExMTExMTExMTExMTExMScsXG4pO1xuXG5leHBvcnQgY29uc3QgU1lTVkFSX1JFTlRfUFVCS0VZID0gbmV3IFB1YmxpY0tleShcbiAgJ1N5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnLFxuKTtcblxuZXhwb3J0IGNvbnN0IFNZU1ZBUl9SRVdBUkRTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoXG4gICdTeXN2YXJSZXdhcmRzMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyxcbik7XG5cbmV4cG9ydCBjb25zdCBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleShcbiAgJ1N5c3ZhclMxb3RIYXNoZXMxMTExMTExMTExMTExMTExMTExMTExMTExMTEnLFxuKTtcblxuZXhwb3J0IGNvbnN0IFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleShcbiAgJ1N5c3ZhclMxb3RIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMTEnLFxuKTtcblxuZXhwb3J0IGNvbnN0IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoXG4gICdTeXN2YXJTdGFrZUhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExJyxcbik7XG4iLCJpbXBvcnQge0Nvbm5lY3Rpb259IGZyb20gJy4vY29ubmVjdGlvbic7XG5pbXBvcnQge1RyYW5zYWN0aW9uU2lnbmF0dXJlfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcblxuZXhwb3J0IGNsYXNzIFNlbmRUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcml2YXRlIHNpZ25hdHVyZTogVHJhbnNhY3Rpb25TaWduYXR1cmU7XG4gIHByaXZhdGUgdHJhbnNhY3Rpb25NZXNzYWdlOiBzdHJpbmc7XG4gIHByaXZhdGUgdHJhbnNhY3Rpb25Mb2dzOiBzdHJpbmdbXSB8IFByb21pc2U8c3RyaW5nW10+IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhY3Rpb24sXG4gICAgc2lnbmF0dXJlLFxuICAgIHRyYW5zYWN0aW9uTWVzc2FnZSxcbiAgICBsb2dzLFxuICB9OiB7XG4gICAgYWN0aW9uOiAnc2VuZCcgfCAnc2ltdWxhdGUnO1xuICAgIHNpZ25hdHVyZTogVHJhbnNhY3Rpb25TaWduYXR1cmU7XG4gICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBzdHJpbmc7XG4gICAgbG9ncz86IHN0cmluZ1tdO1xuICB9KSB7XG4gICAgY29uc3QgbWF5YmVMb2dzT3V0cHV0ID0gbG9nc1xuICAgICAgPyBgTG9nczogXFxuJHtKU09OLnN0cmluZ2lmeShsb2dzLnNsaWNlKC0xMCksIG51bGwsIDIpfS4gYFxuICAgICAgOiAnJztcbiAgICBjb25zdCBndWlkZVRleHQgPVxuICAgICAgJ1xcbkNhdGNoIHRoZSBgU2VuZFRyYW5zYWN0aW9uRXJyb3JgIGFuZCBjYWxsIGBnZXRMb2dzKClgIG9uIGl0IGZvciBmdWxsIGRldGFpbHMuJztcbiAgICBsZXQgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlICdzZW5kJzpcbiAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgYFRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSByZXN1bHRlZCBpbiBhbiBlcnJvci4gXFxuYCArXG4gICAgICAgICAgYCR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gYCArXG4gICAgICAgICAgbWF5YmVMb2dzT3V0cHV0ICtcbiAgICAgICAgICBndWlkZVRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2ltdWxhdGUnOlxuICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICBgU2ltdWxhdGlvbiBmYWlsZWQuIFxcbk1lc3NhZ2U6ICR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gXFxuYCArXG4gICAgICAgICAgbWF5YmVMb2dzT3V0cHV0ICtcbiAgICAgICAgICBndWlkZVRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBtZXNzYWdlID0gYFVua25vd24gYWN0aW9uICckeygoYTogbmV2ZXIpID0+IGEpKGFjdGlvbil9J2A7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy50cmFuc2FjdGlvbk1lc3NhZ2UgPSB0cmFuc2FjdGlvbk1lc3NhZ2U7XG4gICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSBsb2dzID8gbG9ncyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldCB0cmFuc2FjdGlvbkVycm9yKCk6IHttZXNzYWdlOiBzdHJpbmc7IGxvZ3M/OiBzdHJpbmdbXX0ge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiB0aGlzLnRyYW5zYWN0aW9uTWVzc2FnZSxcbiAgICAgIGxvZ3M6IEFycmF5LmlzQXJyYXkodGhpcy50cmFuc2FjdGlvbkxvZ3MpXG4gICAgICAgID8gdGhpcy50cmFuc2FjdGlvbkxvZ3NcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qIEBkZXByZWNhdGVkIFVzZSBgYXdhaXQgZ2V0TG9ncygpYCBpbnN0ZWFkICovXG4gIGdldCBsb2dzKCk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBjYWNoZWRMb2dzID0gdGhpcy50cmFuc2FjdGlvbkxvZ3M7XG4gICAgaWYgKFxuICAgICAgY2FjaGVkTG9ncyAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgY2FjaGVkTG9ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICd0aGVuJyBpbiBjYWNoZWRMb2dzXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkTG9ncztcbiAgfVxuXG4gIGFzeW5jIGdldExvZ3MoY29ubmVjdGlvbjogQ29ubmVjdGlvbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50cmFuc2FjdGlvbkxvZ3MpKSB7XG4gICAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdGlvblxuICAgICAgICAgIC5nZXRUcmFuc2FjdGlvbih0aGlzLnNpZ25hdHVyZSlcbiAgICAgICAgICAudGhlbih0eCA9PiB7XG4gICAgICAgICAgICBpZiAodHggJiYgdHgubWV0YSAmJiB0eC5tZXRhLmxvZ01lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSB0eC5tZXRhLmxvZ01lc3NhZ2VzO1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IGxvZ3M7XG4gICAgICAgICAgICAgIHJlc29sdmUobG9ncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdMb2cgbWVzc2FnZXMgbm90IGZvdW5kJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb25Mb2dzO1xuICB9XG59XG5cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGNsaWVudC9zcmMvcnBjX2N1c3RvbV9lcnJvcnMucnNcbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmV4cG9ydCBjb25zdCBTb2xhbmFKU09OUlBDRXJyb3JDb2RlID0ge1xuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUDogLTMyMDAxLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRTogLTMyMDAyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFOiAtMzIwMDQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWTogLTMyMDA1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDA2LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEOiAtMzIwMDcsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVDogLTMyMDA4LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEOiAtMzIwMDksXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVg6IC0zMjAxMCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRTogLTMyMDExLFxuICBKU09OX1JQQ19TQ0FOX0VSUk9SOiAtMzIwMTIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIOiAtMzIwMTMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQ6IC0zMjAxNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT046IC0zMjAxNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQ6IC0zMjAxNixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBTb2xhbmFKU09OUlBDRXJyb3JDb2RlRW51bSA9XG4gICh0eXBlb2YgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSlba2V5b2YgdHlwZW9mIFNvbGFuYUpTT05SUENFcnJvckNvZGVdO1xuXG5leHBvcnQgY2xhc3MgU29sYW5hSlNPTlJQQ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBTb2xhbmFKU09OUlBDRXJyb3JDb2RlRW51bSB8IHVua25vd247XG4gIGRhdGE/OiBhbnk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YSxcbiAgICB9OiBSZWFkb25seTx7Y29kZTogdW5rbm93bjsgbWVzc2FnZTogc3RyaW5nOyBkYXRhPzogYW55fT4sXG4gICAgY3VzdG9tTWVzc2FnZT86IHN0cmluZyxcbiAgKSB7XG4gICAgc3VwZXIoY3VzdG9tTWVzc2FnZSAhPSBudWxsID8gYCR7Y3VzdG9tTWVzc2FnZX06ICR7bWVzc2FnZX1gIDogbWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubmFtZSA9ICdTb2xhbmFKU09OUlBDRXJyb3InO1xuICB9XG59XG4iLCJpbXBvcnQge0Nvbm5lY3Rpb24sIFNpZ25hdHVyZVJlc3VsdH0gZnJvbSAnLi4vY29ubmVjdGlvbic7XG5pbXBvcnQge1RyYW5zYWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgdHlwZSB7Q29uZmlybU9wdGlvbnN9IGZyb20gJy4uL2Nvbm5lY3Rpb24nO1xuaW1wb3J0IHR5cGUge1NpZ25lcn0gZnJvbSAnLi4va2V5cGFpcic7XG5pbXBvcnQgdHlwZSB7VHJhbnNhY3Rpb25TaWduYXR1cmV9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7U2VuZFRyYW5zYWN0aW9uRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8qKlxuICogU2lnbiwgc2VuZCBhbmQgY29uZmlybSBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIElmIGBjb21taXRtZW50YCBvcHRpb24gaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gJ21heCcgY29tbWl0bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnNcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihcbiAgY29ubmVjdGlvbjogQ29ubmVjdGlvbixcbiAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLFxuICBzaWduZXJzOiBBcnJheTxTaWduZXI+LFxuICBvcHRpb25zPzogQ29uZmlybU9wdGlvbnMgJlxuICAgIFJlYWRvbmx5PHtcbiAgICAgIC8vIEEgc2lnbmFsIHRoYXQsIHdoZW4gYWJvcnRlZCwgY2FuY2VscyBhbnkgb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIG9wZXJhdGlvbnNcbiAgICAgIGFib3J0U2lnbmFsPzogQWJvcnRTaWduYWw7XG4gICAgfT4sXG4pOiBQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPiB7XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgIG1pbkNvbnRleHRTbG90OiBvcHRpb25zLm1pbkNvbnRleHRTbG90LFxuICB9O1xuXG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIHNpZ25lcnMsXG4gICAgc2VuZE9wdGlvbnMsXG4gICk7XG5cbiAgbGV0IHN0YXR1czogU2lnbmF0dXJlUmVzdWx0O1xuICBpZiAoXG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoICE9IG51bGwgJiZcbiAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCAhPSBudWxsXG4gICkge1xuICAgIHN0YXR1cyA9IChcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKFxuICAgICAgICB7XG4gICAgICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnM/LmFib3J0U2lnbmFsLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoLFxuICAgICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgICApXG4gICAgKS52YWx1ZTtcbiAgfSBlbHNlIGlmIChcbiAgICB0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90ICE9IG51bGwgJiZcbiAgICB0cmFuc2FjdGlvbi5ub25jZUluZm8gIT0gbnVsbFxuICApIHtcbiAgICBjb25zdCB7bm9uY2VJbnN0cnVjdGlvbn0gPSB0cmFuc2FjdGlvbi5ub25jZUluZm87XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50UHVia2V5ID0gbm9uY2VJbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleTtcbiAgICBzdGF0dXMgPSAoXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihcbiAgICAgICAge1xuICAgICAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCxcbiAgICAgICAgICBtaW5Db250ZXh0U2xvdDogdHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCxcbiAgICAgICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICAgICAgbm9uY2VWYWx1ZTogdHJhbnNhY3Rpb24ubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgICApXG4gICAgKS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0aW9ucz8uYWJvcnRTaWduYWwgIT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbigpOiBBIHRyYW5zYWN0aW9uIHdpdGggYSBkZXByZWNhdGVkIGNvbmZpcm1hdGlvbiBzdHJhdGVneSB3YXMgJyArXG4gICAgICAgICAgJ3N1cHBsaWVkIGFsb25nIHdpdGggYW4gYGFib3J0U2lnbmFsYC4gT25seSB0cmFuc2FjdGlvbnMgaGF2aW5nIGBsYXN0VmFsaWRCbG9ja0hlaWdodGAgJyArXG4gICAgICAgICAgJ29yIGEgY29tYmluYXRpb24gb2YgYG5vbmNlSW5mb2AgYW5kIGBtaW5Ob25jZUNvbnRleHRTbG90YCBhcmUgYWJvcnRhYmxlLicsXG4gICAgICApO1xuICAgIH1cbiAgICBzdGF0dXMgPSAoXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICAgIClcbiAgICApLnZhbHVlO1xuICB9XG5cbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogJ3NlbmQnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUcmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWAsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzaWduYXR1cmU7XG59XG4iLCIvLyB6enpcbmV4cG9ydCBmdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5cbmltcG9ydCAqIGFzIExheW91dCBmcm9tICcuL2xheW91dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUluc3RydWN0aW9uSW5wdXREYXRhIHtcbiAgcmVhZG9ubHkgaW5zdHJ1Y3Rpb246IG51bWJlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgSW5zdHJ1Y3Rpb25UeXBlPFRJbnB1dERhdGEgZXh0ZW5kcyBJSW5zdHJ1Y3Rpb25JbnB1dERhdGE+ID0ge1xuICAvKiogVGhlIEluc3RydWN0aW9uIGluZGV4IChmcm9tIHNvbGFuYSB1cHN0cmVhbSBwcm9ncmFtKSAqL1xuICBpbmRleDogbnVtYmVyO1xuICAvKiogVGhlIEJ1ZmZlckxheW91dCB0byB1c2UgdG8gYnVpbGQgZGF0YSAqL1xuICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5MYXlvdXQ8VElucHV0RGF0YT47XG59O1xuXG4vKipcbiAqIFBvcHVsYXRlIGEgYnVmZmVyIG9mIGluc3RydWN0aW9uIGRhdGEgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZURhdGE8VElucHV0RGF0YSBleHRlbmRzIElJbnN0cnVjdGlvbklucHV0RGF0YT4oXG4gIHR5cGU6IEluc3RydWN0aW9uVHlwZTxUSW5wdXREYXRhPixcbiAgZmllbGRzPzogYW55LFxuKTogQnVmZmVyIHtcbiAgY29uc3QgYWxsb2NMZW5ndGggPVxuICAgIHR5cGUubGF5b3V0LnNwYW4gPj0gMCA/IHR5cGUubGF5b3V0LnNwYW4gOiBMYXlvdXQuZ2V0QWxsb2ModHlwZSwgZmllbGRzKTtcbiAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhhbGxvY0xlbmd0aCk7XG4gIGNvbnN0IGxheW91dEZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe2luc3RydWN0aW9uOiB0eXBlLmluZGV4fSwgZmllbGRzKTtcbiAgdHlwZS5sYXlvdXQuZW5jb2RlKGxheW91dEZpZWxkcywgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZSBpbnN0cnVjdGlvbiBkYXRhIGJ1ZmZlciB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRGF0YTxUSW5wdXREYXRhIGV4dGVuZHMgSUluc3RydWN0aW9uSW5wdXREYXRhPihcbiAgdHlwZTogSW5zdHJ1Y3Rpb25UeXBlPFRJbnB1dERhdGE+LFxuICBidWZmZXI6IEJ1ZmZlcixcbik6IFRJbnB1dERhdGEge1xuICBsZXQgZGF0YTogVElucHV0RGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdHlwZS5sYXlvdXQuZGVjb2RlKGJ1ZmZlcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cblxuICBpZiAoZGF0YS5pbnN0cnVjdGlvbiAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBpbnZhbGlkIGluc3RydWN0aW9uOyBpbnN0cnVjdGlvbiBpbmRleCBtaXNtYXRjaCAke2RhdGEuaW5zdHJ1Y3Rpb259ICE9ICR7dHlwZS5pbmRleH1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi85MGJlZGQ3ZTA2N2I1YjhmM2RkYmI0NWRhMDBhNGU5Y2FiYjIyYzYyL3Nkay9zcmMvZmVlX2NhbGN1bGF0b3IucnMjTDctTDExXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBGZWVDYWxjdWxhdG9yTGF5b3V0ID0gQnVmZmVyTGF5b3V0Lm51NjQoJ2xhbXBvcnRzUGVyU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQ2FsY3VsYXRvciBmb3IgdHJhbnNhY3Rpb24gZmVlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmVlQ2FsY3VsYXRvciB7XG4gIC8qKiBDb3N0IGluIGxhbXBvcnRzIHRvIHZhbGlkYXRlIGEgc2lnbmF0dXJlLiAqL1xuICBsYW1wb3J0c1BlclNpZ25hdHVyZTogbnVtYmVyO1xufVxuIiwiaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcblxuaW1wb3J0ICogYXMgTGF5b3V0IGZyb20gJy4vbGF5b3V0JztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuL3B1YmxpY2tleSc7XG5pbXBvcnQgdHlwZSB7RmVlQ2FsY3VsYXRvcn0gZnJvbSAnLi9mZWUtY2FsY3VsYXRvcic7XG5pbXBvcnQge0ZlZUNhbGN1bGF0b3JMYXlvdXR9IGZyb20gJy4vZmVlLWNhbGN1bGF0b3InO1xuaW1wb3J0IHt0b0J1ZmZlcn0gZnJvbSAnLi91dGlscy90by1idWZmZXInO1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvMGVhMjg0M2VjOWNkYzUxNzU3MmI4ZTYyYzk1OWY0MWI1NWNmNDQ1My9zZGsvc3JjL25vbmNlX3N0YXRlLnJzI0wyOS1MMzJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTm9uY2VBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgUmVhZG9ubHk8e1xuICAgIGF1dGhvcml6ZWRQdWJrZXk6IFVpbnQ4QXJyYXk7XG4gICAgZmVlQ2FsY3VsYXRvcjogUmVhZG9ubHk8e1xuICAgICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IG51bWJlcjtcbiAgICB9PjtcbiAgICBub25jZTogVWludDhBcnJheTtcbiAgICBzdGF0ZTogbnVtYmVyO1xuICAgIHZlcnNpb246IG51bWJlcjtcbiAgfT5cbj4oW1xuICBCdWZmZXJMYXlvdXQudTMyKCd2ZXJzaW9uJyksXG4gIEJ1ZmZlckxheW91dC51MzIoJ3N0YXRlJyksXG4gIExheW91dC5wdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSxcbiAgTGF5b3V0LnB1YmxpY0tleSgnbm9uY2UnKSxcbiAgQnVmZmVyTGF5b3V0LnN0cnVjdDxSZWFkb25seTx7bGFtcG9ydHNQZXJTaWduYXR1cmU6IG51bWJlcn0+PihcbiAgICBbRmVlQ2FsY3VsYXRvckxheW91dF0sXG4gICAgJ2ZlZUNhbGN1bGF0b3InLFxuICApLFxuXSk7XG5cbmV4cG9ydCBjb25zdCBOT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5vbmNlQWNjb3VudExheW91dC5zcGFuO1xuXG4vKipcbiAqIEEgZHVyYWJsZSBub25jZSBpcyBhIDMyIGJ5dGUgdmFsdWUgZW5jb2RlZCBhcyBhIGJhc2U1OCBzdHJpbmcuXG4gKi9cbmV4cG9ydCB0eXBlIER1cmFibGVOb25jZSA9IHN0cmluZztcblxudHlwZSBOb25jZUFjY291bnRBcmdzID0ge1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG4gIG5vbmNlOiBEdXJhYmxlTm9uY2U7XG4gIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3I7XG59O1xuXG4vKipcbiAqIE5vbmNlQWNjb3VudCBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgTm9uY2VBY2NvdW50IHtcbiAgYXV0aG9yaXplZFB1YmtleTogUHVibGljS2V5O1xuICBub25jZTogRHVyYWJsZU5vbmNlO1xuICBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IE5vbmNlQWNjb3VudEFyZ3MpIHtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSBhcmdzLmF1dGhvcml6ZWRQdWJrZXk7XG4gICAgdGhpcy5ub25jZSA9IGFyZ3Mubm9uY2U7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gYXJncy5mZWVDYWxjdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIE5vbmNlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gTm9uY2VBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKFxuICAgIGJ1ZmZlcjogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICk6IE5vbmNlQWNjb3VudCB7XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50ID0gTm9uY2VBY2NvdW50TGF5b3V0LmRlY29kZSh0b0J1ZmZlcihidWZmZXIpLCAwKTtcbiAgICByZXR1cm4gbmV3IE5vbmNlQWNjb3VudCh7XG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5hdXRob3JpemVkUHVia2V5KSxcbiAgICAgIG5vbmNlOiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5ub25jZSkudG9TdHJpbmcoKSxcbiAgICAgIGZlZUNhbGN1bGF0b3I6IG5vbmNlQWNjb3VudC5mZWVDYWxjdWxhdG9yLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7YmxvYiwgTGF5b3V0fSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHt0b0JpZ0ludExFLCB0b0J1ZmZlckxFfSBmcm9tICdiaWdpbnQtYnVmZmVyJztcblxuaW50ZXJmYWNlIEVuY29kZURlY29kZTxUPiB7XG4gIGRlY29kZShidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0PzogbnVtYmVyKTogVDtcbiAgZW5jb2RlKHNyYzogVCwgYnVmZmVyOiBCdWZmZXIsIG9mZnNldD86IG51bWJlcik6IG51bWJlcjtcbn1cblxuY29uc3QgZW5jb2RlRGVjb2RlID0gPFQ+KGxheW91dDogTGF5b3V0PFQ+KTogRW5jb2RlRGVjb2RlPFQ+ID0+IHtcbiAgY29uc3QgZGVjb2RlID0gbGF5b3V0LmRlY29kZS5iaW5kKGxheW91dCk7XG4gIGNvbnN0IGVuY29kZSA9IGxheW91dC5lbmNvZGUuYmluZChsYXlvdXQpO1xuICByZXR1cm4ge2RlY29kZSwgZW5jb2RlfTtcbn07XG5cbmNvbnN0IGJpZ0ludCA9XG4gIChsZW5ndGg6IG51bWJlcikgPT5cbiAgKHByb3BlcnR5Pzogc3RyaW5nKTogTGF5b3V0PGJpZ2ludD4gPT4ge1xuICAgIGNvbnN0IGxheW91dCA9IGJsb2IobGVuZ3RoLCBwcm9wZXJ0eSk7XG4gICAgY29uc3Qge2VuY29kZSwgZGVjb2RlfSA9IGVuY29kZURlY29kZShsYXlvdXQpO1xuXG4gICAgY29uc3QgYmlnSW50TGF5b3V0ID0gbGF5b3V0IGFzIExheW91dDx1bmtub3duPiBhcyBMYXlvdXQ8YmlnaW50PjtcblxuICAgIGJpZ0ludExheW91dC5kZWNvZGUgPSAoYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBzcmMgPSBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIHRvQmlnSW50TEUoQnVmZmVyLmZyb20oc3JjKSk7XG4gICAgfTtcblxuICAgIGJpZ0ludExheW91dC5lbmNvZGUgPSAoYmlnSW50OiBiaWdpbnQsIGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qgc3JjID0gdG9CdWZmZXJMRShiaWdJbnQsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gYmlnSW50TGF5b3V0O1xuICB9O1xuXG5leHBvcnQgY29uc3QgdTY0ID0gYmlnSW50KDgpO1xuXG5leHBvcnQgY29uc3QgdTEyOCA9IGJpZ0ludCgxNik7XG5cbmV4cG9ydCBjb25zdCB1MTkyID0gYmlnSW50KDI0KTtcblxuZXhwb3J0IGNvbnN0IHUyNTYgPSBiaWdJbnQoMzIpO1xuIiwiaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5cbmltcG9ydCB7XG4gIGVuY29kZURhdGEsXG4gIGRlY29kZURhdGEsXG4gIEluc3RydWN0aW9uVHlwZSxcbiAgSUluc3RydWN0aW9uSW5wdXREYXRhLFxufSBmcm9tICcuLi9pbnN0cnVjdGlvbic7XG5pbXBvcnQgKiBhcyBMYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCB7Tk9OQ0VfQUNDT1VOVF9MRU5HVEh9IGZyb20gJy4uL25vbmNlLWFjY291bnQnO1xuaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4uL3B1YmxpY2tleSc7XG5pbXBvcnQge1NZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLCBTWVNWQVJfUkVOVF9QVUJLRVl9IGZyb20gJy4uL3N5c3Zhcic7XG5pbXBvcnQge1RyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge3RvQnVmZmVyfSBmcm9tICcuLi91dGlscy90by1idWZmZXInO1xuaW1wb3J0IHt1NjR9IGZyb20gJy4uL3V0aWxzL2JpZ2ludCc7XG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBDcmVhdGVBY2NvdW50UGFyYW1zID0ge1xuICAvKiogVGhlIGFjY291bnQgdGhhdCB3aWxsIHRyYW5zZmVyIGxhbXBvcnRzIHRvIHRoZSBjcmVhdGVkIGFjY291bnQgKi9cbiAgZnJvbVB1YmtleTogUHVibGljS2V5O1xuICAvKiogUHVibGljIGtleSBvZiB0aGUgY3JlYXRlZCBhY2NvdW50ICovXG4gIG5ld0FjY291bnRQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEFtb3VudCBvZiBsYW1wb3J0cyB0byB0cmFuc2ZlciB0byB0aGUgY3JlYXRlZCBhY2NvdW50ICovXG4gIGxhbXBvcnRzOiBudW1iZXI7XG4gIC8qKiBBbW91bnQgb2Ygc3BhY2UgaW4gYnl0ZXMgdG8gYWxsb2NhdGUgdG8gdGhlIGNyZWF0ZWQgYWNjb3VudCAqL1xuICBzcGFjZTogbnVtYmVyO1xuICAvKiogUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBhc3NpZ24gYXMgdGhlIG93bmVyIG9mIHRoZSBjcmVhdGVkIGFjY291bnQgKi9cbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIFRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNmZXJQYXJhbXMgPSB7XG4gIC8qKiBBY2NvdW50IHRoYXQgd2lsbCB0cmFuc2ZlciBsYW1wb3J0cyAqL1xuICBmcm9tUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBY2NvdW50IHRoYXQgd2lsbCByZWNlaXZlIHRyYW5zZmVycmVkIGxhbXBvcnRzICovXG4gIHRvUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBbW91bnQgb2YgbGFtcG9ydHMgdG8gdHJhbnNmZXIgKi9cbiAgbGFtcG9ydHM6IG51bWJlciB8IGJpZ2ludDtcbn07XG5cbi8qKlxuICogQXNzaWduIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgQXNzaWduUGFyYW1zID0ge1xuICAvKiogUHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB3aGljaCB3aWxsIGJlIGFzc2lnbmVkIGEgbmV3IG93bmVyICovXG4gIGFjY291bnRQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIHByb2dyYW0gdG8gYXNzaWduIGFzIHRoZSBvd25lciAqL1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgQ3JlYXRlQWNjb3VudFdpdGhTZWVkUGFyYW1zID0ge1xuICAvKiogVGhlIGFjY291bnQgdGhhdCB3aWxsIHRyYW5zZmVyIGxhbXBvcnRzIHRvIHRoZSBjcmVhdGVkIGFjY291bnQgKi9cbiAgZnJvbVB1YmtleTogUHVibGljS2V5O1xuICAvKiogUHVibGljIGtleSBvZiB0aGUgY3JlYXRlZCBhY2NvdW50LiBNdXN0IGJlIHByZS1jYWxjdWxhdGVkIHdpdGggUHVibGljS2V5LmNyZWF0ZVdpdGhTZWVkKCkgKi9cbiAgbmV3QWNjb3VudFB1YmtleTogUHVibGljS2V5O1xuICAvKiogQmFzZSBwdWJsaWMga2V5IHRvIHVzZSB0byBkZXJpdmUgdGhlIGFkZHJlc3Mgb2YgdGhlIGNyZWF0ZWQgYWNjb3VudC4gTXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgYmFzZSBrZXkgdXNlZCB0byBjcmVhdGUgYG5ld0FjY291bnRQdWJrZXlgICovXG4gIGJhc2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFNlZWQgdG8gdXNlIHRvIGRlcml2ZSB0aGUgYWRkcmVzcyBvZiB0aGUgY3JlYXRlZCBhY2NvdW50LiBNdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSBzZWVkIHVzZWQgdG8gY3JlYXRlIGBuZXdBY2NvdW50UHVia2V5YCAqL1xuICBzZWVkOiBzdHJpbmc7XG4gIC8qKiBBbW91bnQgb2YgbGFtcG9ydHMgdG8gdHJhbnNmZXIgdG8gdGhlIGNyZWF0ZWQgYWNjb3VudCAqL1xuICBsYW1wb3J0czogbnVtYmVyO1xuICAvKiogQW1vdW50IG9mIHNwYWNlIGluIGJ5dGVzIHRvIGFsbG9jYXRlIHRvIHRoZSBjcmVhdGVkIGFjY291bnQgKi9cbiAgc3BhY2U6IG51bWJlcjtcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIHByb2dyYW0gdG8gYXNzaWduIGFzIHRoZSBvd25lciBvZiB0aGUgY3JlYXRlZCBhY2NvdW50ICovXG4gIHByb2dyYW1JZDogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIENyZWF0ZU5vbmNlQWNjb3VudFBhcmFtcyA9IHtcbiAgLyoqIFRoZSBhY2NvdW50IHRoYXQgd2lsbCB0cmFuc2ZlciBsYW1wb3J0cyB0byB0aGUgY3JlYXRlZCBub25jZSBhY2NvdW50ICovXG4gIGZyb21QdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIGNyZWF0ZWQgbm9uY2UgYWNjb3VudCAqL1xuICBub25jZVB1YmtleTogUHVibGljS2V5O1xuICAvKiogUHVibGljIGtleSB0byBzZXQgYXMgYXV0aG9yaXR5IG9mIHRoZSBjcmVhdGVkIG5vbmNlIGFjY291bnQgKi9cbiAgYXV0aG9yaXplZFB1YmtleTogUHVibGljS2V5O1xuICAvKiogQW1vdW50IG9mIGxhbXBvcnRzIHRvIHRyYW5zZmVyIHRvIHRoZSBjcmVhdGVkIG5vbmNlIGFjY291bnQgKi9cbiAgbGFtcG9ydHM6IG51bWJlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgQ3JlYXRlTm9uY2VBY2NvdW50V2l0aFNlZWRQYXJhbXMgPSB7XG4gIC8qKiBUaGUgYWNjb3VudCB0aGF0IHdpbGwgdHJhbnNmZXIgbGFtcG9ydHMgdG8gdGhlIGNyZWF0ZWQgbm9uY2UgYWNjb3VudCAqL1xuICBmcm9tUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBQdWJsaWMga2V5IG9mIHRoZSBjcmVhdGVkIG5vbmNlIGFjY291bnQgKi9cbiAgbm9uY2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFB1YmxpYyBrZXkgdG8gc2V0IGFzIGF1dGhvcml0eSBvZiB0aGUgY3JlYXRlZCBub25jZSBhY2NvdW50ICovXG4gIGF1dGhvcml6ZWRQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEFtb3VudCBvZiBsYW1wb3J0cyB0byB0cmFuc2ZlciB0byB0aGUgY3JlYXRlZCBub25jZSBhY2NvdW50ICovXG4gIGxhbXBvcnRzOiBudW1iZXI7XG4gIC8qKiBCYXNlIHB1YmxpYyBrZXkgdG8gdXNlIHRvIGRlcml2ZSB0aGUgYWRkcmVzcyBvZiB0aGUgbm9uY2UgYWNjb3VudCAqL1xuICBiYXNlUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBTZWVkIHRvIHVzZSB0byBkZXJpdmUgdGhlIGFkZHJlc3Mgb2YgdGhlIG5vbmNlIGFjY291bnQgKi9cbiAgc2VlZDogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBJbml0aWFsaXplTm9uY2VQYXJhbXMgPSB7XG4gIC8qKiBOb25jZSBhY2NvdW50IHdoaWNoIHdpbGwgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgbm9uY2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFB1YmxpYyBrZXkgdG8gc2V0IGFzIGF1dGhvcml0eSBvZiB0aGUgaW5pdGlhbGl6ZWQgbm9uY2UgYWNjb3VudCAqL1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIEFkdmFuY2Ugbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIEFkdmFuY2VOb25jZVBhcmFtcyA9IHtcbiAgLyoqIE5vbmNlIGFjY291bnQgKi9cbiAgbm9uY2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIG5vbmNlIGF1dGhvcml0eSAqL1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIFdpdGhkcmF3IG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBXaXRoZHJhd05vbmNlUGFyYW1zID0ge1xuICAvKiogTm9uY2UgYWNjb3VudCAqL1xuICBub25jZVB1YmtleTogUHVibGljS2V5O1xuICAvKiogUHVibGljIGtleSBvZiB0aGUgbm9uY2UgYXV0aG9yaXR5ICovXG4gIGF1dGhvcml6ZWRQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSB3aXRoZHJhd24gbm9uY2UgYWNjb3VudCBiYWxhbmNlICovXG4gIHRvUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBbW91bnQgb2YgbGFtcG9ydHMgdG8gd2l0aGRyYXcgZnJvbSB0aGUgbm9uY2UgYWNjb3VudCAqL1xuICBsYW1wb3J0czogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBBdXRob3JpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhvcml6ZU5vbmNlUGFyYW1zID0ge1xuICAvKiogTm9uY2UgYWNjb3VudCAqL1xuICBub25jZVB1YmtleTogUHVibGljS2V5O1xuICAvKiogUHVibGljIGtleSBvZiB0aGUgY3VycmVudCBub25jZSBhdXRob3JpdHkgKi9cbiAgYXV0aG9yaXplZFB1YmtleTogUHVibGljS2V5O1xuICAvKiogUHVibGljIGtleSB0byBzZXQgYXMgdGhlIG5ldyBub25jZSBhdXRob3JpdHkgKi9cbiAgbmV3QXV0aG9yaXplZFB1YmtleTogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgQWxsb2NhdGVQYXJhbXMgPSB7XG4gIC8qKiBBY2NvdW50IHRvIGFsbG9jYXRlICovXG4gIGFjY291bnRQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEFtb3VudCBvZiBzcGFjZSBpbiBieXRlcyB0byBhbGxvY2F0ZSAqL1xuICBzcGFjZTogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIEFsbG9jYXRlV2l0aFNlZWRQYXJhbXMgPSB7XG4gIC8qKiBBY2NvdW50IHRvIGFsbG9jYXRlICovXG4gIGFjY291bnRQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEJhc2UgcHVibGljIGtleSB0byB1c2UgdG8gZGVyaXZlIHRoZSBhZGRyZXNzIG9mIHRoZSBhbGxvY2F0ZWQgYWNjb3VudCAqL1xuICBiYXNlUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBTZWVkIHRvIHVzZSB0byBkZXJpdmUgdGhlIGFkZHJlc3Mgb2YgdGhlIGFsbG9jYXRlZCBhY2NvdW50ICovXG4gIHNlZWQ6IHN0cmluZztcbiAgLyoqIEFtb3VudCBvZiBzcGFjZSBpbiBieXRlcyB0byBhbGxvY2F0ZSAqL1xuICBzcGFjZTogbnVtYmVyO1xuICAvKiogUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBhc3NpZ24gYXMgdGhlIG93bmVyIG9mIHRoZSBhbGxvY2F0ZWQgYWNjb3VudCAqL1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogQXNzaWduIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgQXNzaWduV2l0aFNlZWRQYXJhbXMgPSB7XG4gIC8qKiBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50IHdoaWNoIHdpbGwgYmUgYXNzaWduZWQgYSBuZXcgb3duZXIgKi9cbiAgYWNjb3VudFB1YmtleTogUHVibGljS2V5O1xuICAvKiogQmFzZSBwdWJsaWMga2V5IHRvIHVzZSB0byBkZXJpdmUgdGhlIGFkZHJlc3Mgb2YgdGhlIGFzc2lnbmVkIGFjY291bnQgKi9cbiAgYmFzZVB1YmtleTogUHVibGljS2V5O1xuICAvKiogU2VlZCB0byB1c2UgdG8gZGVyaXZlIHRoZSBhZGRyZXNzIG9mIHRoZSBhc3NpZ25lZCBhY2NvdW50ICovXG4gIHNlZWQ6IHN0cmluZztcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIHByb2dyYW0gdG8gYXNzaWduIGFzIHRoZSBvd25lciAqL1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogVHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNmZXJXaXRoU2VlZFBhcmFtcyA9IHtcbiAgLyoqIEFjY291bnQgdGhhdCB3aWxsIHRyYW5zZmVyIGxhbXBvcnRzICovXG4gIGZyb21QdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEJhc2UgcHVibGljIGtleSB0byB1c2UgdG8gZGVyaXZlIHRoZSBmdW5kaW5nIGFjY291bnQgYWRkcmVzcyAqL1xuICBiYXNlUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBY2NvdW50IHRoYXQgd2lsbCByZWNlaXZlIHRyYW5zZmVycmVkIGxhbXBvcnRzICovXG4gIHRvUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBbW91bnQgb2YgbGFtcG9ydHMgdG8gdHJhbnNmZXIgKi9cbiAgbGFtcG9ydHM6IG51bWJlciB8IGJpZ2ludDtcbiAgLyoqIFNlZWQgdG8gdXNlIHRvIGRlcml2ZSB0aGUgZnVuZGluZyBhY2NvdW50IGFkZHJlc3MgKi9cbiAgc2VlZDogc3RyaW5nO1xuICAvKiogUHJvZ3JhbSBpZCB0byB1c2UgdG8gZGVyaXZlIHRoZSBmdW5kaW5nIGFjY291bnQgYWRkcmVzcyAqL1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbn07XG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuZXhwb3J0IHR5cGUgRGVjb2RlZFRyYW5zZmVySW5zdHJ1Y3Rpb24gPSB7XG4gIC8qKiBBY2NvdW50IHRoYXQgd2lsbCB0cmFuc2ZlciBsYW1wb3J0cyAqL1xuICBmcm9tUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBY2NvdW50IHRoYXQgd2lsbCByZWNlaXZlIHRyYW5zZmVycmVkIGxhbXBvcnRzICovXG4gIHRvUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBbW91bnQgb2YgbGFtcG9ydHMgdG8gdHJhbnNmZXIgKi9cbiAgbGFtcG9ydHM6IGJpZ2ludDtcbn07XG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyV2l0aFNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uICovXG5leHBvcnQgdHlwZSBEZWNvZGVkVHJhbnNmZXJXaXRoU2VlZEluc3RydWN0aW9uID0ge1xuICAvKiogQWNjb3VudCB0aGF0IHdpbGwgdHJhbnNmZXIgbGFtcG9ydHMgKi9cbiAgZnJvbVB1YmtleTogUHVibGljS2V5O1xuICAvKiogQmFzZSBwdWJsaWMga2V5IHRvIHVzZSB0byBkZXJpdmUgdGhlIGZ1bmRpbmcgYWNjb3VudCBhZGRyZXNzICovXG4gIGJhc2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEFjY291bnQgdGhhdCB3aWxsIHJlY2VpdmUgdHJhbnNmZXJyZWQgbGFtcG9ydHMgKi9cbiAgdG9QdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEFtb3VudCBvZiBsYW1wb3J0cyB0byB0cmFuc2ZlciAqL1xuICBsYW1wb3J0czogYmlnaW50O1xuICAvKiogU2VlZCB0byB1c2UgdG8gZGVyaXZlIHRoZSBmdW5kaW5nIGFjY291bnQgYWRkcmVzcyAqL1xuICBzZWVkOiBzdHJpbmc7XG4gIC8qKiBQcm9ncmFtIGlkIHRvIHVzZSB0byBkZXJpdmUgdGhlIGZ1bmRpbmcgYWNjb3VudCBhZGRyZXNzICovXG4gIHByb2dyYW1JZDogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBTeXN0ZW0gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFN5c3RlbUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG5cbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG5cbiAgICBsZXQgdHlwZTogU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGUgYXMgU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN5c3RlbUluc3RydWN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY3JlYXRlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUFjY291bnQoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IENyZWF0ZUFjY291bnRQYXJhbXMge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuXG4gICAgY29uc3Qge2xhbXBvcnRzLCBzcGFjZSwgcHJvZ3JhbUlkfSA9IGRlY29kZURhdGEoXG4gICAgICBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGUsXG4gICAgICBpbnN0cnVjdGlvbi5kYXRhLFxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHRyYW5zZmVyIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcihcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogRGVjb2RlZFRyYW5zZmVySW5zdHJ1Y3Rpb24ge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuXG4gICAgY29uc3Qge2xhbXBvcnRzfSA9IGRlY29kZURhdGEoXG4gICAgICBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcixcbiAgICAgIGluc3RydWN0aW9uLmRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcldpdGhTZWVkKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBEZWNvZGVkVHJhbnNmZXJXaXRoU2VlZEluc3RydWN0aW9uIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcblxuICAgIGNvbnN0IHtsYW1wb3J0cywgc2VlZCwgcHJvZ3JhbUlkfSA9IGRlY29kZURhdGEoXG4gICAgICBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhbGxvY2F0ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGUoaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24pOiBBbGxvY2F0ZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG5cbiAgICBjb25zdCB7c3BhY2V9ID0gZGVjb2RlRGF0YShcbiAgICAgIFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BhY2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBBbGxvY2F0ZVdpdGhTZWVkUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcblxuICAgIGNvbnN0IHtiYXNlLCBzZWVkLCBzcGFjZSwgcHJvZ3JhbUlkfSA9IGRlY29kZURhdGEoXG4gICAgICBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduKGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uKTogQXNzaWduUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcblxuICAgIGNvbnN0IHtwcm9ncmFtSWR9ID0gZGVjb2RlRGF0YShcbiAgICAgIFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbixcbiAgICAgIGluc3RydWN0aW9uLmRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFzc2lnbldpdGhTZWVkKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBBc3NpZ25XaXRoU2VlZFBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG5cbiAgICBjb25zdCB7YmFzZSwgc2VlZCwgcHJvZ3JhbUlkfSA9IGRlY29kZURhdGEoXG4gICAgICBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZCxcbiAgICAgIGluc3RydWN0aW9uLmRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZVdpdGhTZWVkKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBDcmVhdGVBY2NvdW50V2l0aFNlZWRQYXJhbXMge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuXG4gICAgY29uc3Qge2Jhc2UsIHNlZWQsIGxhbXBvcnRzLCBzcGFjZSwgcHJvZ3JhbUlkfSA9IGRlY29kZURhdGEoXG4gICAgICBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVXaXRoU2VlZCxcbiAgICAgIGluc3RydWN0aW9uLmRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBpbml0aWFsaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUluaXRpYWxpemUoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IEluaXRpYWxpemVOb25jZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG5cbiAgICBjb25zdCB7YXV0aG9yaXplZH0gPSBkZWNvZGVEYXRhKFxuICAgICAgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCxcbiAgICAgIGluc3RydWN0aW9uLmRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYWR2YW5jZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBZHZhbmNlKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBBZHZhbmNlTm9uY2VQYXJhbXMge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuXG4gICAgZGVjb2RlRGF0YShcbiAgICAgIFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQsXG4gICAgICBpbnN0cnVjdGlvbi5kYXRhLFxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSB3aXRoZHJhdyBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VXaXRoZHJhdyhcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogV2l0aGRyYXdOb25jZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG5cbiAgICBjb25zdCB7bGFtcG9ydHN9ID0gZGVjb2RlRGF0YShcbiAgICAgIFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50LFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhdXRob3JpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQXV0aG9yaXplKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBBdXRob3JpemVOb25jZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG5cbiAgICBjb25zdCB7YXV0aG9yaXplZH0gPSBkZWNvZGVEYXRhKFxuICAgICAgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50LFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZDogUHVibGljS2V5KSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN5c3RlbVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5czogQXJyYXk8YW55PiwgZXhwZWN0ZWRMZW5ndGg6IG51bWJlcikge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN5c3RlbUluc3RydWN0aW9uVHlwZSdzXG4gKi9cbmV4cG9ydCB0eXBlIFN5c3RlbUluc3RydWN0aW9uVHlwZSA9XG4gIC8vIEZJWE1FXG4gIC8vIEl0IHdvdWxkIGJlIHByZWZlcmFibGUgZm9yIHRoaXMgdHlwZSB0byBiZSBga2V5b2YgU3lzdGVtSW5zdHJ1Y3Rpb25JbnB1dERhdGFgXG4gIC8vIGJ1dCBUeXBlZG9jIGRvZXMgbm90IHRyYW5zcGlsZSBga2V5b2ZgIGV4cHJlc3Npb25zLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvdHlwZWRvYy9pc3N1ZXMvMTg5NFxuICB8ICdBZHZhbmNlTm9uY2VBY2NvdW50J1xuICB8ICdBbGxvY2F0ZSdcbiAgfCAnQWxsb2NhdGVXaXRoU2VlZCdcbiAgfCAnQXNzaWduJ1xuICB8ICdBc3NpZ25XaXRoU2VlZCdcbiAgfCAnQXV0aG9yaXplTm9uY2VBY2NvdW50J1xuICB8ICdDcmVhdGUnXG4gIHwgJ0NyZWF0ZVdpdGhTZWVkJ1xuICB8ICdJbml0aWFsaXplTm9uY2VBY2NvdW50J1xuICB8ICdUcmFuc2ZlcidcbiAgfCAnVHJhbnNmZXJXaXRoU2VlZCdcbiAgfCAnV2l0aGRyYXdOb25jZUFjY291bnQnXG4gIHwgJ1VwZ3JhZGVOb25jZUFjY291bnQnO1xuXG50eXBlIFN5c3RlbUluc3RydWN0aW9uSW5wdXREYXRhID0ge1xuICBBZHZhbmNlTm9uY2VBY2NvdW50OiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGE7XG4gIEFsbG9jYXRlOiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJiB7XG4gICAgc3BhY2U6IG51bWJlcjtcbiAgfTtcbiAgQWxsb2NhdGVXaXRoU2VlZDogSUluc3RydWN0aW9uSW5wdXREYXRhICYge1xuICAgIGJhc2U6IFVpbnQ4QXJyYXk7XG4gICAgcHJvZ3JhbUlkOiBVaW50OEFycmF5O1xuICAgIHNlZWQ6IHN0cmluZztcbiAgICBzcGFjZTogbnVtYmVyO1xuICB9O1xuICBBc3NpZ246IElJbnN0cnVjdGlvbklucHV0RGF0YSAmIHtcbiAgICBwcm9ncmFtSWQ6IFVpbnQ4QXJyYXk7XG4gIH07XG4gIEFzc2lnbldpdGhTZWVkOiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJiB7XG4gICAgYmFzZTogVWludDhBcnJheTtcbiAgICBzZWVkOiBzdHJpbmc7XG4gICAgcHJvZ3JhbUlkOiBVaW50OEFycmF5O1xuICB9O1xuICBBdXRob3JpemVOb25jZUFjY291bnQ6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmIHtcbiAgICBhdXRob3JpemVkOiBVaW50OEFycmF5O1xuICB9O1xuICBDcmVhdGU6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmIHtcbiAgICBsYW1wb3J0czogbnVtYmVyO1xuICAgIHByb2dyYW1JZDogVWludDhBcnJheTtcbiAgICBzcGFjZTogbnVtYmVyO1xuICB9O1xuICBDcmVhdGVXaXRoU2VlZDogSUluc3RydWN0aW9uSW5wdXREYXRhICYge1xuICAgIGJhc2U6IFVpbnQ4QXJyYXk7XG4gICAgbGFtcG9ydHM6IG51bWJlcjtcbiAgICBwcm9ncmFtSWQ6IFVpbnQ4QXJyYXk7XG4gICAgc2VlZDogc3RyaW5nO1xuICAgIHNwYWNlOiBudW1iZXI7XG4gIH07XG4gIEluaXRpYWxpemVOb25jZUFjY291bnQ6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmIHtcbiAgICBhdXRob3JpemVkOiBVaW50OEFycmF5O1xuICB9O1xuICBUcmFuc2ZlcjogSUluc3RydWN0aW9uSW5wdXREYXRhICYge1xuICAgIGxhbXBvcnRzOiBiaWdpbnQ7XG4gIH07XG4gIFRyYW5zZmVyV2l0aFNlZWQ6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmIHtcbiAgICBsYW1wb3J0czogYmlnaW50O1xuICAgIHByb2dyYW1JZDogVWludDhBcnJheTtcbiAgICBzZWVkOiBzdHJpbmc7XG4gIH07XG4gIFdpdGhkcmF3Tm9uY2VBY2NvdW50OiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJiB7XG4gICAgbGFtcG9ydHM6IG51bWJlcjtcbiAgfTtcbiAgVXBncmFkZU5vbmNlQWNjb3VudDogSUluc3RydWN0aW9uSW5wdXREYXRhO1xufTtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzeXN0ZW0gSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplPHtcbiAgW0luc3RydWN0aW9uIGluIFN5c3RlbUluc3RydWN0aW9uVHlwZV06IEluc3RydWN0aW9uVHlwZTxcbiAgICBTeXN0ZW1JbnN0cnVjdGlvbklucHV0RGF0YVtJbnN0cnVjdGlvbl1cbiAgPjtcbn0+KHtcbiAgQ3JlYXRlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFN5c3RlbUluc3RydWN0aW9uSW5wdXREYXRhWydDcmVhdGUnXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLFxuICAgICAgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksXG4gICAgICBMYXlvdXQucHVibGljS2V5KCdwcm9ncmFtSWQnKSxcbiAgICBdKSxcbiAgfSxcbiAgQXNzaWduOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFN5c3RlbUluc3RydWN0aW9uSW5wdXREYXRhWydBc3NpZ24nXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIExheW91dC5wdWJsaWNLZXkoJ3Byb2dyYW1JZCcpLFxuICAgIF0pLFxuICB9LFxuICBUcmFuc2Zlcjoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxTeXN0ZW1JbnN0cnVjdGlvbklucHV0RGF0YVsnVHJhbnNmZXInXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIHU2NCgnbGFtcG9ydHMnKSxcbiAgICBdKSxcbiAgfSxcbiAgQ3JlYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8U3lzdGVtSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ0NyZWF0ZVdpdGhTZWVkJ10+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICBMYXlvdXQucHVibGljS2V5KCdiYXNlJyksXG4gICAgICBMYXlvdXQucnVzdFN0cmluZygnc2VlZCcpLFxuICAgICAgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksXG4gICAgICBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSxcbiAgICAgIExheW91dC5wdWJsaWNLZXkoJ3Byb2dyYW1JZCcpLFxuICAgIF0pLFxuICB9LFxuICBBZHZhbmNlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFxuICAgICAgU3lzdGVtSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ0FkdmFuY2VOb25jZUFjY291bnQnXVxuICAgID4oW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKSxcbiAgfSxcbiAgV2l0aGRyYXdOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBTeXN0ZW1JbnN0cnVjdGlvbklucHV0RGF0YVsnV2l0aGRyYXdOb25jZUFjY291bnQnXVxuICAgID4oW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSksXG4gIH0sXG4gIEluaXRpYWxpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBTeXN0ZW1JbnN0cnVjdGlvbklucHV0RGF0YVsnSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCddXG4gICAgPihbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgTGF5b3V0LnB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSksXG4gIH0sXG4gIEF1dGhvcml6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgICAgIFN5c3RlbUluc3RydWN0aW9uSW5wdXREYXRhWydBdXRob3JpemVOb25jZUFjY291bnQnXVxuICAgID4oW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIExheW91dC5wdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pLFxuICB9LFxuICBBbGxvY2F0ZToge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxTeXN0ZW1JbnN0cnVjdGlvbklucHV0RGF0YVsnQWxsb2NhdGUnXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLFxuICAgIF0pLFxuICB9LFxuICBBbGxvY2F0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDksXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFN5c3RlbUluc3RydWN0aW9uSW5wdXREYXRhWydBbGxvY2F0ZVdpdGhTZWVkJ10+KFxuICAgICAgW1xuICAgICAgICBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLFxuICAgICAgICBMYXlvdXQucHVibGljS2V5KCdiYXNlJyksXG4gICAgICAgIExheW91dC5ydXN0U3RyaW5nKCdzZWVkJyksXG4gICAgICAgIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLFxuICAgICAgICBMYXlvdXQucHVibGljS2V5KCdwcm9ncmFtSWQnKSxcbiAgICAgIF0sXG4gICAgKSxcbiAgfSxcbiAgQXNzaWduV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFN5c3RlbUluc3RydWN0aW9uSW5wdXREYXRhWydBc3NpZ25XaXRoU2VlZCddPihbXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLFxuICAgICAgTGF5b3V0LnB1YmxpY0tleSgnYmFzZScpLFxuICAgICAgTGF5b3V0LnJ1c3RTdHJpbmcoJ3NlZWQnKSxcbiAgICAgIExheW91dC5wdWJsaWNLZXkoJ3Byb2dyYW1JZCcpLFxuICAgIF0pLFxuICB9LFxuICBUcmFuc2ZlcldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDExLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxTeXN0ZW1JbnN0cnVjdGlvbklucHV0RGF0YVsnVHJhbnNmZXJXaXRoU2VlZCddPihcbiAgICAgIFtcbiAgICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgICAgdTY0KCdsYW1wb3J0cycpLFxuICAgICAgICBMYXlvdXQucnVzdFN0cmluZygnc2VlZCcpLFxuICAgICAgICBMYXlvdXQucHVibGljS2V5KCdwcm9ncmFtSWQnKSxcbiAgICAgIF0sXG4gICAgKSxcbiAgfSxcbiAgVXBncmFkZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiAxMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBTeXN0ZW1JbnN0cnVjdGlvbklucHV0RGF0YVsnVXBncmFkZU5vbmNlQWNjb3VudCddXG4gICAgPihbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pLFxuICB9LFxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFN5c3RlbSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBTeXN0ZW1Qcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgU3lzdGVtIHByb2dyYW1cbiAgICovXG4gIHN0YXRpYyBwcm9ncmFtSWQ6IFB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoXG4gICAgJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyxcbiAgKTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zOiBDcmVhdGVBY2NvdW50UGFyYW1zKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKSxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIHtwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICBdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHRyYW5zZmVycyBsYW1wb3J0cyBmcm9tIG9uZSBhY2NvdW50IHRvIGFub3RoZXJcbiAgICovXG4gIHN0YXRpYyB0cmFuc2ZlcihcbiAgICBwYXJhbXM6IFRyYW5zZmVyUGFyYW1zIHwgVHJhbnNmZXJXaXRoU2VlZFBhcmFtcyxcbiAgKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cyksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSksXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbXG4gICAgICAgIHtwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgICB7cHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICAgICAge3B1YmtleTogcGFyYW1zLnRvUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge2xhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKX0pO1xuICAgICAga2V5cyA9IFtcbiAgICAgICAge3B1YmtleTogcGFyYW1zLmZyb21QdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAge3B1YmtleTogcGFyYW1zLnRvUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhc3NpZ25zIGFuIGFjY291bnQgdG8gYSBwcm9ncmFtXG4gICAqL1xuICBzdGF0aWMgYXNzaWduKFxuICAgIHBhcmFtczogQXNzaWduUGFyYW1zIHwgQXNzaWduV2l0aFNlZWRQYXJhbXMsXG4gICk6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpLFxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW1xuICAgICAgICB7cHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAge3B1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSksXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe3B1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChcbiAgICBwYXJhbXM6IENyZWF0ZUFjY291bnRXaXRoU2VlZFBhcmFtcyxcbiAgKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKSxcbiAgICB9KTtcbiAgICBsZXQga2V5cyA9IFtcbiAgICAgIHtwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICB7cHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICBdO1xuICAgIGlmIChwYXJhbXMuYmFzZVB1YmtleSAhPSBwYXJhbXMuZnJvbVB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTm9uY2VBY2NvdW50KFxuICAgIHBhcmFtczogQ3JlYXRlTm9uY2VBY2NvdW50UGFyYW1zIHwgQ3JlYXRlTm9uY2VBY2NvdW50V2l0aFNlZWRQYXJhbXMsXG4gICk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zICYmICdzZWVkJyBpbiBwYXJhbXMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChcbiAgICAgICAgU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChcbiAgICAgICAgU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgICBub25jZVB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgfTtcblxuICAgIHRyYW5zYWN0aW9uLmFkZCh0aGlzLm5vbmNlSW5pdGlhbGl6ZShpbml0UGFyYW1zKSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGluaXRpYWxpemUgYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VJbml0aWFsaXplKFxuICAgIHBhcmFtczogSW5pdGlhbGl6ZU5vbmNlUGFyYW1zLFxuICApOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMuYXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7cHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gdG8gYWR2YW5jZSB0aGUgbm9uY2UgaW4gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VBZHZhbmNlKHBhcmFtczogQWR2YW5jZU5vbmNlUGFyYW1zKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW1xuICAgICAgICB7cHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAge3B1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICBdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgd2l0aGRyYXdzIGxhbXBvcnRzIGZyb20gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VXaXRoZHJhdyhwYXJhbXM6IFdpdGhkcmF3Tm9uY2VQYXJhbXMpOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge2xhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHN9KTtcblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAge3B1YmtleTogcGFyYW1zLnRvUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHtwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyB0aGUgYXV0aG9yaXR5XG4gICAqIG9uIGEgTm9uY2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBub25jZUF1dGhvcml6ZShwYXJhbXM6IEF1dGhvcml6ZU5vbmNlUGFyYW1zKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMubmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAge3B1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICBdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGFsbG9jYXRlcyBzcGFjZSBpbiBhbiBhY2NvdW50IHdpdGhvdXQgZnVuZGluZ1xuICAgKi9cbiAgc3RhdGljIGFsbG9jYXRlKFxuICAgIHBhcmFtczogQWxsb2NhdGVQYXJhbXMgfCBBbGxvY2F0ZVdpdGhTZWVkUGFyYW1zLFxuICApOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpLFxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW1xuICAgICAgICB7cHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAge3B1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGU7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe3B1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcblxuaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4vcHVibGlja2V5JztcbmltcG9ydCB7VHJhbnNhY3Rpb24sIFBBQ0tFVF9EQVRBX1NJWkV9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHtNU19QRVJfU0xPVH0gZnJvbSAnLi90aW1pbmcnO1xuaW1wb3J0IHtTWVNWQVJfUkVOVF9QVUJLRVl9IGZyb20gJy4vc3lzdmFyJztcbmltcG9ydCB7c2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbn0gZnJvbSAnLi91dGlscy9zZW5kLWFuZC1jb25maXJtLXRyYW5zYWN0aW9uJztcbmltcG9ydCB7c2xlZXB9IGZyb20gJy4vdXRpbHMvc2xlZXAnO1xuaW1wb3J0IHR5cGUge0Nvbm5lY3Rpb259IGZyb20gJy4vY29ubmVjdGlvbic7XG5pbXBvcnQgdHlwZSB7U2lnbmVyfSBmcm9tICcuL2tleXBhaXInO1xuaW1wb3J0IHtTeXN0ZW1Qcm9ncmFtfSBmcm9tICcuL3Byb2dyYW1zL3N5c3RlbSc7XG5pbXBvcnQge0lJbnN0cnVjdGlvbklucHV0RGF0YX0gZnJvbSAnLi9pbnN0cnVjdGlvbic7XG5cbi8vIEtlZXAgcHJvZ3JhbSBjaHVua3MgdW5kZXIgUEFDS0VUX0RBVEFfU0laRSwgbGVhdmluZyBlbm91Z2ggcm9vbSBmb3IgdGhlXG4vLyByZXN0IG9mIHRoZSBUcmFuc2FjdGlvbiBmaWVsZHNcbi8vXG4vLyBUT0RPOiByZXBsYWNlIDMwMCB3aXRoIGEgcHJvcGVyIGNvbnN0YW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgb3RoZXJcbi8vIFRyYW5zYWN0aW9uIGZpZWxkc1xuY29uc3QgQ0hVTktfU0laRSA9IFBBQ0tFVF9EQVRBX1NJWkUgLSAzMDA7XG5cbi8qKlxuICogUHJvZ3JhbSBsb2FkZXIgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2FkZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBwcm9ncmFtIGRhdGEgcGxhY2VkIGluIGVhY2ggbG9hZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIGNodW5rU2l6ZTogbnVtYmVyID0gQ0hVTktfU0laRTtcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBsb2FkIGEgcHJvZ3JhbSBub3QgaW5jbHVkaW5nXG4gICAqIHJldHJpZXNcbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICovXG4gIHN0YXRpYyBnZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIChcbiAgICAgIDIgKiAvLyBFdmVyeSB0cmFuc2FjdGlvbiByZXF1aXJlcyB0d28gc2lnbmF0dXJlcyAocGF5ZXIgKyBwcm9ncmFtKVxuICAgICAgKE1hdGguY2VpbChkYXRhTGVuZ3RoIC8gTG9hZGVyLmNodW5rU2l6ZSkgK1xuICAgICAgICAxICsgLy8gQWRkIG9uZSBmb3IgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgICAgIDEpIC8vIEFkZCBvbmUgZm9yIEZpbmFsaXplIHRyYW5zYWN0aW9uXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGdlbmVyaWMgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIFN5c3RlbSBhY2NvdW50IHRoYXQgcGF5cyB0byBsb2FkIHRoZSBwcm9ncmFtXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGxvYWRlclxuICAgKiBAcGFyYW0gZGF0YSBQcm9ncmFtIG9jdGV0c1xuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkKFxuICAgIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gICAgcGF5ZXI6IFNpZ25lcixcbiAgICBwcm9ncmFtOiBTaWduZXIsXG4gICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXksXG4gICAgZGF0YTogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHtcbiAgICAgIGNvbnN0IGJhbGFuY2VOZWVkZWQgPSBhd2FpdCBjb25uZWN0aW9uLmdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihcbiAgICAgICAgZGF0YS5sZW5ndGgsXG4gICAgICApO1xuXG4gICAgICAvLyBGZXRjaCBwcm9ncmFtIGFjY291bnQgaW5mbyB0byBjaGVjayBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhcbiAgICAgICAgcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICdjb25maXJtZWQnLFxuICAgICAgKTtcblxuICAgICAgbGV0IHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbiB8IG51bGwgPSBudWxsO1xuICAgICAgaWYgKHByb2dyYW1JbmZvICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsb2FkIGZhaWxlZCwgYWNjb3VudCBpcyBhbHJlYWR5IGV4ZWN1dGFibGUnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoXG4gICAgICAgICAgICBTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb2dyYW1JbmZvLm93bmVyLmVxdWFscyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoXG4gICAgICAgICAgICBTeXN0ZW1Qcm9ncmFtLmFzc2lnbih7XG4gICAgICAgICAgICAgIGFjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmxhbXBvcnRzIDwgYmFsYW5jZU5lZWRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFxuICAgICAgICAgICAgU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgdG9QdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCAtIHByb2dyYW1JbmZvLmxhbXBvcnRzLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoXG4gICAgICAgICAgU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgPiAwID8gYmFsYW5jZU5lZWRlZCA6IDEsXG4gICAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhY2NvdW50IGlzIGFscmVhZHkgY3JlYXRlZCBjb3JyZWN0bHksIHNraXAgdGhpcyBzdGVwXG4gICAgICAvLyBhbmQgcHJvY2VlZCBkaXJlY3RseSB0byBsb2FkaW5nIGluc3RydWN0aW9uc1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oXG4gICAgICAgICAgY29ubmVjdGlvbixcbiAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICBbcGF5ZXIsIHByb2dyYW1dLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBSZWFkb25seTx7XG4gICAgICAgIGJ5dGVzOiBudW1iZXJbXTtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IG51bWJlcjtcbiAgICAgICAgYnl0ZXNMZW5ndGhQYWRkaW5nOiBudW1iZXI7XG4gICAgICAgIGluc3RydWN0aW9uOiBudW1iZXI7XG4gICAgICAgIG9mZnNldDogbnVtYmVyO1xuICAgICAgfT5cbiAgICA+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCdvZmZzZXQnKSxcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2J5dGVzTGVuZ3RoJyksXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aFBhZGRpbmcnKSxcbiAgICAgIEJ1ZmZlckxheW91dC5zZXEoXG4gICAgICAgIEJ1ZmZlckxheW91dC51OCgnYnl0ZScpLFxuICAgICAgICBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLFxuICAgICAgICAnYnl0ZXMnLFxuICAgICAgKSxcbiAgICBdKTtcblxuICAgIGNvbnN0IGNodW5rU2l6ZSA9IExvYWRlci5jaHVua1NpemU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IGFycmF5ID0gZGF0YTtcbiAgICBsZXQgdHJhbnNhY3Rpb25zID0gW107XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXkuc2xpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoY2h1bmtTaXplICsgMTYpO1xuICAgICAgZGF0YUxheW91dC5lbmNvZGUoXG4gICAgICAgIHtcbiAgICAgICAgICBpbnN0cnVjdGlvbjogMCwgLy8gTG9hZCBpbnN0cnVjdGlvblxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBieXRlczogYnl0ZXMgYXMgbnVtYmVyW10sXG4gICAgICAgICAgYnl0ZXNMZW5ndGg6IDAsXG4gICAgICAgICAgYnl0ZXNMZW5ndGhQYWRkaW5nOiAwLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe3B1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YSxcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb25zLnB1c2goXG4gICAgICAgIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJyxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICAvLyBEZWxheSBiZXR3ZWVuIHNlbmRzIGluIGFuIGF0dGVtcHQgdG8gcmVkdWNlIHJhdGUgbGltaXQgZXJyb3JzXG4gICAgICBpZiAoY29ubmVjdGlvbi5fcnBjRW5kcG9pbnQuaW5jbHVkZXMoJ3NvbGFuYS5jb20nKSkge1xuICAgICAgICBjb25zdCBSRVFVRVNUU19QRVJfU0VDT05EID0gNDtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCAvIFJFUVVFU1RTX1BFUl9TRUNPTkQpO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgYXJyYXkgPSBhcnJheS5zbGljZShjaHVua1NpemUpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMpO1xuXG4gICAgLy8gRmluYWxpemUgdGhlIGFjY291bnQgbG9hZGVkIHdpdGggcHJvZ3JhbSBkYXRhIGZvciBleGVjdXRpb25cbiAgICB7XG4gICAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdDxJSW5zdHJ1Y3Rpb25JbnB1dERhdGE+KFtcbiAgICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZShcbiAgICAgICAge1xuICAgICAgICAgIGluc3RydWN0aW9uOiAxLCAvLyBGaW5hbGl6ZSBpbnN0cnVjdGlvblxuICAgICAgICB9LFxuICAgICAgICBkYXRhLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAge3B1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAgICB7cHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgICBdLFxuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGEsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveUNvbW1pdG1lbnQgPSAncHJvY2Vzc2VkJztcbiAgICAgIGNvbnN0IGZpbmFsaXplU2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24oXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBbcGF5ZXIsIHByb2dyYW1dLFxuICAgICAgICB7cHJlZmxpZ2h0Q29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudH0sXG4gICAgICApO1xuICAgICAgY29uc3Qge2NvbnRleHQsIHZhbHVlfSA9IGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKFxuICAgICAgICB7XG4gICAgICAgICAgc2lnbmF0dXJlOiBmaW5hbGl6ZVNpZ25hdHVyZSxcbiAgICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQhLFxuICAgICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoISxcbiAgICAgICAgfSxcbiAgICAgICAgZGVwbG95Q29tbWl0bWVudCxcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVHJhbnNhY3Rpb24gJHtmaW5hbGl6ZVNpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIHByZXZlbnQgcHJvZ3JhbXMgZnJvbSBiZWluZyB1c2FibGUgdW50aWwgdGhlIHNsb3QgYWZ0ZXIgdGhlaXIgZGVwbG95bWVudC5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjk2NTRcbiAgICAgIHdoaWxlIChcbiAgICAgICAgdHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFNsb3QgPSBhd2FpdCBjb25uZWN0aW9uLmdldFNsb3Qoe1xuICAgICAgICAgICAgY29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY3VycmVudFNsb3QgPiBjb250ZXh0LnNsb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLyogZW1wdHkgKi9cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+XG4gICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJvdW5kKE1TX1BFUl9TTE9UIC8gMikpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN1Y2Nlc3NcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcblxuaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4vcHVibGlja2V5JztcbmltcG9ydCB7TG9hZGVyfSBmcm9tICcuL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7Q29ubmVjdGlvbn0gZnJvbSAnLi9jb25uZWN0aW9uJztcbmltcG9ydCB0eXBlIHtTaWduZXJ9IGZyb20gJy4va2V5cGFpcic7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmV4cG9ydCBjb25zdCBCUEZfTE9BREVSX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KFxuICAnQlBGTG9hZGVyMjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScsXG4pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIGEgcHJvZ3JhbSBsb2FkZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS4xNy4yMC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJwZkxvYWRlciB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTG9hZGVyLmdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIFNCRiBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gcGF5ZXIgQWNjb3VudCB0aGF0IHdpbGwgcGF5IHByb2dyYW0gbG9hZGluZyBmZWVzXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBlbGYgVGhlIGVudGlyZSBFTEYgY29udGFpbmluZyB0aGUgU0JGIHByb2dyYW1cbiAgICogQHBhcmFtIGxvYWRlclByb2dyYW1JZCBUaGUgcHJvZ3JhbSBpZCBvZiB0aGUgQlBGIGxvYWRlciB0byB1c2VcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgbG9hZChcbiAgICBjb25uZWN0aW9uOiBDb25uZWN0aW9uLFxuICAgIHBheWVyOiBTaWduZXIsXG4gICAgcHJvZ3JhbTogU2lnbmVyLFxuICAgIGVsZjogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgbG9hZGVyUHJvZ3JhbUlkOiBQdWJsaWNLZXksXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBMb2FkZXIubG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgbG9hZGVyUHJvZ3JhbUlkLCBlbGYpO1xuICB9XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvKiFcbiAqIGh1bWFuaXplLW1zIC0gaW5kZXguanNcbiAqIENvcHlyaWdodChjKSAyMDE0IGRlYWRfaG9yc2UgPGRlYWRfaG9yc2VAcXEuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgbXMgPSByZXF1aXJlKCdtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicpIHJldHVybiB0O1xuICB2YXIgciA9IG1zKHQpO1xuICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnaHVtYW5pemUtbXMoJWopIHJlc3VsdCB1bmRlZmluZWQnLCB0KSk7XG4gICAgY29uc29sZS53YXJuKGVyci5zdGFjayk7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYWdlbnRcbiAgQ1VSUkVOVF9JRDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjdXJyZW50SWQnKSxcbiAgQ1JFQVRFX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUlkJyksXG4gIElOSVRfU09DS0VUOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2luaXRTb2NrZXQnKSxcbiAgQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT046IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3JlYXRlSHR0cHNDb25uZWN0aW9uJyksXG4gIC8vIHNvY2tldFxuICBTT0NLRVRfQ1JFQVRFRF9USU1FOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldENyZWF0ZWRUaW1lJyksXG4gIFNPQ0tFVF9OQU1FOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldE5hbWUnKSxcbiAgU09DS0VUX1JFUVVFU1RfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdENvdW50JyksXG4gIFNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldFJlcXVlc3RGaW5pc2hlZENvdW50JyksXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBPcmlnaW5hbEFnZW50ID0gcmVxdWlyZSgnaHR0cCcpLkFnZW50O1xuY29uc3QgbXMgPSByZXF1aXJlKCdodW1hbml6ZS1tcycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCd1dGlsJykuZGVidWdsb2coJ2FnZW50a2VlcGFsaXZlJyk7XG5jb25zdCB7XG4gIElOSVRfU09DS0VULFxuICBDVVJSRU5UX0lELFxuICBDUkVBVEVfSUQsXG4gIFNPQ0tFVF9DUkVBVEVEX1RJTUUsXG4gIFNPQ0tFVF9OQU1FLFxuICBTT0NLRVRfUkVRVUVTVF9DT1VOVCxcbiAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLy8gT3JpZ2luYWxBZ2VudCBjb21lIGZyb21cbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjguMTIuMC9saWIvX2h0dHBfYWdlbnQuanNcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjEyLjAvbGliL19odHRwX2FnZW50LmpzXG5cbi8vIG5vZGUgPD0gMTBcbmxldCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAxO1xuY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJywgMSlbMF0uc3Vic3RyaW5nKDEpKTtcbmlmIChtYWpvclZlcnNpb24gPj0gMTEgJiYgbWFqb3JWZXJzaW9uIDw9IDEyKSB7XG4gIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDI7XG59IGVsc2UgaWYgKG1ham9yVmVyc2lvbiA+PSAxMykge1xuICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAzO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZygnW2FnZW50a2VlcGFsaXZlOmRlcHJlY2F0ZWRdICVzJywgbWVzc2FnZSk7XG59XG5cbmNsYXNzIEFnZW50IGV4dGVuZHMgT3JpZ2luYWxBZ2VudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmtlZXBBbGl2ZSA9IG9wdGlvbnMua2VlcEFsaXZlICE9PSBmYWxzZTtcbiAgICAvLyBkZWZhdWx0IGlzIGtlZXAtYWxpdmUgYW5kIDRzIGZyZWUgc29ja2V0IHRpbWVvdXRcbiAgICAvLyBzZWUgaHR0cHM6Ly9tZWRpdW0uY29tL3NzZW5zZS10ZWNoL3JlZHVjZS1uZXR3b3JraW5nLWVycm9ycy1pbi1ub2RlanMtMjNiNGViOWYyZDgzXG4gICAgaWYgKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IDQwMDA7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBBUEk6IGtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG4gICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlVGltZW91dCkge1xuICAgICAgZGVwcmVjYXRlKCdvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcbiAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgICBkZWxldGUgb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuICAgIH1cbiAgICAvLyBMZWdhY3kgQVBJOiBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBzaG91bGQgYmUgcmVuYW1lIHRvIGBmcmVlU29ja2V0VGltZW91dGBcbiAgICBpZiAob3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCkge1xuICAgICAgZGVwcmVjYXRlKCdvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG4gICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuICAgIH1cblxuICAgIC8vIFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyIHRpbWVvdXQgbWlsbGlzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gdGhlIHNvY2tldC5cbiAgICAvLyBCeSBkZWZhdWx0IGlzIGRvdWJsZSBmcmVlIHNvY2tldCB0aW1lb3V0LlxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHNvY2tldCBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dCA+PSA4c1xuICAgICAgb3B0aW9ucy50aW1lb3V0ID0gTWF0aC5tYXgob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCAqIDIsIDgwMDApO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnQgaHVtYW5pemUgZm9ybWF0XG4gICAgb3B0aW9ucy50aW1lb3V0ID0gbXMob3B0aW9ucy50aW1lb3V0KTtcbiAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gbXMob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCk7XG4gICAgb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPSBvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCA/IG1zKG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSA6IDA7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXNbQ1VSUkVOVF9JRF0gPSAwO1xuXG4gICAgLy8gY3JlYXRlIHNvY2tldCBzdWNjZXNzIGNvdW50ZXJcbiAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50ID0gMDtcbiAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCA9IDA7XG4gICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrID0gMDtcblxuICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudCA9IDA7XG4gICAgdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIC8vIHNvY2tldCBlcnJvciBldmVudCBjb3VudFxuICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudCA9IDA7XG4gICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIC8vIHJlcXVlc3QgZmluaXNoZWQgY291bnRlclxuICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICAvLyBpbmNsdWRpbmcgZnJlZSBzb2NrZXQgdGltZW91dCBjb3VudGVyXG4gICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnQgPSAwO1xuICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIHRoaXMub24oJ2ZyZWUnLCBzb2NrZXQgPT4ge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzIwMDBcbiAgICAgIC8vIE5vZGUuanMgbmF0aXZlIGFnZW50IHdpbGwgY2hlY2sgc29ja2V0IHRpbWVvdXQgZXFzIGFnZW50Lm9wdGlvbnMudGltZW91dC5cbiAgICAgIC8vIFVzZSB0aGUgdHRsIG9yIGZyZWVTb2NrZXRUaW1lb3V0IHRvIG92ZXJ3cml0ZS5cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG4gICAgICBpZiAodGltZW91dCA+IDAgJiYgc29ja2V0LnRpbWVvdXQgIT09IHRpbWVvdXQpIHtcbiAgICAgICAgc29ja2V0LnNldFRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQoKSB7XG4gICAgZGVwcmVjYXRlKCdhZ2VudC5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG4gIH1cblxuICBnZXQgdGltZW91dCgpIHtcbiAgICBkZXByZWNhdGUoJ2FnZW50LnRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnRpbWVvdXQgaW5zdGVhZCcpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGltZW91dDtcbiAgfVxuXG4gIGdldCBzb2NrZXRBY3RpdmVUVEwoKSB7XG4gICAgZGVwcmVjYXRlKCdhZ2VudC5zb2NrZXRBY3RpdmVUVEwgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTCBpbnN0ZWFkJyk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG4gIH1cblxuICBjYWxjU29ja2V0VGltZW91dChzb2NrZXQpIHtcbiAgICAvKipcbiAgICAgKiByZXR1cm4gPD0gMDogc2hvdWxkIGZyZWUgc29ja2V0XG4gICAgICogcmV0dXJuID4gMDogc2hvdWxkIHVwZGF0ZSBzb2NrZXQgdGltZW91dFxuICAgICAqIHJldHVybiB1bmRlZmluZWQ6IG5vdCBmaW5kIGN1c3RvbSB0aW1lb3V0XG4gICAgICovXG4gICAgbGV0IGZyZWVTb2NrZXRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0O1xuICAgIGNvbnN0IHNvY2tldEFjdGl2ZVRUTCA9IHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG4gICAgaWYgKHNvY2tldEFjdGl2ZVRUTCkge1xuICAgICAgLy8gY2hlY2sgc29ja2V0QWN0aXZlVFRMXG4gICAgICBjb25zdCBhbGl2ZVRpbWUgPSBEYXRlLm5vdygpIC0gc29ja2V0W1NPQ0tFVF9DUkVBVEVEX1RJTUVdO1xuICAgICAgY29uc3QgZGlmZiA9IHNvY2tldEFjdGl2ZVRUTCAtIGFsaXZlVGltZTtcbiAgICAgIGlmIChkaWZmIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9XG4gICAgICBpZiAoZnJlZVNvY2tldFRpbWVvdXQgJiYgZGlmZiA8IGZyZWVTb2NrZXRUaW1lb3V0KSB7XG4gICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0ID0gZGlmZjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IGZyZWVTb2NrZXRUaW1lb3V0XG4gICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0KSB7XG4gICAgICAvLyBzZXQgZnJlZSBrZWVwYWxpdmUgdGltZXJcbiAgICAgIC8vIHRyeSB0byB1c2Ugc29ja2V0IGN1c3RvbSBmcmVlU29ja2V0VGltZW91dCBmaXJzdCwgc3VwcG9ydCBoZWFkZXJzWydrZWVwLWFsaXZlJ11cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLW1vZHVsZXMvdXJsbGliL2Jsb2IvYjc2MDUzMDIwOTIzZjRkOTlhMWM5M2NmMmUxNmUwYzViYTEwYmFjZi9saWIvdXJsbGliLmpzI0w0OThcbiAgICAgIGNvbnN0IGN1c3RvbUZyZWVTb2NrZXRUaW1lb3V0ID0gc29ja2V0LmZyZWVTb2NrZXRUaW1lb3V0IHx8IHNvY2tldC5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcbiAgICAgIHJldHVybiBjdXN0b21GcmVlU29ja2V0VGltZW91dCB8fCBmcmVlU29ja2V0VGltZW91dDtcbiAgICB9XG4gIH1cblxuICBrZWVwU29ja2V0QWxpdmUoc29ja2V0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIua2VlcFNvY2tldEFsaXZlKHNvY2tldCk7XG4gICAgLy8gc2hvdWxkIG5vdCBrZWVwQWxpdmUsIGRvIG5vdGhpbmdcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNvbnN0IGN1c3RvbVRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21UaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjdXN0b21UaW1lb3V0IDw9IDApIHtcbiAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZnJlZSBidXQgbmVlZCB0byBkZXN0cm95IGJ5IFRUTCwgcmVxdWVzdCBjb3VudCAlcywgZGlmZiBpcyAlcycsXG4gICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGN1c3RvbVRpbWVvdXQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc29ja2V0LnRpbWVvdXQgIT09IGN1c3RvbVRpbWVvdXQpIHtcbiAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGN1c3RvbVRpbWVvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIG9ubHkgY2FsbCBvbiBhZGRSZXF1ZXN0XG4gIHJldXNlU29ja2V0KC4uLmFyZ3MpIHtcbiAgICAvLyByZXVzZVNvY2tldChzb2NrZXQsIHJlcSlcbiAgICBzdXBlci5yZXVzZVNvY2tldCguLi5hcmdzKTtcbiAgICBjb25zdCBzb2NrZXQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IHJlcSA9IGFyZ3NbMV07XG4gICAgcmVxLnJldXNlZFNvY2tldCA9IHRydWU7XG4gICAgY29uc3QgYWdlbnRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG4gICAgaWYgKGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSAhPT0gYWdlbnRUaW1lb3V0KSB7XG4gICAgICAvLyByZXNldCB0aW1lb3V0IGJlZm9yZSB1c2VcbiAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGFnZW50VGltZW91dCk7XG4gICAgICBkZWJ1ZygnJXMgcmVzZXQgdGltZW91dCB0byAlc21zJywgc29ja2V0W1NPQ0tFVF9OQU1FXSwgYWdlbnRUaW1lb3V0KTtcbiAgICB9XG4gICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgcmV1c2Ugb24gYWRkUmVxdWVzdCwgdGltZW91dCAlc21zJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG4gICAgICBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuICB9XG5cbiAgW0NSRUFURV9JRF0oKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzW0NVUlJFTlRfSURdKys7XG4gICAgaWYgKHRoaXNbQ1VSUkVOVF9JRF0gPT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB0aGlzW0NVUlJFTlRfSURdID0gMDtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBbSU5JVF9TT0NLRVRdKHNvY2tldCwgb3B0aW9ucykge1xuICAgIC8vIGJ1Z2ZpeCBoZXJlLlxuICAgIC8vIGh0dHBzIG9uIG5vZGUgOCwgMTAgd29uJ3Qgc2V0IGFnZW50Lm9wdGlvbnMudGltZW91dCBieSBkZWZhdWx0XG4gICAgLy8gVE9ETzogbmVlZCB0byBmaXggb24gbm9kZSBpdHNlbGZcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KG9wdGlvbnMudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIERpc2FibGUgTmFnbGUncyBhbGdvcml0aG06IGh0dHA6Ly9ibG9nLmNhdXN0aWsuY29tLzIwMTIvMDQvMDgvc2NhbGluZy1ub2RlLWpzLXRvLTEwMGstY29uY3VycmVudC1jb25uZWN0aW9ucy9cbiAgICAgIC8vIGh0dHBzOi8vZmVuZ21rMi5jb20vYmVuY2htYXJrL25hZ2xlLWFsZ29yaXRobS1kZWxheWVkLWFjay1tb2NrLmh0bWxcbiAgICAgIHNvY2tldC5zZXROb0RlbGF5KHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50Kys7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwpIHtcbiAgICAgIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIC8vIGRvbid0IHNob3cgdGhlIGhvbGUgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tJyBrZXkgc3RyaW5nXG4gICAgc29ja2V0W1NPQ0tFVF9OQU1FXSA9IGBzb2NrWyR7dGhpc1tDUkVBVEVfSURdKCl9IyR7b3B0aW9ucy5fYWdlbnRLZXl9XWAuc3BsaXQoJy0tLS0tQkVHSU4nLCAxKVswXTtcbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdID0gMTtcbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdID0gMDtcbiAgICBpbnN0YWxsTGlzdGVuZXJzKHRoaXMsIHNvY2tldCwgb3B0aW9ucyk7XG4gIH1cblxuICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IG9uTmV3Q3JlYXRlID0gKGVyciwgc29ja2V0KSA9PiB7XG4gICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCsrO1xuICAgICAgICByZXR1cm4gb25jcmVhdGUoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXNbSU5JVF9TT0NLRVRdKHNvY2tldCwgb3B0aW9ucyk7XG4gICAgICBvbmNyZWF0ZShlcnIsIHNvY2tldCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG5ld1NvY2tldCA9IHN1cGVyLmNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25OZXdDcmVhdGUpO1xuICAgIGlmIChuZXdTb2NrZXQpIG9uTmV3Q3JlYXRlKG51bGwsIG5ld1NvY2tldCk7XG4gICAgcmV0dXJuIG5ld1NvY2tldDtcbiAgfVxuXG4gIGdldCBzdGF0dXNDaGFuZ2VkKCkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLmNyZWF0ZVNvY2tldENvdW50ICE9PSB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ICE9PSB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudCAhPT0gdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCAhPT0gdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMucmVxdWVzdENvdW50ICE9PSB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjaztcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQ7XG4gICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQ7XG4gICAgICB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmNsb3NlU29ja2V0Q291bnQ7XG4gICAgICB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmVycm9yU29ja2V0Q291bnQ7XG4gICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMudGltZW91dFNvY2tldENvdW50O1xuICAgICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLnJlcXVlc3RDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICBnZXRDdXJyZW50U3RhdHVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVTb2NrZXRDb3VudDogdGhpcy5jcmVhdGVTb2NrZXRDb3VudCxcbiAgICAgIGNyZWF0ZVNvY2tldEVycm9yQ291bnQ6IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCxcbiAgICAgIGNsb3NlU29ja2V0Q291bnQ6IHRoaXMuY2xvc2VTb2NrZXRDb3VudCxcbiAgICAgIGVycm9yU29ja2V0Q291bnQ6IHRoaXMuZXJyb3JTb2NrZXRDb3VudCxcbiAgICAgIHRpbWVvdXRTb2NrZXRDb3VudDogdGhpcy50aW1lb3V0U29ja2V0Q291bnQsXG4gICAgICByZXF1ZXN0Q291bnQ6IHRoaXMucmVxdWVzdENvdW50LFxuICAgICAgZnJlZVNvY2tldHM6IGluc3BlY3QodGhpcy5mcmVlU29ja2V0cyksXG4gICAgICBzb2NrZXRzOiBpbnNwZWN0KHRoaXMuc29ja2V0cyksXG4gICAgICByZXF1ZXN0czogaW5zcGVjdCh0aGlzLnJlcXVlc3RzKSxcbiAgICB9O1xuICB9XG59XG5cbi8vIG5vZGUgOCBkb24ndCBoYXMgdGltZW91dCBhdHRyaWJ1dGUgb24gc29ja2V0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8yMTIwNC9maWxlcyNkaWZmLWU2ZWYwMjRjMzc3NWQ3ODdjMzg0ODdhNjMwOWU0OTFkUjQwOFxuZnVuY3Rpb24gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpIHtcbiAgcmV0dXJuIHNvY2tldC50aW1lb3V0IHx8IHNvY2tldC5faWRsZVRpbWVvdXQ7XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxMaXN0ZW5lcnMoYWdlbnQsIHNvY2tldCwgb3B0aW9ucykge1xuICBkZWJ1ZygnJXMgY3JlYXRlLCB0aW1lb3V0ICVzbXMnLCBzb2NrZXRbU09DS0VUX05BTUVdLCBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuXG4gIC8vIGxpc3RlbmVyIHNvY2tldCBldmVudHM6IGNsb3NlLCB0aW1lb3V0LCBlcnJvciwgZnJlZVxuICBmdW5jdGlvbiBvbkZyZWUoKSB7XG4gICAgLy8gY3JlYXRlIGFuZCBzb2NrZXQuZW1pdCgnZnJlZScpIGxvZ2ljXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9faHR0cF9hZ2VudC5qcyNMMzExXG4gICAgLy8gbm8gcmVxIG9uIHRoZSBzb2NrZXQsIGl0IHNob3VsZCBiZSB0aGUgbmV3IHNvY2tldFxuICAgIGlmICghc29ja2V0Ll9odHRwTWVzc2FnZSAmJiBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdID09PSAxKSByZXR1cm47XG5cbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKys7XG4gICAgYWdlbnQucmVxdWVzdENvdW50Kys7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBmcmVlJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuXG4gICAgLy8gc2hvdWxkIHJldXNlIG9uIHBlZGRpbmcgcmVxdWVzdHM/XG4gICAgY29uc3QgbmFtZSA9IGFnZW50LmdldE5hbWUob3B0aW9ucyk7XG4gICAgaWYgKHNvY2tldC53cml0YWJsZSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXS5sZW5ndGgpIHtcbiAgICAgIC8vIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBsaXN0ZW5lclxuICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuICAgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB3aWxsIGJlIHJldXNlIG9uIGFnZW50IGZyZWUgZXZlbnQnLFxuICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcbiAgICB9XG4gIH1cbiAgc29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcblxuICBmdW5jdGlvbiBvbkNsb3NlKGlzRXJyb3IpIHtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGNsb3NlLCBpc0Vycm9yOiAlcycsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBpc0Vycm9yKTtcbiAgICBhZ2VudC5jbG9zZVNvY2tldENvdW50Kys7XG4gIH1cbiAgc29ja2V0Lm9uKCdjbG9zZScsIG9uQ2xvc2UpO1xuXG4gIC8vIHN0YXJ0IHNvY2tldCB0aW1lb3V0IGhhbmRsZXJcbiAgZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgIC8vIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0KF9odHRwX2NsaWVudC5qcylcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTIueC9saWIvX2h0dHBfY2xpZW50LmpzI0w3MTFcbiAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLmxlbmd0aDtcbiAgICAvLyBub2RlIDw9IDEwLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMSwgb25UaW1lb3V0XG4gICAgLy8gMTEgPCBub2RlIDw9IDEyLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMiwgb25UaW1lb3V0IGFuZCBlbWl0UmVxdWVzdFRpbWVvdXRcbiAgICAvLyBub2RlID49IDEzLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMywgb25UaW1lb3V0LFxuICAgIC8vICAgb25UaW1lb3V0KGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwL2ZpbGVzI2RpZmYtNWY3ZmIwODUwNDEyYzZiZTE4OWZhZWRkZWE2YzUzNTlSMzMzKVxuICAgIC8vICAgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG4gICAgY29uc3QgcmVxID0gc29ja2V0Ll9odHRwTWVzc2FnZTtcbiAgICBjb25zdCByZXFUaW1lb3V0TGlzdGVuZXJDb3VudCA9IHJlcSAmJiByZXEubGlzdGVuZXJzKCd0aW1lb3V0JykubGVuZ3RoIHx8IDA7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB0aW1lb3V0IGFmdGVyICVzbXMsIGxpc3RlbmVycyAlcywgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ICVzLCBoYXNIdHRwUmVxdWVzdCAlcywgSHR0cFJlcXVlc3QgdGltZW91dExpc3RlbmVyQ291bnQgJXMnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcbiAgICAgIHRpbWVvdXQsIGxpc3RlbmVyQ291bnQsIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCwgISFyZXEsIHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50KTtcbiAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgZGVidWcoJ3RpbWVvdXQgbGlzdGVuZXJzOiAlcycsIHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5tYXAoZiA9PiBmLm5hbWUpLmpvaW4oJywgJykpO1xuICAgIH1cbiAgICBhZ2VudC50aW1lb3V0U29ja2V0Q291bnQrKztcbiAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcbiAgICBpZiAoYWdlbnQuZnJlZVNvY2tldHNbbmFtZV0gJiYgYWdlbnQuZnJlZVNvY2tldHNbbmFtZV0uaW5kZXhPZihzb2NrZXQpICE9PSAtMSkge1xuICAgICAgLy8gZnJlZSBzb2NrZXQgdGltZW91dCwgZGVzdHJveSBxdWlldGx5XG4gICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gZnJlZVNvY2tldHMgbGlzdCBpbW1lZGlhdGVseSB0byBwcmV2ZW50IG5ldyByZXF1ZXN0c1xuICAgICAgLy8gZnJvbSBiZWluZyBzZW50IHRocm91Z2ggdGhpcyBzb2NrZXQuXG4gICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcbiAgICAgIGRlYnVnKCclcyBpcyBmcmVlLCBkZXN0cm95IHF1aWV0bHknLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYW55IHJlcXVlc3Qgc29ja2V0IHRpbWVvdXQgaGFuZGxlcixcbiAgICAgIC8vIGFnZW50IG5lZWQgdG8gaGFuZGxlIHNvY2tldCB0aW1lb3V0IGl0c2VsZi5cbiAgICAgIC8vXG4gICAgICAvLyBjdXN0b20gcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGUgbG9naWMgbXVzdCBmb2xsb3cgdGhlc2UgcnVsZXM6XG4gICAgICAvLyAgMS4gRGVzdHJveSBzb2NrZXQgZmlyc3RcbiAgICAgIC8vICAyLiBNdXN0IGVtaXQgc29ja2V0ICdhZ2VudFJlbW92ZScgZXZlbnQgdGVsbCBhZ2VudCByZW1vdmUgc29ja2V0XG4gICAgICAvLyAgICAgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5LlxuICAgICAgLy8gICAgIE90aGVyaXNlIHlvdSBtYXkgYmUgZ2V0ICdzb2NrZXQgaGFuZyB1cCcgZXJyb3Igd2hlbiByZXVzZVxuICAgICAgLy8gICAgIGZyZWUgc29ja2V0IGFuZCB0aW1lb3V0IGhhcHBlbiBpbiB0aGUgc2FtZSB0aW1lLlxuICAgICAgaWYgKHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdTb2NrZXQgdGltZW91dCcpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ0VSUl9TT0NLRVRfVElNRU9VVCc7XG4gICAgICAgIGVycm9yLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICAvLyBtdXN0IG1hbnVhbGx5IGNhbGwgc29ja2V0LmVuZCgpIG9yIHNvY2tldC5kZXN0cm95KCkgdG8gZW5kIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2tcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyb3IpO1xuICAgICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcbiAgICAgICAgZGVidWcoJyVzIGRlc3Ryb3kgd2l0aCB0aW1lb3V0IGVycm9yJywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNvY2tldC5vbigndGltZW91dCcsIG9uVGltZW91dCk7XG5cbiAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGg7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBlcnJvcjogJXMsIGxpc3RlbmVyQ291bnQ6ICVzJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG4gICAgICBlcnIsIGxpc3RlbmVyQ291bnQpO1xuICAgIGFnZW50LmVycm9yU29ja2V0Q291bnQrKztcbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgLy8gaWYgc29ja2V0IGRvbid0IGNvbnRhaW4gZXJyb3IgZXZlbnQgaGFuZGxlciwgZG9uJ3QgY2F0Y2ggaXQsIGVtaXQgaXQgYWdhaW5cbiAgICAgIGRlYnVnKCclcyBlbWl0IHVuY2F1Z2h0IGVycm9yIGV2ZW50Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG4gICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxuICBzb2NrZXQub24oJ2Vycm9yJywgb25FcnJvcik7XG5cbiAgZnVuY3Rpb24gb25SZW1vdmUoKSB7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBhZ2VudFJlbW92ZScsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLFxuICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG4gICAgLy8gV2UgbmVlZCB0aGlzIGZ1bmN0aW9uIGZvciBjYXNlcyBsaWtlIEhUVFAgJ3VwZ3JhZGUnXG4gICAgLy8gKGRlZmluZWQgYnkgV2ViU29ja2V0cykgd2hlcmUgd2UgbmVlZCB0byByZW1vdmUgYSBzb2NrZXQgZnJvbSB0aGVcbiAgICAvLyBwb29sIGJlY2F1c2UgaXQnbGwgYmUgbG9ja2VkIHVwIGluZGVmaW5pdGVseVxuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3RpbWVvdXQnLCBvblRpbWVvdXQpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG4gIH1cbiAgc29ja2V0Lm9uKCdhZ2VudFJlbW92ZScsIG9uUmVtb3ZlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcblxuZnVuY3Rpb24gaW5zcGVjdChvYmopIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc1trZXldID0gb2JqW2tleV0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE9yaWdpbmFsSHR0cHNBZ2VudCA9IHJlcXVpcmUoJ2h0dHBzJykuQWdlbnQ7XG5jb25zdCBIdHRwQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50Jyk7XG5jb25zdCB7XG4gIElOSVRfU09DS0VULFxuICBDUkVBVEVfSFRUUFNfQ09OTkVDVElPTixcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jbGFzcyBIdHRwc0FnZW50IGV4dGVuZHMgSHR0cEFnZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kZWZhdWx0UG9ydCA9IDQ0MztcbiAgICB0aGlzLnByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgdGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9IHRoaXMub3B0aW9ucy5tYXhDYWNoZWRTZXNzaW9ucztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0aGlzLm1heENhY2hlZFNlc3Npb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPSAxMDA7XG4gICAgfVxuXG4gICAgdGhpcy5fc2Vzc2lvbkNhY2hlID0ge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIGxpc3Q6IFtdLFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG4gICAgY29uc3Qgc29ja2V0ID0gdGhpc1tDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0ob3B0aW9ucywgb25jcmVhdGUpO1xuICAgIHRoaXNbSU5JVF9TT0NLRVRdKHNvY2tldCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNvY2tldDtcbiAgfVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2h0dHBzLmpzI0w4OVxuSHR0cHNBZ2VudC5wcm90b3R5cGVbQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT05dID0gT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uO1xuXG5bXG4gICdnZXROYW1lJyxcbiAgJ19nZXRTZXNzaW9uJyxcbiAgJ19jYWNoZVNlc3Npb24nLFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80OTgyXG4gICdfZXZpY3RTZXNzaW9uJyxcbl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdID0gT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdHRwc0FnZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2FnZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5IdHRwc0FnZW50ID0gcmVxdWlyZSgnLi9saWIvaHR0cHNfYWdlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL2NvbnN0YW50cycpO1xuIiwidmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGtleXMgPSBbXTtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0a2V5cy5wdXNoKG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4ga2V5cztcblx0fTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgaXNBcnJheVByb3ApIHtcblx0dmFyIGksIG1heCwgc3RyLCBrZXlzLCBrZXksIHByb3BWYWwsIHRvU3RyO1xuXHRpZiAodmFsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuIFwidHJ1ZVwiO1xuXHR9XG5cdGlmICh2YWwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIFwiZmFsc2VcIjtcblx0fVxuXHRzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcblx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwudG9KU09OICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSh2YWwudG9KU09OKCksIGlzQXJyYXlQcm9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuXHRcdFx0XHRpZiAodG9TdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0XHRcdHN0ciA9ICdbJztcblx0XHRcdFx0XHRtYXggPSB2YWwubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpICsgJywnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWF4ID4gLTEpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN0ciArICddJztcblx0XHRcdFx0fSBlbHNlIGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0XHRcdC8vIG9ubHkgb2JqZWN0IGlzIGxlZnRcblx0XHRcdFx0XHRrZXlzID0gb2JqS2V5cyh2YWwpLnNvcnQoKTtcblx0XHRcdFx0XHRtYXggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRzdHIgPSBcIlwiO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlIChpIDwgbWF4KSB7XG5cdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0cHJvcFZhbCA9IHN0cmluZ2lmeSh2YWxba2V5XSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKHByb3BWYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9ICcsJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHByb3BWYWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAneycgKyBzdHIgKyAnfSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRjYXNlIFwidW5kZWZpbmVkXCI6XG5cdFx0XHRyZXR1cm4gaXNBcnJheVByb3AgPyBudWxsIDogdW5kZWZpbmVkO1xuXHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpIHtcblx0dmFyIHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcblx0aWYgKHJldHVyblZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuICcnKyByZXR1cm5WYWw7XG5cdH1cbn07XG4iLCJjb25zdCBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIID0gMzI7XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHNlbGYuXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKG46IG51bWJlcikge1xuICBsZXQgdHJhaWxpbmdaZXJvcyA9IDA7XG4gIHdoaWxlIChuID4gMSkge1xuICAgIG4gLz0gMjtcbiAgICB0cmFpbGluZ1plcm9zKys7XG4gIH1cbiAgcmV0dXJuIHRyYWlsaW5nWmVyb3M7XG59XG5cbi8vIFJldHVybnMgdGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gblxuZnVuY3Rpb24gbmV4dFBvd2VyT2ZUd28objogbnVtYmVyKSB7XG4gIGlmIChuID09PSAwKSByZXR1cm4gMTtcbiAgbi0tO1xuICBuIHw9IG4gPj4gMTtcbiAgbiB8PSBuID4+IDI7XG4gIG4gfD0gbiA+PiA0O1xuICBuIHw9IG4gPj4gODtcbiAgbiB8PSBuID4+IDE2O1xuICBuIHw9IG4gPj4gMzI7XG4gIHJldHVybiBuICsgMTtcbn1cblxuLyoqXG4gKiBFcG9jaCBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNlcG9jaClcbiAqIENhbiBiZSByZXRyaWV2ZWQgd2l0aCB0aGUge0BsaW5rIENvbm5lY3Rpb24uZ2V0RXBvY2hTY2hlZHVsZX0gbWV0aG9kXG4gKi9cbmV4cG9ydCBjbGFzcyBFcG9jaFNjaGVkdWxlIHtcbiAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzbG90cyBpbiBlYWNoIGVwb2NoICovXG4gIHB1YmxpYyBzbG90c1BlckVwb2NoOiBudW1iZXI7XG4gIC8qKiBUaGUgbnVtYmVyIG9mIHNsb3RzIGJlZm9yZSBiZWdpbm5pbmcgb2YgYW4gZXBvY2ggdG8gY2FsY3VsYXRlIGEgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGF0IGVwb2NoICovXG4gIHB1YmxpYyBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ6IG51bWJlcjtcbiAgLyoqIEluZGljYXRlcyB3aGV0aGVyIGVwb2NocyBzdGFydCBzaG9ydCBhbmQgZ3JvdyAqL1xuICBwdWJsaWMgd2FybXVwOiBib29sZWFuO1xuICAvKiogVGhlIGZpcnN0IGVwb2NoIHdpdGggYHNsb3RzUGVyRXBvY2hgIHNsb3RzICovXG4gIHB1YmxpYyBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXI7XG4gIC8qKiBUaGUgZmlyc3Qgc2xvdCBvZiBgZmlyc3ROb3JtYWxFcG9jaGAgKi9cbiAgcHVibGljIGZpcnN0Tm9ybWFsU2xvdDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNsb3RzUGVyRXBvY2g6IG51bWJlcixcbiAgICBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ6IG51bWJlcixcbiAgICB3YXJtdXA6IGJvb2xlYW4sXG4gICAgZmlyc3ROb3JtYWxFcG9jaDogbnVtYmVyLFxuICAgIGZpcnN0Tm9ybWFsU2xvdDogbnVtYmVyLFxuICApIHtcbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSBzbG90c1BlckVwb2NoO1xuICAgIHRoaXMubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0ID0gbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0O1xuICAgIHRoaXMud2FybXVwID0gd2FybXVwO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IGZpcnN0Tm9ybWFsRXBvY2g7XG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSBmaXJzdE5vcm1hbFNsb3Q7XG4gIH1cblxuICBnZXRFcG9jaChzbG90OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpWzBdO1xuICB9XG5cbiAgZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgaWYgKHNsb3QgPCB0aGlzLmZpcnN0Tm9ybWFsU2xvdCkge1xuICAgICAgY29uc3QgZXBvY2ggPVxuICAgICAgICB0cmFpbGluZ1plcm9zKG5leHRQb3dlck9mVHdvKHNsb3QgKyBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIICsgMSkpIC1cbiAgICAgICAgdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSAtXG4gICAgICAgIDE7XG5cbiAgICAgIGNvbnN0IGVwb2NoTGVuID0gdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpO1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gc2xvdCAtIChlcG9jaExlbiAtIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9ybWFsU2xvdEluZGV4ID0gc2xvdCAtIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgICAgY29uc3Qgbm9ybWFsRXBvY2hJbmRleCA9IE1hdGguZmxvb3Iobm9ybWFsU2xvdEluZGV4IC8gdGhpcy5zbG90c1BlckVwb2NoKTtcbiAgICAgIGNvbnN0IGVwb2NoID0gdGhpcy5maXJzdE5vcm1hbEVwb2NoICsgbm9ybWFsRXBvY2hJbmRleDtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IG5vcm1hbFNsb3RJbmRleCAlIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfVxuICB9XG5cbiAgZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoZXBvY2ggPD0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gKE1hdGgucG93KDIsIGVwb2NoKSAtIDEpICogTUlOSU1VTV9TTE9UX1BFUl9FUE9DSDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGVwb2NoIC0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSAqIHRoaXMuc2xvdHNQZXJFcG9jaCArXG4gICAgICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGdldExhc3RTbG90SW5FcG9jaChlcG9jaDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSArIHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSAtIDE7XG4gIH1cblxuICBnZXRTbG90c0luRXBvY2goZXBvY2g6IG51bWJlcikge1xuICAgIGlmIChlcG9jaCA8IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIGVwb2NoICsgdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBub2RlRmV0Y2ggZnJvbSAnbm9kZS1mZXRjaCc7XG5cbmV4cG9ydCBkZWZhdWx0ICh0eXBlb2YgZ2xvYmFsVGhpcy5mZXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICA/IC8vIFRoZSBGZXRjaCBBUEkgaXMgc3VwcG9ydGVkIGV4cGVyaW1lbnRhbGx5IGluIE5vZGUgMTcuNSsgYW5kIG5hdGl2ZWx5IGluIE5vZGUgMTgrLlxuICAgIGdsb2JhbFRoaXMuZmV0Y2hcbiAgOiAvLyBPdGhlcndpc2UgdXNlIHRoZSBwb2x5ZmlsbC5cbiAgICBhc3luYyBmdW5jdGlvbiAoXG4gICAgICBpbnB1dDogbm9kZUZldGNoLlJlcXVlc3RJbmZvLFxuICAgICAgaW5pdD86IG5vZGVGZXRjaC5SZXF1ZXN0SW5pdCxcbiAgICApOiBQcm9taXNlPG5vZGVGZXRjaC5SZXNwb25zZT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2VkSW5wdXQgPVxuICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIGlucHV0LnNsaWNlKDAsIDIpID09PSAnLy8nXG4gICAgICAgICAgPyAnaHR0cHM6JyArIGlucHV0XG4gICAgICAgICAgOiBpbnB1dDtcbiAgICAgIHJldHVybiBhd2FpdCBub2RlRmV0Y2guZGVmYXVsdChwcm9jZXNzZWRJbnB1dCwgaW5pdCk7XG4gICAgfSkgYXMgdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2g7XG4iLCJpbXBvcnQge1xuICBDb21tb25DbGllbnQsXG4gIElDb21tb25XZWJTb2NrZXQsXG4gIElXU0NsaWVudEFkZGl0aW9uYWxPcHRpb25zLFxuICBOb2RlV2ViU29ja2V0VHlwZSxcbiAgTm9kZVdlYlNvY2tldFR5cGVPcHRpb25zLFxuICBXZWJTb2NrZXQgYXMgY3JlYXRlUnBjLFxufSBmcm9tICdycGMtd2Vic29ja2V0cyc7XG5cbmludGVyZmFjZSBJSGFzUmVhZHlTdGF0ZSB7XG4gIHJlYWR5U3RhdGU6IFdlYlNvY2tldFsncmVhZHlTdGF0ZSddO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBScGNXZWJTb2NrZXRDbGllbnQgZXh0ZW5kcyBDb21tb25DbGllbnQge1xuICBwcml2YXRlIHVuZGVybHlpbmdTb2NrZXQ6IElIYXNSZWFkeVN0YXRlIHwgdW5kZWZpbmVkO1xuICBjb25zdHJ1Y3RvcihcbiAgICBhZGRyZXNzPzogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBJV1NDbGllbnRBZGRpdGlvbmFsT3B0aW9ucyAmIE5vZGVXZWJTb2NrZXRUeXBlT3B0aW9ucyxcbiAgICBnZW5lcmF0ZV9yZXF1ZXN0X2lkPzogKFxuICAgICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgICBwYXJhbXM6IG9iamVjdCB8IEFycmF5PGFueT4sXG4gICAgKSA9PiBudW1iZXIsXG4gICkge1xuICAgIGNvbnN0IHdlYlNvY2tldEZhY3RvcnkgPSAodXJsOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IHJwYyA9IGNyZWF0ZVJwYyh1cmwsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRydWUsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiA1LFxuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogMTAwMCxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIH0pO1xuICAgICAgaWYgKCdzb2NrZXQnIGluIHJwYykge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGMuc29ja2V0IGFzIFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVJwYz47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGMgYXMgTm9kZVdlYlNvY2tldFR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnBjIGFzIElDb21tb25XZWJTb2NrZXQ7XG4gICAgfTtcbiAgICBzdXBlcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKTtcbiAgfVxuICBjYWxsKFxuICAgIC4uLmFyZ3M6IFBhcmFtZXRlcnM8Q29tbW9uQ2xpZW50WydjYWxsJ10+XG4gICk6IFJldHVyblR5cGU8Q29tbW9uQ2xpZW50WydjYWxsJ10+IHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FsbCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKFxuICAgICAgICAnVHJpZWQgdG8gY2FsbCBhIEpTT04tUlBDIG1ldGhvZCBgJyArXG4gICAgICAgICAgYXJnc1swXSArXG4gICAgICAgICAgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgK1xuICAgICAgICAgIHJlYWR5U3RhdGUgK1xuICAgICAgICAgICcpJyxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuICBub3RpZnkoXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczxDb21tb25DbGllbnRbJ25vdGlmeSddPlxuICApOiBSZXR1cm5UeXBlPENvbW1vbkNsaWVudFsnbm90aWZ5J10+IHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIubm90aWZ5KC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoXG4gICAgICAgICdUcmllZCB0byBzZW5kIGEgSlNPTi1SUEMgbm90aWZpY2F0aW9uIGAnICtcbiAgICAgICAgICBhcmdzWzBdICtcbiAgICAgICAgICAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArXG4gICAgICAgICAgcmVhZHlTdGF0ZSArXG4gICAgICAgICAgJyknLFxuICAgICAgKSxcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcblxuZXhwb3J0IGludGVyZmFjZSBJQWNjb3VudFN0YXRlRGF0YSB7XG4gIHJlYWRvbmx5IHR5cGVJbmRleDogbnVtYmVyO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBBY2NvdW50VHlwZTxUSW5wdXREYXRhIGV4dGVuZHMgSUFjY291bnRTdGF0ZURhdGE+ID0ge1xuICAvKiogVGhlIGFjY291bnQgdHlwZSBpbmRleCAoZnJvbSBzb2xhbmEgdXBzdHJlYW0gcHJvZ3JhbSkgKi9cbiAgaW5kZXg6IG51bWJlcjtcbiAgLyoqIFRoZSBCdWZmZXJMYXlvdXQgdG8gdXNlIHRvIGJ1aWxkIGRhdGEgKi9cbiAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuTGF5b3V0PFRJbnB1dERhdGE+O1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYWNjb3VudCBkYXRhIGJ1ZmZlciB1c2luZyBhbiBBY2NvdW50VHlwZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVEYXRhPFRBY2NvdW50U3RhdGVEYXRhIGV4dGVuZHMgSUFjY291bnRTdGF0ZURhdGE+KFxuICB0eXBlOiBBY2NvdW50VHlwZTxUQWNjb3VudFN0YXRlRGF0YT4sXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4pOiBUQWNjb3VudFN0YXRlRGF0YSB7XG4gIGxldCBkZWNvZGVkOiBUQWNjb3VudFN0YXRlRGF0YTtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gdHlwZS5sYXlvdXQuZGVjb2RlKGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG5cbiAgaWYgKGRlY29kZWQudHlwZUluZGV4ICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGludmFsaWQgYWNjb3VudCBkYXRhOyBhY2NvdW50IHR5cGUgbWlzbWF0Y2ggJHtkZWNvZGVkLnR5cGVJbmRleH0gIT0gJHt0eXBlLmluZGV4fWAsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuIiwiaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCAqIGFzIExheW91dCBmcm9tICcuLi8uLi9sYXlvdXQnO1xuaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4uLy4uL3B1YmxpY2tleSc7XG5pbXBvcnQge3U2NH0gZnJvbSAnLi4vLi4vdXRpbHMvYmlnaW50JztcbmltcG9ydCB7ZGVjb2RlRGF0YX0gZnJvbSAnLi4vLi4vYWNjb3VudC1kYXRhJztcblxuZXhwb3J0IHR5cGUgQWRkcmVzc0xvb2t1cFRhYmxlU3RhdGUgPSB7XG4gIGRlYWN0aXZhdGlvblNsb3Q6IGJpZ2ludDtcbiAgbGFzdEV4dGVuZGVkU2xvdDogbnVtYmVyO1xuICBsYXN0RXh0ZW5kZWRTbG90U3RhcnRJbmRleDogbnVtYmVyO1xuICBhdXRob3JpdHk/OiBQdWJsaWNLZXk7XG4gIGFkZHJlc3NlczogQXJyYXk8UHVibGljS2V5Pjtcbn07XG5cbmV4cG9ydCB0eXBlIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRBcmdzID0ge1xuICBrZXk6IFB1YmxpY0tleTtcbiAgc3RhdGU6IEFkZHJlc3NMb29rdXBUYWJsZVN0YXRlO1xufTtcblxuLy8vIFRoZSBzZXJpYWxpemVkIHNpemUgb2YgbG9va3VwIHRhYmxlIG1ldGFkYXRhXG5jb25zdCBMT09LVVBfVEFCTEVfTUVUQV9TSVpFID0gNTY7XG5cbmV4cG9ydCBjbGFzcyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IHtcbiAga2V5OiBQdWJsaWNLZXk7XG4gIHN0YXRlOiBBZGRyZXNzTG9va3VwVGFibGVTdGF0ZTtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50QXJncykge1xuICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3Muc3RhdGU7XG4gIH1cblxuICBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBVNjRfTUFYID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kZWFjdGl2YXRpb25TbG90ID09PSBVNjRfTUFYO1xuICB9XG5cbiAgc3RhdGljIGRlc2VyaWFsaXplKGFjY291bnREYXRhOiBVaW50OEFycmF5KTogQWRkcmVzc0xvb2t1cFRhYmxlU3RhdGUge1xuICAgIGNvbnN0IG1ldGEgPSBkZWNvZGVEYXRhKExvb2t1cFRhYmxlTWV0YUxheW91dCwgYWNjb3VudERhdGEpO1xuXG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiA9IGFjY291bnREYXRhLmxlbmd0aCAtIExPT0tVUF9UQUJMRV9NRVRBX1NJWkU7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPj0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gJSAzMiA9PT0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG5cbiAgICBjb25zdCBudW1TZXJpYWxpemVkQWRkcmVzc2VzID0gc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiAvIDMyO1xuICAgIGNvbnN0IHthZGRyZXNzZXN9ID0gQnVmZmVyTGF5b3V0LnN0cnVjdDx7YWRkcmVzc2VzOiBBcnJheTxVaW50OEFycmF5Pn0+KFtcbiAgICAgIEJ1ZmZlckxheW91dC5zZXEoTGF5b3V0LnB1YmxpY0tleSgpLCBudW1TZXJpYWxpemVkQWRkcmVzc2VzLCAnYWRkcmVzc2VzJyksXG4gICAgXSkuZGVjb2RlKGFjY291bnREYXRhLnNsaWNlKExPT0tVUF9UQUJMRV9NRVRBX1NJWkUpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkZWFjdGl2YXRpb25TbG90OiBtZXRhLmRlYWN0aXZhdGlvblNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90OiBtZXRhLmxhc3RFeHRlbmRlZFNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90U3RhcnRJbmRleDogbWV0YS5sYXN0RXh0ZW5kZWRTdGFydEluZGV4LFxuICAgICAgYXV0aG9yaXR5OlxuICAgICAgICBtZXRhLmF1dGhvcml0eS5sZW5ndGggIT09IDBcbiAgICAgICAgICA/IG5ldyBQdWJsaWNLZXkobWV0YS5hdXRob3JpdHlbMF0pXG4gICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSxcbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IExvb2t1cFRhYmxlTWV0YUxheW91dCA9IHtcbiAgaW5kZXg6IDEsXG4gIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDx7XG4gICAgdHlwZUluZGV4OiBudW1iZXI7XG4gICAgZGVhY3RpdmF0aW9uU2xvdDogYmlnaW50O1xuICAgIGxhc3RFeHRlbmRlZFNsb3Q6IG51bWJlcjtcbiAgICBsYXN0RXh0ZW5kZWRTdGFydEluZGV4OiBudW1iZXI7XG4gICAgYXV0aG9yaXR5OiBBcnJheTxVaW50OEFycmF5PjtcbiAgfT4oW1xuICAgIEJ1ZmZlckxheW91dC51MzIoJ3R5cGVJbmRleCcpLFxuICAgIHU2NCgnZGVhY3RpdmF0aW9uU2xvdCcpLFxuICAgIEJ1ZmZlckxheW91dC5udTY0KCdsYXN0RXh0ZW5kZWRTbG90JyksXG4gICAgQnVmZmVyTGF5b3V0LnU4KCdsYXN0RXh0ZW5kZWRTdGFydEluZGV4JyksXG4gICAgQnVmZmVyTGF5b3V0LnU4KCksIC8vIG9wdGlvblxuICAgIEJ1ZmZlckxheW91dC5zZXEoXG4gICAgICBMYXlvdXQucHVibGljS2V5KCksXG4gICAgICBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51OCgpLCAtMSksXG4gICAgICAnYXV0aG9yaXR5JyxcbiAgICApLFxuICBdKSxcbn07XG4iLCJjb25zdCBVUkxfUkUgPSAvXlteOl0rOlxcL1xcLyhbXjpbXSt8XFxbW15cXF1dK1xcXSkoOlxcZCspPyguKikvaTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VXZWJzb2NrZXRVcmwoZW5kcG9pbnQ6IHN0cmluZykge1xuICBjb25zdCBtYXRjaGVzID0gZW5kcG9pbnQubWF0Y2goVVJMX1JFKTtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihgRmFpbGVkIHRvIHZhbGlkYXRlIGVuZHBvaW50IFVSTCBcXGAke2VuZHBvaW50fVxcYGApO1xuICB9XG4gIGNvbnN0IFtcbiAgICBfLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGhvc3Rpc2gsXG4gICAgcG9ydFdpdGhDb2xvbixcbiAgICByZXN0LFxuICBdID0gbWF0Y2hlcztcbiAgY29uc3QgcHJvdG9jb2wgPSBlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczonKSA/ICd3c3M6JyA6ICd3czonO1xuICBjb25zdCBzdGFydFBvcnQgPVxuICAgIHBvcnRXaXRoQ29sb24gPT0gbnVsbCA/IG51bGwgOiBwYXJzZUludChwb3J0V2l0aENvbG9uLnNsaWNlKDEpLCAxMCk7XG4gIGNvbnN0IHdlYnNvY2tldFBvcnQgPVxuICAgIC8vIE9ubHkgc2hpZnQgdGhlIHBvcnQgYnkgKzEgYXMgYSBjb252ZW50aW9uIGZvciB3cyhzKSBvbmx5IGlmIGdpdmVuIGVuZHBvaW50XG4gICAgLy8gaXMgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBlbmRwb2ludCBwb3J0IChIVFRQLWJhc2VkIFJQQyksIGFzc3VtaW5nXG4gICAgLy8gd2UncmUgZGlyZWN0bHkgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gYWdhdmUtdmFsaWRhdG9yJ3Mgd3MgbGlzdGVuaW5nIHBvcnQuXG4gICAgLy8gV2hlbiB0aGUgZW5kcG9pbnQgb21pdHMgdGhlIHBvcnQsIHdlJ3JlIGNvbm5lY3RpbmcgdG8gdGhlIHByb3RvY29sXG4gICAgLy8gZGVmYXVsdCBwb3J0czogaHR0cCg4MCkgb3IgaHR0cHMoNDQzKSBhbmQgaXQncyBhc3N1bWVkIHdlJ3JlIGJlaGluZCBhIHJldmVyc2VcbiAgICAvLyBwcm94eSB3aGljaCBtYW5hZ2VzIFdlYlNvY2tldCB1cGdyYWRlIGFuZCBiYWNrZW5kIHBvcnQgcmVkaXJlY3Rpb24uXG4gICAgc3RhcnRQb3J0ID09IG51bGwgPyAnJyA6IGA6JHtzdGFydFBvcnQgKyAxfWA7XG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdGlzaH0ke3dlYnNvY2tldFBvcnR9JHtyZXN0fWA7XG59XG4iLCJpbXBvcnQgSHR0cEtlZXBBbGl2ZUFnZW50LCB7XG4gIEh0dHBzQWdlbnQgYXMgSHR0cHNLZWVwQWxpdmVBZ2VudCxcbn0gZnJvbSAnYWdlbnRrZWVwYWxpdmUnO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBmYXN0U3RhYmxlU3RyaW5naWZ5IGZyb20gJ2Zhc3Qtc3RhYmxlLXN0cmluZ2lmeSc7XG5pbXBvcnQgdHlwZSB7QWdlbnQgYXMgTm9kZUh0dHBBZ2VudH0gZnJvbSAnaHR0cCc7XG5pbXBvcnQge0FnZW50IGFzIE5vZGVIdHRwc0FnZW50fSBmcm9tICdodHRwcyc7XG5pbXBvcnQge1xuICB0eXBlIGFzIHBpY2ssXG4gIG51bWJlcixcbiAgc3RyaW5nLFxuICBhcnJheSxcbiAgYm9vbGVhbixcbiAgbGl0ZXJhbCxcbiAgcmVjb3JkLFxuICB1bmlvbixcbiAgb3B0aW9uYWwsXG4gIG51bGxhYmxlLFxuICBjb2VyY2UsXG4gIGluc3RhbmNlLFxuICBjcmVhdGUsXG4gIHR1cGxlLFxuICB1bmtub3duLFxuICBhbnksXG59IGZyb20gJ3N1cGVyc3RydWN0JztcbmltcG9ydCB0eXBlIHtTdHJ1Y3R9IGZyb20gJ3N1cGVyc3RydWN0JztcbmltcG9ydCBScGNDbGllbnQgZnJvbSAnamF5c29uL2xpYi9jbGllbnQvYnJvd3Nlcic7XG5pbXBvcnQge0pTT05SUENFcnJvcn0gZnJvbSAnamF5c29uJztcblxuaW1wb3J0IHtFcG9jaFNjaGVkdWxlfSBmcm9tICcuL2Vwb2NoLXNjaGVkdWxlJztcbmltcG9ydCB7U2VuZFRyYW5zYWN0aW9uRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvcn0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IGZldGNoSW1wbCBmcm9tICcuL2ZldGNoLWltcGwnO1xuaW1wb3J0IHtEdXJhYmxlTm9uY2UsIE5vbmNlQWNjb3VudH0gZnJvbSAnLi9ub25jZS1hY2NvdW50JztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuL3B1YmxpY2tleSc7XG5pbXBvcnQge1NpZ25lcn0gZnJvbSAnLi9rZXlwYWlyJztcbmltcG9ydCBScGNXZWJTb2NrZXRDbGllbnQgZnJvbSAnLi9ycGMtd2Vic29ja2V0JztcbmltcG9ydCB7TVNfUEVSX1NMT1R9IGZyb20gJy4vdGltaW5nJztcbmltcG9ydCB7XG4gIFRyYW5zYWN0aW9uLFxuICBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBWZXJzaW9uZWRUcmFuc2FjdGlvbixcbn0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge01lc3NhZ2UsIE1lc3NhZ2VIZWFkZXIsIE1lc3NhZ2VWMCwgVmVyc2lvbmVkTWVzc2FnZX0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7QWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudH0gZnJvbSAnLi9wcm9ncmFtcy9hZGRyZXNzLWxvb2t1cC10YWJsZS9zdGF0ZSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7c2xlZXB9IGZyb20gJy4vdXRpbHMvc2xlZXAnO1xuaW1wb3J0IHt0b0J1ZmZlcn0gZnJvbSAnLi91dGlscy90by1idWZmZXInO1xuaW1wb3J0IHtcbiAgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLFxuICBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcixcbiAgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLFxufSBmcm9tICcuL3RyYW5zYWN0aW9uL2V4cGlyeS1jdXN0b20tZXJyb3JzJztcbmltcG9ydCB7bWFrZVdlYnNvY2tldFVybH0gZnJvbSAnLi91dGlscy9tYWtlV2Vic29ja2V0VXJsJztcbmltcG9ydCB0eXBlIHtCbG9ja2hhc2h9IGZyb20gJy4vYmxvY2toYXNoJztcbmltcG9ydCB0eXBlIHtGZWVDYWxjdWxhdG9yfSBmcm9tICcuL2ZlZS1jYWxjdWxhdG9yJztcbmltcG9ydCB0eXBlIHtUcmFuc2FjdGlvblNpZ25hdHVyZX0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgdHlwZSB7Q29tcGlsZWRJbnN0cnVjdGlvbn0gZnJvbSAnLi9tZXNzYWdlJztcblxuY29uc3QgUHVibGljS2V5RnJvbVN0cmluZyA9IGNvZXJjZShcbiAgaW5zdGFuY2UoUHVibGljS2V5KSxcbiAgc3RyaW5nKCksXG4gIHZhbHVlID0+IG5ldyBQdWJsaWNLZXkodmFsdWUpLFxuKTtcblxuY29uc3QgUmF3QWNjb3VudERhdGFSZXN1bHQgPSB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSk7XG5cbmNvbnN0IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSA9IGNvZXJjZShcbiAgaW5zdGFuY2UoQnVmZmVyKSxcbiAgUmF3QWNjb3VudERhdGFSZXN1bHQsXG4gIHZhbHVlID0+IEJ1ZmZlci5mcm9tKHZhbHVlWzBdLCAnYmFzZTY0JyksXG4pO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gdXNlIGEgcmVjZW50IGJsb2NraGFzaCBmb3IgdXAgdG8gMzAgc2Vjb25kc1xuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyA9IDMwICogMTAwMDtcblxuLyoqXG4gKiBIQUNLLlxuICogQ29waWVkIGZyb20gcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50LlxuICogT3RoZXJ3aXNlLCBgeWFybiBidWlsZGAgZmFpbHMgd2l0aDpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9jMDU3ZWNhODFkNDc5ZWY3MDVjZGI1MzE2MmY5OTcxZFxuICovXG5pbnRlcmZhY2UgSVdTUmVxdWVzdFBhcmFtcyB7XG4gIFt4OiBzdHJpbmddOiBhbnk7XG4gIFt4OiBudW1iZXJdOiBhbnk7XG59XG5cbnR5cGUgQ2xpZW50U3Vic2NyaXB0aW9uSWQgPSBudW1iZXI7XG4vKiogQGludGVybmFsICovIHR5cGUgU2VydmVyU3Vic2NyaXB0aW9uSWQgPSBudW1iZXI7XG4vKiogQGludGVybmFsICovIHR5cGUgU3Vic2NyaXB0aW9uQ29uZmlnSGFzaCA9IHN0cmluZztcbi8qKiBAaW50ZXJuYWwgKi8gdHlwZSBTdWJzY3JpcHRpb25EaXNwb3NlRm4gPSAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuLyoqIEBpbnRlcm5hbCAqLyB0eXBlIFN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2sgPSAoXG4gIG5leHRTdGF0ZTogU3RhdGVmdWxTdWJzY3JpcHRpb25bJ3N0YXRlJ10sXG4pID0+IHZvaWQ7XG4vKiogQGludGVybmFsICovIHR5cGUgU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VEaXNwb3NlRm4gPSAoKSA9PiB2b2lkO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEV2ZXJ5IHN1YnNjcmlwdGlvbiBjb250YWlucyB0aGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoXG4gKiB0aGUgc2VydmVyLCBhbmQgYSBsaXN0IG9mIGNhbGxlcnMgaW50ZXJlc3RlZCBpbiBub3RpZmljYXRpb25zLlxuICovXG50eXBlIEJhc2VTdWJzY3JpcHRpb248VE1ldGhvZCA9IFN1YnNjcmlwdGlvbkNvbmZpZ1snbWV0aG9kJ10+ID0gUmVhZG9ubHk8e1xuICBhcmdzOiBJV1NSZXF1ZXN0UGFyYW1zO1xuICBjYWxsYmFja3M6IFNldDxFeHRyYWN0PFN1YnNjcmlwdGlvbkNvbmZpZywge21ldGhvZDogVE1ldGhvZH0+WydjYWxsYmFjayddPjtcbn0+O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEEgc3Vic2NyaXB0aW9uIG1heSBiZSBpbiB2YXJpb3VzIHN0YXRlcyBvZiBjb25uZWN0ZWRuZXNzLiBPbmx5IHdoZW4gaXQgaXNcbiAqIGZ1bGx5IGNvbm5lY3RlZCB3aWxsIGl0IGhhdmUgYSBzZXJ2ZXIgc3Vic2NyaXB0aW9uIGlkIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFRoaXMgaWQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBzZXJ2ZXIgdG8gdW5zdWJzY3JpYmUgdGhlIGNsaWVudCBlbnRpcmVseS5cbiAqL1xudHlwZSBTdGF0ZWZ1bFN1YnNjcmlwdGlvbiA9IFJlYWRvbmx5PFxuICAvLyBOZXcgc3Vic2NyaXB0aW9ucyB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gIC8vIHNlbnQgdG8gdGhlIHNlcnZlciBzdGFydCBpbiB0aGlzIHN0YXRlLlxuICB8IHtcbiAgICAgIHN0YXRlOiAncGVuZGluZyc7XG4gICAgfVxuICAvLyBUaGVzZSBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgLy8gYW5kIGFyZSB3YWl0aW5nIGZvciB0aGUgc2VydmVyIHRvIGFja25vd2xlZGdlIHRoZW0uXG4gIHwge1xuICAgICAgc3RhdGU6ICdzdWJzY3JpYmluZyc7XG4gICAgfVxuICAvLyBUaGVzZSBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgYnkgdGhlXG4gIC8vIHNlcnZlciBhbmQgaGF2ZSBiZWVuIGFzc2lnbmVkIHNlcnZlciBzdWJzY3JpcHRpb24gaWRzLlxuICB8IHtcbiAgICAgIHNlcnZlclN1YnNjcmlwdGlvbklkOiBTZXJ2ZXJTdWJzY3JpcHRpb25JZDtcbiAgICAgIHN0YXRlOiAnc3Vic2NyaWJlZCc7XG4gICAgfVxuICAvLyBUaGVzZSBzdWJzY3JpcHRpb25zIGFyZSBpbnRlbmRlZCB0byBiZSB0b3JuIGRvd24gYW5kXG4gIC8vIGFyZSB3YWl0aW5nIG9uIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXIuXG4gIHwge1xuICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQ6IFNlcnZlclN1YnNjcmlwdGlvbklkO1xuICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJztcbiAgICB9XG4gIC8vIFRoZSByZXF1ZXN0IHRvIHRlYXIgZG93biB0aGVzZSBzdWJzY3JpcHRpb25zIGhhcyBiZWVuXG4gIC8vIGFja25vd2xlZGdlZCBieSB0aGUgc2VydmVyLiBUaGUgYHNlcnZlclN1YnNjcmlwdGlvbklkYFxuICAvLyBpcyB0aGUgaWQgb2YgdGhlIG5vdy1kZWFkIHN1YnNjcmlwdGlvbi5cbiAgfCB7XG4gICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZDogU2VydmVyU3Vic2NyaXB0aW9uSWQ7XG4gICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJlZCc7XG4gICAgfVxuPjtcbi8qKlxuICogQSB0eXBlIHRoYXQgZW5jYXBzdWxhdGVzIGEgc3Vic2NyaXB0aW9uJ3MgUlBDIG1ldGhvZFxuICogbmFtZXMgYW5kIG5vdGlmaWNhdGlvbiAoY2FsbGJhY2spIHNpZ25hdHVyZS5cbiAqL1xudHlwZSBTdWJzY3JpcHRpb25Db25maWcgPSBSZWFkb25seTxcbiAgfCB7XG4gICAgICBjYWxsYmFjazogQWNjb3VudENoYW5nZUNhbGxiYWNrO1xuICAgICAgbWV0aG9kOiAnYWNjb3VudFN1YnNjcmliZSc7XG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2FjY291bnRVbnN1YnNjcmliZSc7XG4gICAgfVxuICB8IHtcbiAgICAgIGNhbGxiYWNrOiBMb2dzQ2FsbGJhY2s7XG4gICAgICBtZXRob2Q6ICdsb2dzU3Vic2NyaWJlJztcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnbG9nc1Vuc3Vic2NyaWJlJztcbiAgICB9XG4gIHwge1xuICAgICAgY2FsbGJhY2s6IFByb2dyYW1BY2NvdW50Q2hhbmdlQ2FsbGJhY2s7XG4gICAgICBtZXRob2Q6ICdwcm9ncmFtU3Vic2NyaWJlJztcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncHJvZ3JhbVVuc3Vic2NyaWJlJztcbiAgICB9XG4gIHwge1xuICAgICAgY2FsbGJhY2s6IFJvb3RDaGFuZ2VDYWxsYmFjaztcbiAgICAgIG1ldGhvZDogJ3Jvb3RTdWJzY3JpYmUnO1xuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdyb290VW5zdWJzY3JpYmUnO1xuICAgIH1cbiAgfCB7XG4gICAgICBjYWxsYmFjazogU2lnbmF0dXJlU3Vic2NyaXB0aW9uQ2FsbGJhY2s7XG4gICAgICBtZXRob2Q6ICdzaWduYXR1cmVTdWJzY3JpYmUnO1xuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSc7XG4gICAgfVxuICB8IHtcbiAgICAgIGNhbGxiYWNrOiBTbG90Q2hhbmdlQ2FsbGJhY2s7XG4gICAgICBtZXRob2Q6ICdzbG90U3Vic2NyaWJlJztcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2xvdFVuc3Vic2NyaWJlJztcbiAgICB9XG4gIHwge1xuICAgICAgY2FsbGJhY2s6IFNsb3RVcGRhdGVDYWxsYmFjaztcbiAgICAgIG1ldGhvZDogJ3Nsb3RzVXBkYXRlc1N1YnNjcmliZSc7XG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RzVXBkYXRlc1Vuc3Vic2NyaWJlJztcbiAgICB9XG4+O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFV0aWxpdHkgdHlwZSB0aGF0IGtlZXBzIHRhZ2dlZCB1bmlvbnMgaW50YWN0IHdoaWxlIG9taXR0aW5nIHByb3BlcnRpZXMuXG4gKi9cbnR5cGUgRGlzdHJpYnV0aXZlT21pdDxULCBLIGV4dGVuZHMgUHJvcGVydHlLZXk+ID0gVCBleHRlbmRzIHVua25vd25cbiAgPyBPbWl0PFQsIEs+XG4gIDogbmV2ZXI7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBzaW5nbGUgc3Vic2NyaWJhYmxlICd0b3BpYy4nIEl0J3MgbWFkZSB1cCBvZjpcbiAqXG4gKiAtIFRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIHNlcnZlcixcbiAqIC0gVGhlIHN0YXRlIG9mIHRoZSBzdWJzY3JpcHRpb24sIGluIHRlcm1zIG9mIGl0cyBjb25uZWN0ZWRuZXNzLCBhbmRcbiAqIC0gVGhlIHNldCBvZiBjYWxsYmFja3MgdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgcHVibGlzaGVzIG5vdGlmaWNhdGlvbnNcbiAqXG4gKiBUaGlzIHJlY29yZCBnZXRzIGluZGV4ZWQgYnkgYFN1YnNjcmlwdGlvbkNvbmZpZ0hhc2hgIGFuZCBpcyB1c2VkIHRvXG4gKiBzZXQgdXAgc3Vic2NyaXB0aW9ucywgZmFuIG91dCBub3RpZmljYXRpb25zLCBhbmQgdHJhY2sgc3Vic2NyaXB0aW9uIHN0YXRlLlxuICovXG50eXBlIFN1YnNjcmlwdGlvbiA9IEJhc2VTdWJzY3JpcHRpb24gJlxuICBTdGF0ZWZ1bFN1YnNjcmlwdGlvbiAmXG4gIERpc3RyaWJ1dGl2ZU9taXQ8U3Vic2NyaXB0aW9uQ29uZmlnLCAnY2FsbGJhY2snPjtcblxudHlwZSBScGNSZXF1ZXN0ID0gKG1ldGhvZE5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55PikgPT4gUHJvbWlzZTxhbnk+O1xuXG50eXBlIFJwY0JhdGNoUmVxdWVzdCA9IChyZXF1ZXN0czogUnBjUGFyYW1zW10pID0+IFByb21pc2U8YW55W10+O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBScGNQYXJhbXMgPSB7XG4gIG1ldGhvZE5hbWU6IHN0cmluZztcbiAgYXJnczogQXJyYXk8YW55Pjtcbn07XG5cbmV4cG9ydCB0eXBlIFRva2VuQWNjb3VudHNGaWx0ZXIgPVxuICB8IHtcbiAgICAgIG1pbnQ6IFB1YmxpY0tleTtcbiAgICB9XG4gIHwge1xuICAgICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXk7XG4gICAgfTtcblxuLyoqXG4gKiBFeHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGZvciBSUEMgcmVzcG9uc2VzXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRleHQgPSB7XG4gIHNsb3Q6IG51bWJlcjtcbn07XG5cbi8qKlxuICogT3B0aW9ucyBmb3Igc2VuZGluZyB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgU2VuZE9wdGlvbnMgPSB7XG4gIC8qKiBkaXNhYmxlIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBzdGVwICovXG4gIHNraXBQcmVmbGlnaHQ/OiBib29sZWFuO1xuICAvKiogcHJlZmxpZ2h0IGNvbW1pdG1lbnQgbGV2ZWwgKi9cbiAgcHJlZmxpZ2h0Q29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiB0aW1lcyBmb3IgdGhlIFJQQyBub2RlIHRvIHJldHJ5IHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBsZWFkZXIuICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIC8qKiBUaGUgbWluaW11bSBzbG90IHRoYXQgdGhlIHJlcXVlc3QgY2FuIGJlIGV2YWx1YXRlZCBhdCAqL1xuICBtaW5Db250ZXh0U2xvdD86IG51bWJlcjtcbn07XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgQ29uZmlybU9wdGlvbnMgPSB7XG4gIC8qKiBkaXNhYmxlIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBzdGVwICovXG4gIHNraXBQcmVmbGlnaHQ/OiBib29sZWFuO1xuICAvKiogZGVzaXJlZCBjb21taXRtZW50IGxldmVsICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogcHJlZmxpZ2h0IGNvbW1pdG1lbnQgbGV2ZWwgKi9cbiAgcHJlZmxpZ2h0Q29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiB0aW1lcyBmb3IgdGhlIFJQQyBub2RlIHRvIHJldHJ5IHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBsZWFkZXIuICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIC8qKiBUaGUgbWluaW11bSBzbG90IHRoYXQgdGhlIHJlcXVlc3QgY2FuIGJlIGV2YWx1YXRlZCBhdCAqL1xuICBtaW5Db250ZXh0U2xvdD86IG51bWJlcjtcbn07XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXG4gKi9cbmV4cG9ydCB0eXBlIENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMk9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBTdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzIGZyb20gdGhpcyB0cmFuc2FjdGlvbiBzaWduYXR1cmUuXG4gICAqIEByZW1hcmtzIElmIG5vdCBwcm92aWRlZCB0aGUgc2VhcmNoIHN0YXJ0cyBmcm9tIHRoZSBoaWdoZXN0IG1heCBjb25maXJtZWQgYmxvY2suXG4gICAqL1xuICBiZWZvcmU/OiBUcmFuc2FjdGlvblNpZ25hdHVyZTtcbiAgLyoqIFNlYXJjaCB1bnRpbCB0aGlzIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBpcyByZWFjaGVkLCBpZiBmb3VuZCBiZWZvcmUgYGxpbWl0YC4gKi9cbiAgdW50aWw/OiBUcmFuc2FjdGlvblNpZ25hdHVyZTtcbiAgLyoqIE1heGltdW0gdHJhbnNhY3Rpb24gc2lnbmF0dXJlcyB0byByZXR1cm4gKGJldHdlZW4gMSBhbmQgMSwwMDAsIGRlZmF1bHQ6IDEsMDAwKS4gKi9cbiAgbGltaXQ/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXG4gKi9cbmV4cG9ydCB0eXBlIFNpZ25hdHVyZXNGb3JBZGRyZXNzT3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIFN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMgZnJvbSB0aGlzIHRyYW5zYWN0aW9uIHNpZ25hdHVyZS5cbiAgICogQHJlbWFya3MgSWYgbm90IHByb3ZpZGVkIHRoZSBzZWFyY2ggc3RhcnRzIGZyb20gdGhlIGhpZ2hlc3QgbWF4IGNvbmZpcm1lZCBibG9jay5cbiAgICovXG4gIGJlZm9yZT86IFRyYW5zYWN0aW9uU2lnbmF0dXJlO1xuICAvKiogU2VhcmNoIHVudGlsIHRoaXMgdHJhbnNhY3Rpb24gc2lnbmF0dXJlIGlzIHJlYWNoZWQsIGlmIGZvdW5kIGJlZm9yZSBgbGltaXRgLiAqL1xuICB1bnRpbD86IFRyYW5zYWN0aW9uU2lnbmF0dXJlO1xuICAvKiogTWF4aW11bSB0cmFuc2FjdGlvbiBzaWduYXR1cmVzIHRvIHJldHVybiAoYmV0d2VlbiAxIGFuZCAxLDAwMCwgZGVmYXVsdDogMSwwMDApLiAqL1xuICBsaW1pdD86IG51bWJlcjtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBSUEMgUmVzcG9uc2Ugd2l0aCBleHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxUPiA9IHtcbiAgLyoqIHJlc3BvbnNlIGNvbnRleHQgKi9cbiAgY29udGV4dDogQ29udGV4dDtcbiAgLyoqIHJlc3BvbnNlIHZhbHVlICovXG4gIHZhbHVlOiBUO1xufTtcblxuZXhwb3J0IHR5cGUgQmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0ID0gUmVhZG9ubHk8e1xuICBibG9ja2hhc2g6IEJsb2NraGFzaDtcbiAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IG51bWJlcjtcbn0+O1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zIHRoYXQgdXNlcyB0aGUgbGFzdCB2YWxpZFxuICogYmxvY2sgaGVpZ2h0IGZvciBhIGdpdmVuIGJsb2NraGFzaCB0byBjaGVjayBmb3IgdHJhbnNhY3Rpb24gZXhwaXJhdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgQmxvY2toZWlnaHRCYXNlZFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3kgPVxuICBCYXNlVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneSAmIEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodDtcblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb25zLlxuICovXG5leHBvcnQgdHlwZSBEdXJhYmxlTm9uY2VUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5ID1cbiAgQmFzZVRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3kgJiB7XG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VzdCBzbG90IGF0IHdoaWNoIHRvIGZldGNoIHRoZSBub25jZSB2YWx1ZSBmcm9tIHRoZVxuICAgICAqIG5vbmNlIGFjY291bnQuIFRoaXMgc2hvdWxkIGJlIG5vIGxvd2VyIHRoYW4gdGhlIHNsb3QgYXRcbiAgICAgKiB3aGljaCB0aGUgbGFzdC1rbm93biB2YWx1ZSBvZiB0aGUgbm9uY2Ugd2FzIGZldGNoZWQuXG4gICAgICovXG4gICAgbWluQ29udGV4dFNsb3Q6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjb3VudCB3aGVyZSB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgbm9uY2UgaXMgc3RvcmVkLlxuICAgICAqL1xuICAgIG5vbmNlQWNjb3VudFB1YmtleTogUHVibGljS2V5O1xuICAgIC8qKlxuICAgICAqIFRoZSBub25jZSB2YWx1ZSB0aGF0IHdhcyB1c2VkIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogZm9yIHdoaWNoIGNvbmZpcm1hdGlvbiBpcyBiZWluZyBzb3VnaHQuXG4gICAgICovXG4gICAgbm9uY2VWYWx1ZTogRHVyYWJsZU5vbmNlO1xuICB9O1xuXG4vKipcbiAqIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5leHBvcnQgdHlwZSBCYXNlVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneSA9IFJlYWRvbmx5PHtcbiAgLyoqIEEgc2lnbmFsIHRoYXQsIHdoZW4gYWJvcnRlZCwgY2FuY2VscyBhbnkgb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIG9wZXJhdGlvbnMgKi9cbiAgYWJvcnRTaWduYWw/OiBBYm9ydFNpZ25hbDtcbiAgc2lnbmF0dXJlOiBUcmFuc2FjdGlvblNpZ25hdHVyZTtcbn0+O1xuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5leHBvcnQgdHlwZSBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5ID1cbiAgfCBCbG9ja2hlaWdodEJhc2VkVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneVxuICB8IER1cmFibGVOb25jZVRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3k7XG5cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gYXNzZXJ0RW5kcG9pbnRVcmwocHV0YXRpdmVVcmw6IHN0cmluZykge1xuICBpZiAoL15odHRwcz86Ly50ZXN0KHB1dGF0aXZlVXJsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmRwb2ludCBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJyk7XG4gIH1cbiAgcmV0dXJuIHB1dGF0aXZlVXJsO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWc8VENvbmZpZz4oXG4gIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCAoe2NvbW1pdG1lbnQ/OiBDb21taXRtZW50fSAmIFRDb25maWcpLFxuKSB7XG4gIGxldCBjb21taXRtZW50OiBDb21taXRtZW50IHwgdW5kZWZpbmVkO1xuICBsZXQgY29uZmlnOiBPbWl0PFRDb25maWcsICdjb21taXRtZW50Jz4gfCB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgY29tbWl0bWVudE9yQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbW1pdG1lbnQgPSBjb21taXRtZW50T3JDb25maWc7XG4gIH0gZWxzZSBpZiAoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQ6IHNwZWNpZmllZENvbW1pdG1lbnQsIC4uLnNwZWNpZmllZENvbmZpZ30gPVxuICAgICAgY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIGNvbW1pdG1lbnQgPSBzcGVjaWZpZWRDb21taXRtZW50O1xuICAgIGNvbmZpZyA9IHNwZWNpZmllZENvbmZpZztcbiAgfVxuICByZXR1cm4ge2NvbW1pdG1lbnQsIGNvbmZpZ307XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzKFxuICBmaWx0ZXJzOiBHZXRQcm9ncmFtQWNjb3VudHNGaWx0ZXJbXSxcbik6IEdldFByb2dyYW1BY2NvdW50c0ZpbHRlcltdIHtcbiAgcmV0dXJuIGZpbHRlcnMubWFwKGZpbHRlciA9PlxuICAgICdtZW1jbXAnIGluIGZpbHRlclxuICAgICAgPyB7XG4gICAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICAgIG1lbWNtcDoge1xuICAgICAgICAgICAgLi4uZmlsdGVyLm1lbWNtcCxcbiAgICAgICAgICAgIGVuY29kaW5nOiBmaWx0ZXIubWVtY21wLmVuY29kaW5nID8/ICdiYXNlNTgnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIDogZmlsdGVyLFxuICApO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjcmVhdGVScGNSZXN1bHQ8VCwgVT4ocmVzdWx0OiBTdHJ1Y3Q8VCwgVT4pIHtcbiAgcmV0dXJuIHVuaW9uKFtcbiAgICBwaWNrKHtcbiAgICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgICAgaWQ6IHN0cmluZygpLFxuICAgICAgcmVzdWx0LFxuICAgIH0pLFxuICAgIHBpY2soe1xuICAgICAganNvbnJwYzogbGl0ZXJhbCgnMi4wJyksXG4gICAgICBpZDogc3RyaW5nKCksXG4gICAgICBlcnJvcjogcGljayh7XG4gICAgICAgIGNvZGU6IHVua25vd24oKSxcbiAgICAgICAgbWVzc2FnZTogc3RyaW5nKCksXG4gICAgICAgIGRhdGE6IG9wdGlvbmFsKGFueSgpKSxcbiAgICAgIH0pLFxuICAgIH0pLFxuICBdKTtcbn1cblxuY29uc3QgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0PFQsIFU+KHNjaGVtYTogU3RydWN0PFQsIFU+KSB7XG4gIHJldHVybiBjb2VyY2UoY3JlYXRlUnBjUmVzdWx0KHNjaGVtYSksIFVua25vd25ScGNSZXN1bHQsIHZhbHVlID0+IHtcbiAgICBpZiAoJ2Vycm9yJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgcmVzdWx0OiBjcmVhdGUodmFsdWUucmVzdWx0LCBzY2hlbWEpLFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0QW5kQ29udGV4dDxULCBVPih2YWx1ZTogU3RydWN0PFQsIFU+KSB7XG4gIHJldHVybiBqc29uUnBjUmVzdWx0KFxuICAgIHBpY2soe1xuICAgICAgY29udGV4dDogcGljayh7XG4gICAgICAgIHNsb3Q6IG51bWJlcigpLFxuICAgICAgfSksXG4gICAgICB2YWx1ZSxcbiAgICB9KSxcbiAgKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dDxULCBVPih2YWx1ZTogU3RydWN0PFQsIFU+KSB7XG4gIHJldHVybiBwaWNrKHtcbiAgICBjb250ZXh0OiBwaWNrKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpLFxuICAgIH0pLFxuICAgIHZhbHVlLFxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShcbiAgdmVyc2lvbjogVHJhbnNhY3Rpb25WZXJzaW9uIHwgdW5kZWZpbmVkLFxuICByZXNwb25zZTogTWVzc2FnZVJlc3BvbnNlLFxuKTogVmVyc2lvbmVkTWVzc2FnZSB7XG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyOiByZXNwb25zZS5oZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogcmVzcG9uc2UuYWNjb3VudEtleXMubWFwKFxuICAgICAgICBhY2NvdW50S2V5ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudEtleSksXG4gICAgICApLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiByZXNwb25zZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogcmVzcG9uc2UuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSksXG4gICAgICB9KSksXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByZXNwb25zZS5hZGRyZXNzVGFibGVMb29rdXBzISxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UocmVzcG9uc2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCB3aGVuIHF1ZXJ5aW5nIHN0YXRlXG4gKiA8cHJlPlxuICogICAncHJvY2Vzc2VkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuZXhwb3J0IHR5cGUgQ29tbWl0bWVudCA9XG4gIHwgJ3Byb2Nlc3NlZCdcbiAgfCAnY29uZmlybWVkJ1xuICB8ICdmaW5hbGl6ZWQnXG4gIHwgJ3JlY2VudCcgLy8gRGVwcmVjYXRlZCBhcyBvZiB2MS41LjVcbiAgfCAnc2luZ2xlJyAvLyBEZXByZWNhdGVkIGFzIG9mIHYxLjUuNVxuICB8ICdzaW5nbGVHb3NzaXAnIC8vIERlcHJlY2F0ZWQgYXMgb2YgdjEuNS41XG4gIHwgJ3Jvb3QnIC8vIERlcHJlY2F0ZWQgYXMgb2YgdjEuNS41XG4gIHwgJ21heCc7IC8vIERlcHJlY2F0ZWQgYXMgb2YgdjEuNS41XG5cbi8qKlxuICogQSBzdWJzZXQgb2YgQ29tbWl0bWVudCBsZXZlbHMsIHdoaWNoIGFyZSBhdCBsZWFzdCBvcHRpbWlzdGljYWxseSBjb25maXJtZWRcbiAqIDxwcmU+XG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5leHBvcnQgdHlwZSBGaW5hbGl0eSA9ICdjb25maXJtZWQnIHwgJ2ZpbmFsaXplZCc7XG5cbi8qKlxuICogRmlsdGVyIGZvciBsYXJnZXN0IGFjY291bnRzIHF1ZXJ5XG4gKiA8cHJlPlxuICogICAnY2lyY3VsYXRpbmcnOiAgICBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiAgICdub25DaXJjdWxhdGluZyc6IFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiA8L3ByZT5cbiAqL1xuZXhwb3J0IHR5cGUgTGFyZ2VzdEFjY291bnRzRmlsdGVyID0gJ2NpcmN1bGF0aW5nJyB8ICdub25DaXJjdWxhdGluZyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRBY2NvdW50SW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0QWNjb3VudEluZm9Db25maWcgPSB7XG4gIC8qKiBUaGUgbGV2ZWwgb2YgY29tbWl0bWVudCBkZXNpcmVkICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogVGhlIG1pbmltdW0gc2xvdCB0aGF0IHRoZSByZXF1ZXN0IGNhbiBiZSBldmFsdWF0ZWQgYXQgKi9cbiAgbWluQ29udGV4dFNsb3Q/OiBudW1iZXI7XG4gIC8qKiBPcHRpb25hbCBkYXRhIHNsaWNlIHRvIGxpbWl0IHRoZSByZXR1cm5lZCBhY2NvdW50IGRhdGEgKi9cbiAgZGF0YVNsaWNlPzogRGF0YVNsaWNlO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJhbGFuY2VgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIEdldEJhbGFuY2VDb25maWcgPSB7XG4gIC8qKiBUaGUgbGV2ZWwgb2YgY29tbWl0bWVudCBkZXNpcmVkICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogVGhlIG1pbmltdW0gc2xvdCB0aGF0IHRoZSByZXF1ZXN0IGNhbiBiZSBldmFsdWF0ZWQgYXQgKi9cbiAgbWluQ29udGV4dFNsb3Q/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIEdldEJsb2NrQ29uZmlnID0ge1xuICAvKiogVGhlIGxldmVsIG9mIGZpbmFsaXR5IGRlc2lyZWQgKi9cbiAgY29tbWl0bWVudD86IEZpbmFsaXR5O1xuICAvKipcbiAgICogV2hldGhlciB0byBwb3B1bGF0ZSB0aGUgcmV3YXJkcyBhcnJheS4gSWYgcGFyYW1ldGVyIG5vdCBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaW5jbHVkZXMgcmV3YXJkcy5cbiAgICovXG4gIHJld2FyZHM/OiBib29sZWFuO1xuICAvKipcbiAgICogTGV2ZWwgb2YgdHJhbnNhY3Rpb24gZGV0YWlsIHRvIHJldHVybiwgZWl0aGVyIFwiZnVsbFwiLCBcImFjY291bnRzXCIsIFwic2lnbmF0dXJlc1wiLCBvciBcIm5vbmVcIi4gSWZcbiAgICogcGFyYW1ldGVyIG5vdCBwcm92aWRlZCwgdGhlIGRlZmF1bHQgZGV0YWlsIGxldmVsIGlzIFwiZnVsbFwiLiBJZiBcImFjY291bnRzXCIgYXJlIHJlcXVlc3RlZCxcbiAgICogdHJhbnNhY3Rpb24gZGV0YWlscyBvbmx5IGluY2x1ZGUgc2lnbmF0dXJlcyBhbmQgYW4gYW5ub3RhdGVkIGxpc3Qgb2YgYWNjb3VudHMgaW4gZWFjaFxuICAgKiB0cmFuc2FjdGlvbi4gVHJhbnNhY3Rpb24gbWV0YWRhdGEgaXMgbGltaXRlZCB0byBvbmx5OiBmZWUsIGVyciwgcHJlX2JhbGFuY2VzLCBwb3N0X2JhbGFuY2VzLFxuICAgKiBwcmVfdG9rZW5fYmFsYW5jZXMsIGFuZCBwb3N0X3Rva2VuX2JhbGFuY2VzLlxuICAgKi9cbiAgdHJhbnNhY3Rpb25EZXRhaWxzPzogJ2FjY291bnRzJyB8ICdmdWxsJyB8ICdub25lJyB8ICdzaWduYXR1cmVzJztcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0VmVyc2lvbmVkQmxvY2tDb25maWcgPSB7XG4gIC8qKiBUaGUgbGV2ZWwgb2YgZmluYWxpdHkgZGVzaXJlZCAqL1xuICBjb21taXRtZW50PzogRmluYWxpdHk7XG4gIC8qKiBUaGUgbWF4IHRyYW5zYWN0aW9uIHZlcnNpb24gdG8gcmV0dXJuIGluIHJlc3BvbnNlcy4gSWYgdGhlIHJlcXVlc3RlZCB0cmFuc2FjdGlvbiBpcyBhIGhpZ2hlciB2ZXJzaW9uLCBhbiBlcnJvciB3aWxsIGJlIHJldHVybmVkICovXG4gIG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbj86IG51bWJlcjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcG9wdWxhdGUgdGhlIHJld2FyZHMgYXJyYXkuIElmIHBhcmFtZXRlciBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGluY2x1ZGVzIHJld2FyZHMuXG4gICAqL1xuICByZXdhcmRzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIExldmVsIG9mIHRyYW5zYWN0aW9uIGRldGFpbCB0byByZXR1cm4sIGVpdGhlciBcImZ1bGxcIiwgXCJhY2NvdW50c1wiLCBcInNpZ25hdHVyZXNcIiwgb3IgXCJub25lXCIuIElmXG4gICAqIHBhcmFtZXRlciBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGRldGFpbCBsZXZlbCBpcyBcImZ1bGxcIi4gSWYgXCJhY2NvdW50c1wiIGFyZSByZXF1ZXN0ZWQsXG4gICAqIHRyYW5zYWN0aW9uIGRldGFpbHMgb25seSBpbmNsdWRlIHNpZ25hdHVyZXMgYW5kIGFuIGFubm90YXRlZCBsaXN0IG9mIGFjY291bnRzIGluIGVhY2hcbiAgICogdHJhbnNhY3Rpb24uIFRyYW5zYWN0aW9uIG1ldGFkYXRhIGlzIGxpbWl0ZWQgdG8gb25seTogZmVlLCBlcnIsIHByZV9iYWxhbmNlcywgcG9zdF9iYWxhbmNlcyxcbiAgICogcHJlX3Rva2VuX2JhbGFuY2VzLCBhbmQgcG9zdF90b2tlbl9iYWxhbmNlcy5cbiAgICovXG4gIHRyYW5zYWN0aW9uRGV0YWlscz86ICdhY2NvdW50cycgfCAnZnVsbCcgfCAnbm9uZScgfCAnc2lnbmF0dXJlcyc7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbkNvbmZpZyA9IHtcbiAgLyoqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgKi9cbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tIZWlnaHRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIEdldEJsb2NrSGVpZ2h0Q29uZmlnID0ge1xuICAvKiogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEVwb2NoSW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0RXBvY2hJbmZvQ29uZmlnID0ge1xuICAvKiogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEluZmxhdGlvblJld2FyZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0SW5mbGF0aW9uUmV3YXJkQ29uZmlnID0ge1xuICAvKiogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIEFuIGVwb2NoIGZvciB3aGljaCB0aGUgcmV3YXJkIG9jY3Vycy4gSWYgb21pdHRlZCwgdGhlIHByZXZpb3VzIGVwb2NoIHdpbGwgYmUgdXNlZCAqL1xuICBlcG9jaD86IG51bWJlcjtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhdGVzdEJsb2NraGFzaGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0TGF0ZXN0QmxvY2toYXNoQ29uZmlnID0ge1xuICAvKiogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGlzQmxvY2toYXNoVmFsaWRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIElzQmxvY2toYXNoVmFsaWRDb25maWcgPSB7XG4gIC8qKiBUaGUgbGV2ZWwgb2YgY29tbWl0bWVudCBkZXNpcmVkICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogVGhlIG1pbmltdW0gc2xvdCB0aGF0IHRoZSByZXF1ZXN0IGNhbiBiZSBldmFsdWF0ZWQgYXQgKi9cbiAgbWluQ29udGV4dFNsb3Q/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0U2xvdENvbmZpZyA9IHtcbiAgLyoqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgKi9cbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKiBUaGUgbWluaW11bSBzbG90IHRoYXQgdGhlIHJlcXVlc3QgY2FuIGJlIGV2YWx1YXRlZCBhdCAqL1xuICBtaW5Db250ZXh0U2xvdD86IG51bWJlcjtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90TGVhZGVyYCBxdWVyeSBiZWhhdmlvclxuICovXG5leHBvcnQgdHlwZSBHZXRTbG90TGVhZGVyQ29uZmlnID0ge1xuICAvKiogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5leHBvcnQgdHlwZSBHZXRUcmFuc2FjdGlvbkNvbmZpZyA9IHtcbiAgLyoqIFRoZSBsZXZlbCBvZiBmaW5hbGl0eSBkZXNpcmVkICovXG4gIGNvbW1pdG1lbnQ/OiBGaW5hbGl0eTtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHR5cGUgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWcgPSB7XG4gIC8qKiBUaGUgbGV2ZWwgb2YgZmluYWxpdHkgZGVzaXJlZCAqL1xuICBjb21taXRtZW50PzogRmluYWxpdHk7XG4gIC8qKiBUaGUgbWF4IHRyYW5zYWN0aW9uIHZlcnNpb24gdG8gcmV0dXJuIGluIHJlc3BvbnNlcy4gSWYgdGhlIHJlcXVlc3RlZCB0cmFuc2FjdGlvbiBpcyBhIGhpZ2hlciB2ZXJzaW9uLCBhbiBlcnJvciB3aWxsIGJlIHJldHVybmVkICovXG4gIG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbj86IG51bWJlcjtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXJnZXN0QWNjb3VudHNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIEdldExhcmdlc3RBY2NvdW50c0NvbmZpZyA9IHtcbiAgLyoqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgKi9cbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKiBGaWx0ZXIgbGFyZ2VzdCBhY2NvdW50cyBieSB3aGV0aGVyIHRoZXkgYXJlIHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseSAqL1xuICBmaWx0ZXI/OiBMYXJnZXN0QWNjb3VudHNGaWx0ZXI7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3VwcGx5YCByZXF1ZXN0IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIEdldFN1cHBseUNvbmZpZyA9IHtcbiAgLyoqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgKi9cbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKiBFeGNsdWRlIG5vbiBjaXJjdWxhdGluZyBhY2NvdW50cyBsaXN0IGZyb20gcmVzcG9uc2UgKi9cbiAgZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0PzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIFNpZ25hdHVyZVN0YXR1c0NvbmZpZyA9IHtcbiAgLyoqIGVuYWJsZSBzZWFyY2hpbmcgc3RhdHVzIGhpc3RvcnksIG5vdCBuZWVkZWQgZm9yIHJlY2VudCB0cmFuc2FjdGlvbnMgKi9cbiAgc2VhcmNoVHJhbnNhY3Rpb25IaXN0b3J5OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgY2x1c3RlciBub2RlXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRhY3RJbmZvID0ge1xuICAvKiogSWRlbnRpdHkgcHVibGljIGtleSBvZiB0aGUgbm9kZSAqL1xuICBwdWJrZXk6IHN0cmluZztcbiAgLyoqIEdvc3NpcCBuZXR3b3JrIGFkZHJlc3MgZm9yIHRoZSBub2RlICovXG4gIGdvc3NpcDogc3RyaW5nIHwgbnVsbDtcbiAgLyoqIFRQVSBuZXR3b3JrIGFkZHJlc3MgZm9yIHRoZSBub2RlIChudWxsIGlmIG5vdCBhdmFpbGFibGUpICovXG4gIHRwdTogc3RyaW5nIHwgbnVsbDtcbiAgLyoqIEpTT04gUlBDIG5ldHdvcmsgYWRkcmVzcyBmb3IgdGhlIG5vZGUgKG51bGwgaWYgbm90IGF2YWlsYWJsZSkgKi9cbiAgcnBjOiBzdHJpbmcgfCBudWxsO1xuICAvKiogU29mdHdhcmUgdmVyc2lvbiBvZiB0aGUgbm9kZSAobnVsbCBpZiBub3QgYXZhaWxhYmxlKSAqL1xuICB2ZXJzaW9uOiBzdHJpbmcgfCBudWxsO1xufTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgdm90ZSBhY2NvdW50XG4gKi9cbmV4cG9ydCB0eXBlIFZvdGVBY2NvdW50SW5mbyA9IHtcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIHZvdGUgYWNjb3VudCAqL1xuICB2b3RlUHVia2V5OiBzdHJpbmc7XG4gIC8qKiBJZGVudGl0eSBwdWJsaWMga2V5IG9mIHRoZSBub2RlIHZvdGluZyB3aXRoIHRoaXMgYWNjb3VudCAqL1xuICBub2RlUHVia2V5OiBzdHJpbmc7XG4gIC8qKiBUaGUgc3Rha2UsIGluIGxhbXBvcnRzLCBkZWxlZ2F0ZWQgdG8gdGhpcyB2b3RlIGFjY291bnQgYW5kIGFjdGl2YXRlZCAqL1xuICBhY3RpdmF0ZWRTdGFrZTogbnVtYmVyO1xuICAvKiogV2hldGhlciB0aGUgdm90ZSBhY2NvdW50IGlzIHN0YWtlZCBmb3IgdGhpcyBlcG9jaCAqL1xuICBlcG9jaFZvdGVBY2NvdW50OiBib29sZWFuO1xuICAvKiogUmVjZW50IGVwb2NoIHZvdGluZyBjcmVkaXQgaGlzdG9yeSBmb3IgdGhpcyB2b3RlciAqL1xuICBlcG9jaENyZWRpdHM6IEFycmF5PFtudW1iZXIsIG51bWJlciwgbnVtYmVyXT47XG4gIC8qKiBBIHBlcmNlbnRhZ2UgKDAtMTAwKSBvZiByZXdhcmRzIHBheW91dCBvd2VkIHRvIHRoZSB2b3RlciAqL1xuICBjb21taXNzaW9uOiBudW1iZXI7XG4gIC8qKiBNb3N0IHJlY2VudCBzbG90IHZvdGVkIG9uIGJ5IHRoaXMgdm90ZSBhY2NvdW50ICovXG4gIGxhc3RWb3RlOiBudW1iZXI7XG59O1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjbHVzdGVyIHZvdGUgYWNjb3VudHNcbiAqL1xuZXhwb3J0IHR5cGUgVm90ZUFjY291bnRTdGF0dXMgPSB7XG4gIC8qKiBBY3RpdmUgdm90ZSBhY2NvdW50cyAqL1xuICBjdXJyZW50OiBBcnJheTxWb3RlQWNjb3VudEluZm8+O1xuICAvKiogSW5hY3RpdmUgdm90ZSBhY2NvdW50cyAqL1xuICBkZWxpbnF1ZW50OiBBcnJheTxWb3RlQWNjb3VudEluZm8+O1xufTtcblxuLyoqXG4gKiBOZXR3b3JrIEluZmxhdGlvblxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9pbXBsZW1lbnRlZC1wcm9wb3NhbHMvZWRfb3ZlcnZpZXcpXG4gKi9cbmV4cG9ydCB0eXBlIEluZmxhdGlvbkdvdmVybm9yID0ge1xuICBmb3VuZGF0aW9uOiBudW1iZXI7XG4gIGZvdW5kYXRpb25UZXJtOiBudW1iZXI7XG4gIGluaXRpYWw6IG51bWJlcjtcbiAgdGFwZXI6IG51bWJlcjtcbiAgdGVybWluYWw6IG51bWJlcjtcbn07XG5cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0ID0gcGljayh7XG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBmb3VuZGF0aW9uVGVybTogbnVtYmVyKCksXG4gIGluaXRpYWw6IG51bWJlcigpLFxuICB0YXBlcjogbnVtYmVyKCksXG4gIHRlcm1pbmFsOiBudW1iZXIoKSxcbn0pO1xuXG4vKipcbiAqIFRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhbiBlcG9jaFxuICovXG5leHBvcnQgdHlwZSBJbmZsYXRpb25SZXdhcmQgPSB7XG4gIC8qKiBlcG9jaCBmb3Igd2hpY2ggdGhlIHJld2FyZCBvY2N1cnMgKi9cbiAgZXBvY2g6IG51bWJlcjtcbiAgLyoqIHRoZSBzbG90IGluIHdoaWNoIHRoZSByZXdhcmRzIGFyZSBlZmZlY3RpdmUgKi9cbiAgZWZmZWN0aXZlU2xvdDogbnVtYmVyO1xuICAvKiogcmV3YXJkIGFtb3VudCBpbiBsYW1wb3J0cyAqL1xuICBhbW91bnQ6IG51bWJlcjtcbiAgLyoqIHBvc3QgYmFsYW5jZSBvZiB0aGUgYWNjb3VudCBpbiBsYW1wb3J0cyAqL1xuICBwb3N0QmFsYW5jZTogbnVtYmVyO1xuICAvKiogdm90ZSBhY2NvdW50IGNvbW1pc3Npb24gd2hlbiB0aGUgcmV3YXJkIHdhcyBjcmVkaXRlZCAqL1xuICBjb21taXNzaW9uPzogbnVtYmVyIHwgbnVsbDtcbn07XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJld2FyZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0ID0ganNvblJwY1Jlc3VsdChcbiAgYXJyYXkoXG4gICAgbnVsbGFibGUoXG4gICAgICBwaWNrKHtcbiAgICAgICAgZXBvY2g6IG51bWJlcigpLFxuICAgICAgICBlZmZlY3RpdmVTbG90OiBudW1iZXIoKSxcbiAgICAgICAgYW1vdW50OiBudW1iZXIoKSxcbiAgICAgICAgcG9zdEJhbGFuY2U6IG51bWJlcigpLFxuICAgICAgICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICAgICAgfSksXG4gICAgKSxcbiAgKSxcbik7XG5cbmV4cG9ydCB0eXBlIFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyA9IHtcbiAgLyoqIHNsb3QgaW4gd2hpY2ggdGhlIGZlZSB3YXMgb2JzZXJ2ZWQgKi9cbiAgc2xvdDogbnVtYmVyO1xuICAvKiogdGhlIHBlci1jb21wdXRlLXVuaXQgZmVlIHBhaWQgYnkgYXQgbGVhc3Qgb25lIHN1Y2Nlc3NmdWxseSBsYW5kZWQgdHJhbnNhY3Rpb24sIHNwZWNpZmllZCBpbiBpbmNyZW1lbnRzIG9mIDAuMDAwMDAxIGxhbXBvcnRzKi9cbiAgcHJpb3JpdGl6YXRpb25GZWU6IG51bWJlcjtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCB0eXBlIEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc0NvbmZpZyA9IHtcbiAgLyoqXG4gICAqIElmIHRoaXMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgcmVzcG9uc2Ugd2lsbCByZWZsZWN0IGEgZmVlIHRvIGxhbmQgYSB0cmFuc2FjdGlvbiBsb2NraW5nXG4gICAqIGFsbCBvZiB0aGUgcHJvdmlkZWQgYWNjb3VudHMgYXMgd3JpdGFibGUuXG4gICAqL1xuICBsb2NrZWRXcml0YWJsZUFjY291bnRzPzogUHVibGljS2V5W107XG59O1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCA9IGFycmF5KFxuICBwaWNrKHtcbiAgICBzbG90OiBudW1iZXIoKSxcbiAgICBwcmlvcml0aXphdGlvbkZlZTogbnVtYmVyKCksXG4gIH0pLFxuKTtcblxuZXhwb3J0IHR5cGUgSW5mbGF0aW9uUmF0ZSA9IHtcbiAgLyoqIHRvdGFsIGluZmxhdGlvbiAqL1xuICB0b3RhbDogbnVtYmVyO1xuICAvKiogaW5mbGF0aW9uIGFsbG9jYXRlZCB0byB2YWxpZGF0b3JzICovXG4gIHZhbGlkYXRvcjogbnVtYmVyO1xuICAvKiogaW5mbGF0aW9uIGFsbG9jYXRlZCB0byB0aGUgZm91bmRhdGlvbiAqL1xuICBmb3VuZGF0aW9uOiBudW1iZXI7XG4gIC8qKiBlcG9jaCBmb3Igd2hpY2ggdGhlc2UgdmFsdWVzIGFyZSB2YWxpZCAqL1xuICBlcG9jaDogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCA9IHBpY2soe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIHZhbGlkYXRvcjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBlcG9jaDogbnVtYmVyKCksXG59KTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlcG9jaFxuICovXG5leHBvcnQgdHlwZSBFcG9jaEluZm8gPSB7XG4gIGVwb2NoOiBudW1iZXI7XG4gIHNsb3RJbmRleDogbnVtYmVyO1xuICBzbG90c0luRXBvY2g6IG51bWJlcjtcbiAgYWJzb2x1dGVTbG90OiBudW1iZXI7XG4gIGJsb2NrSGVpZ2h0PzogbnVtYmVyO1xuICB0cmFuc2FjdGlvbkNvdW50PzogbnVtYmVyO1xufTtcblxuY29uc3QgR2V0RXBvY2hJbmZvUmVzdWx0ID0gcGljayh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgc2xvdEluZGV4OiBudW1iZXIoKSxcbiAgc2xvdHNJbkVwb2NoOiBudW1iZXIoKSxcbiAgYWJzb2x1dGVTbG90OiBudW1iZXIoKSxcbiAgYmxvY2tIZWlnaHQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogb3B0aW9uYWwobnVtYmVyKCkpLFxufSk7XG5cbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVSZXN1bHQgPSBwaWNrKHtcbiAgc2xvdHNQZXJFcG9jaDogbnVtYmVyKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogbnVtYmVyKCksXG4gIHdhcm11cDogYm9vbGVhbigpLFxuICBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXIoKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBudW1iZXIoKSxcbn0pO1xuXG4vKipcbiAqIExlYWRlciBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNsZWFkZXItc2NoZWR1bGUpXG4gKi9cbmV4cG9ydCB0eXBlIExlYWRlclNjaGVkdWxlID0ge1xuICBbYWRkcmVzczogc3RyaW5nXTogbnVtYmVyW107XG59O1xuXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCA9IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvciBvciBudWxsXG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQgPSBudWxsYWJsZSh1bmlvbihbcGljayh7fSksIHN0cmluZygpXSkpO1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgZm9yIGEgdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzdWx0ID0gcGljayh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbn0pO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSByZWNlaXZlZCBub3RpZmljYXRpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHQgPSBsaXRlcmFsKCdyZWNlaXZlZFNpZ25hdHVyZScpO1xuXG4vKipcbiAqIFZlcnNpb24gaW5mbyBmb3IgYSBub2RlXG4gKi9cbmV4cG9ydCB0eXBlIFZlcnNpb24gPSB7XG4gIC8qKiBWZXJzaW9uIG9mIHNvbGFuYS1jb3JlICovXG4gICdzb2xhbmEtY29yZSc6IHN0cmluZztcbiAgJ2ZlYXR1cmUtc2V0Jz86IG51bWJlcjtcbn07XG5cbmNvbnN0IFZlcnNpb25SZXN1bHQgPSBwaWNrKHtcbiAgJ3NvbGFuYS1jb3JlJzogc3RyaW5nKCksXG4gICdmZWF0dXJlLXNldCc6IG9wdGlvbmFsKG51bWJlcigpKSxcbn0pO1xuXG5leHBvcnQgdHlwZSBTaW11bGF0ZWRUcmFuc2FjdGlvbkFjY291bnRJbmZvID0ge1xuICAvKiogYHRydWVgIGlmIHRoaXMgYWNjb3VudCdzIGRhdGEgY29udGFpbnMgYSBsb2FkZWQgcHJvZ3JhbSAqL1xuICBleGVjdXRhYmxlOiBib29sZWFuO1xuICAvKiogSWRlbnRpZmllciBvZiB0aGUgcHJvZ3JhbSB0aGF0IG93bnMgdGhlIGFjY291bnQgKi9cbiAgb3duZXI6IHN0cmluZztcbiAgLyoqIE51bWJlciBvZiBsYW1wb3J0cyBhc3NpZ25lZCB0byB0aGUgYWNjb3VudCAqL1xuICBsYW1wb3J0czogbnVtYmVyO1xuICAvKiogT3B0aW9uYWwgZGF0YSBhc3NpZ25lZCB0byB0aGUgYWNjb3VudCAqL1xuICBkYXRhOiBzdHJpbmdbXTtcbiAgLyoqIE9wdGlvbmFsIHJlbnQgZXBvY2ggaW5mbyBmb3IgYWNjb3VudCAqL1xuICByZW50RXBvY2g/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBUcmFuc2FjdGlvblJldHVybkRhdGFFbmNvZGluZyA9ICdiYXNlNjQnO1xuXG5leHBvcnQgdHlwZSBUcmFuc2FjdGlvblJldHVybkRhdGEgPSB7XG4gIHByb2dyYW1JZDogc3RyaW5nO1xuICBkYXRhOiBbc3RyaW5nLCBUcmFuc2FjdGlvblJldHVybkRhdGFFbmNvZGluZ107XG59O1xuXG5leHBvcnQgdHlwZSBTaW11bGF0ZVRyYW5zYWN0aW9uQ29uZmlnID0ge1xuICAvKiogT3B0aW9uYWwgcGFyYW1ldGVyIHVzZWQgdG8gZW5hYmxlIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gYmVmb3JlIHNpbXVsYXRpb24gKi9cbiAgc2lnVmVyaWZ5PzogYm9vbGVhbjtcbiAgLyoqIE9wdGlvbmFsIHBhcmFtZXRlciB1c2VkIHRvIHJlcGxhY2UgdGhlIHNpbXVsYXRlZCB0cmFuc2FjdGlvbidzIHJlY2VudCBibG9ja2hhc2ggd2l0aCB0aGUgbGF0ZXN0IGJsb2NraGFzaCAqL1xuICByZXBsYWNlUmVjZW50QmxvY2toYXNoPzogYm9vbGVhbjtcbiAgLyoqIE9wdGlvbmFsIHBhcmFtZXRlciB1c2VkIHRvIHNldCB0aGUgY29tbWl0bWVudCBsZXZlbCB3aGVuIHNlbGVjdGluZyB0aGUgbGF0ZXN0IGJsb2NrICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogT3B0aW9uYWwgcGFyYW1ldGVyIHVzZWQgdG8gc3BlY2lmeSBhIGxpc3Qgb2YgYmFzZTU4LWVuY29kZWQgYWNjb3VudCBhZGRyZXNzZXMgdG8gcmV0dXJuIHBvc3Qgc2ltdWxhdGlvbiBzdGF0ZSBmb3IgKi9cbiAgYWNjb3VudHM/OiB7XG4gICAgLyoqIFRoZSBlbmNvZGluZyBvZiB0aGUgcmV0dXJuZWQgYWNjb3VudCdzIGRhdGEgKi9cbiAgICBlbmNvZGluZzogJ2Jhc2U2NCc7XG4gICAgYWRkcmVzc2VzOiBzdHJpbmdbXTtcbiAgfTtcbiAgLyoqIE9wdGlvbmFsIHBhcmFtZXRlciB1c2VkIHRvIHNwZWNpZnkgdGhlIG1pbmltdW0gYmxvY2sgc2xvdCB0aGF0IGNhbiBiZSB1c2VkIGZvciBzaW11bGF0aW9uICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xuICAvKiogT3B0aW9uYWwgcGFyYW1ldGVyIHVzZWQgdG8gaW5jbHVkZSBpbm5lciBpbnN0cnVjdGlvbnMgaW4gdGhlIHNpbXVsYXRpb24gKi9cbiAgaW5uZXJJbnN0cnVjdGlvbnM/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZSA9IHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yIHwgc3RyaW5nIHwgbnVsbDtcbiAgbG9nczogQXJyYXk8c3RyaW5nPiB8IG51bGw7XG4gIGFjY291bnRzPzogKFNpbXVsYXRlZFRyYW5zYWN0aW9uQWNjb3VudEluZm8gfCBudWxsKVtdIHwgbnVsbDtcbiAgdW5pdHNDb25zdW1lZD86IG51bWJlcjtcbiAgcmV0dXJuRGF0YT86IFRyYW5zYWN0aW9uUmV0dXJuRGF0YSB8IG51bGw7XG4gIGlubmVySW5zdHJ1Y3Rpb25zPzogUGFyc2VkSW5uZXJJbnN0cnVjdGlvbltdIHwgbnVsbDtcbn07XG5jb25zdCBQYXJzZWRJbnN0cnVjdGlvblN0cnVjdCA9IHBpY2soe1xuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBwYXJzZWQ6IHVua25vd24oKSxcbn0pO1xuXG5jb25zdCBQYXJ0aWFsbHlEZWNvZGVkSW5zdHJ1Y3Rpb25TdHJ1Y3QgPSBwaWNrKHtcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZyksXG4gIGRhdGE6IHN0cmluZygpLFxufSk7XG5cbmNvbnN0IFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChcbiAgcGljayh7XG4gICAgZXJyOiBudWxsYWJsZSh1bmlvbihbcGljayh7fSksIHN0cmluZygpXSkpLFxuICAgIGxvZ3M6IG51bGxhYmxlKGFycmF5KHN0cmluZygpKSksXG4gICAgYWNjb3VudHM6IG9wdGlvbmFsKFxuICAgICAgbnVsbGFibGUoXG4gICAgICAgIGFycmF5KFxuICAgICAgICAgIG51bGxhYmxlKFxuICAgICAgICAgICAgcGljayh7XG4gICAgICAgICAgICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICAgICAgICAgICAgb3duZXI6IHN0cmluZygpLFxuICAgICAgICAgICAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgICAgICAgICAgIGRhdGE6IGFycmF5KHN0cmluZygpKSxcbiAgICAgICAgICAgICAgcmVudEVwb2NoOiBvcHRpb25hbChudW1iZXIoKSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICApLFxuICAgIHVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgICByZXR1cm5EYXRhOiBvcHRpb25hbChcbiAgICAgIG51bGxhYmxlKFxuICAgICAgICBwaWNrKHtcbiAgICAgICAgICBwcm9ncmFtSWQ6IHN0cmluZygpLFxuICAgICAgICAgIGRhdGE6IHR1cGxlKFtzdHJpbmcoKSwgbGl0ZXJhbCgnYmFzZTY0JyldKSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICksXG4gICAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKFxuICAgICAgbnVsbGFibGUoXG4gICAgICAgIGFycmF5KFxuICAgICAgICAgIHBpY2soe1xuICAgICAgICAgICAgaW5kZXg6IG51bWJlcigpLFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShcbiAgICAgICAgICAgICAgdW5pb24oW1xuICAgICAgICAgICAgICAgIFBhcnNlZEluc3RydWN0aW9uU3RydWN0LFxuICAgICAgICAgICAgICAgIFBhcnRpYWxseURlY29kZWRJbnN0cnVjdGlvblN0cnVjdCxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICApLFxuICB9KSxcbik7XG5cbmV4cG9ydCB0eXBlIFBhcnNlZElubmVySW5zdHJ1Y3Rpb24gPSB7XG4gIGluZGV4OiBudW1iZXI7XG4gIGluc3RydWN0aW9uczogKFBhcnNlZEluc3RydWN0aW9uIHwgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uKVtdO1xufTtcblxuZXhwb3J0IHR5cGUgVG9rZW5CYWxhbmNlID0ge1xuICBhY2NvdW50SW5kZXg6IG51bWJlcjtcbiAgbWludDogc3RyaW5nO1xuICBvd25lcj86IHN0cmluZztcbiAgdWlUb2tlbkFtb3VudDogVG9rZW5BbW91bnQ7XG59O1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25NZXRhfSBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGEgPSBQYXJzZWRUcmFuc2FjdGlvbk1ldGE7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBhZGRyZXNzZXMgbG9hZGVkIGJ5IGEgdHJhbnNhY3Rpb24gdXNpbmcgYWRkcmVzcyB0YWJsZSBsb29rdXBzXG4gKi9cbmV4cG9ydCB0eXBlIExvYWRlZEFkZHJlc3NlcyA9IHtcbiAgd3JpdGFibGU6IEFycmF5PFB1YmxpY0tleT47XG4gIHJlYWRvbmx5OiBBcnJheTxQdWJsaWNLZXk+O1xufTtcblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRUcmFuc2FjdGlvbk1ldGEgPSB7XG4gIC8qKiBUaGUgZmVlIGNoYXJnZWQgZm9yIHByb2Nlc3NpbmcgdGhlIHRyYW5zYWN0aW9uICovXG4gIGZlZTogbnVtYmVyO1xuICAvKiogQW4gYXJyYXkgb2YgY3Jvc3MgcHJvZ3JhbSBpbnZva2VkIHBhcnNlZCBpbnN0cnVjdGlvbnMgKi9cbiAgaW5uZXJJbnN0cnVjdGlvbnM/OiBQYXJzZWRJbm5lckluc3RydWN0aW9uW10gfCBudWxsO1xuICAvKiogVGhlIGJhbGFuY2VzIG9mIHRoZSB0cmFuc2FjdGlvbiBhY2NvdW50cyBiZWZvcmUgcHJvY2Vzc2luZyAqL1xuICBwcmVCYWxhbmNlczogQXJyYXk8bnVtYmVyPjtcbiAgLyoqIFRoZSBiYWxhbmNlcyBvZiB0aGUgdHJhbnNhY3Rpb24gYWNjb3VudHMgYWZ0ZXIgcHJvY2Vzc2luZyAqL1xuICBwb3N0QmFsYW5jZXM6IEFycmF5PG51bWJlcj47XG4gIC8qKiBBbiBhcnJheSBvZiBwcm9ncmFtIGxvZyBtZXNzYWdlcyBlbWl0dGVkIGR1cmluZyBhIHRyYW5zYWN0aW9uICovXG4gIGxvZ01lc3NhZ2VzPzogQXJyYXk8c3RyaW5nPiB8IG51bGw7XG4gIC8qKiBUaGUgdG9rZW4gYmFsYW5jZXMgb2YgdGhlIHRyYW5zYWN0aW9uIGFjY291bnRzIGJlZm9yZSBwcm9jZXNzaW5nICovXG4gIHByZVRva2VuQmFsYW5jZXM/OiBBcnJheTxUb2tlbkJhbGFuY2U+IHwgbnVsbDtcbiAgLyoqIFRoZSB0b2tlbiBiYWxhbmNlcyBvZiB0aGUgdHJhbnNhY3Rpb24gYWNjb3VudHMgYWZ0ZXIgcHJvY2Vzc2luZyAqL1xuICBwb3N0VG9rZW5CYWxhbmNlcz86IEFycmF5PFRva2VuQmFsYW5jZT4gfCBudWxsO1xuICAvKiogVGhlIGVycm9yIHJlc3VsdCBvZiB0cmFuc2FjdGlvbiBwcm9jZXNzaW5nICovXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvciB8IG51bGw7XG4gIC8qKiBUaGUgY29sbGVjdGlvbiBvZiBhZGRyZXNzZXMgbG9hZGVkIHVzaW5nIGFkZHJlc3MgbG9va3VwIHRhYmxlcyAqL1xuICBsb2FkZWRBZGRyZXNzZXM/OiBMb2FkZWRBZGRyZXNzZXM7XG4gIC8qKiBUaGUgY29tcHV0ZSB1bml0cyBjb25zdW1lZCBhZnRlciBwcm9jZXNzaW5nIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBjb21wdXRlVW5pdHNDb25zdW1lZD86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIENvbXBpbGVkSW5uZXJJbnN0cnVjdGlvbiA9IHtcbiAgaW5kZXg6IG51bWJlcjtcbiAgaW5zdHJ1Y3Rpb25zOiBDb21waWxlZEluc3RydWN0aW9uW107XG59O1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cbmV4cG9ydCB0eXBlIENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YSA9IHtcbiAgLyoqIFRoZSBmZWUgY2hhcmdlZCBmb3IgcHJvY2Vzc2luZyB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgZmVlOiBudW1iZXI7XG4gIC8qKiBBbiBhcnJheSBvZiBjcm9zcyBwcm9ncmFtIGludm9rZWQgaW5zdHJ1Y3Rpb25zICovXG4gIGlubmVySW5zdHJ1Y3Rpb25zPzogQ29tcGlsZWRJbm5lckluc3RydWN0aW9uW10gfCBudWxsO1xuICAvKiogVGhlIGJhbGFuY2VzIG9mIHRoZSB0cmFuc2FjdGlvbiBhY2NvdW50cyBiZWZvcmUgcHJvY2Vzc2luZyAqL1xuICBwcmVCYWxhbmNlczogQXJyYXk8bnVtYmVyPjtcbiAgLyoqIFRoZSBiYWxhbmNlcyBvZiB0aGUgdHJhbnNhY3Rpb24gYWNjb3VudHMgYWZ0ZXIgcHJvY2Vzc2luZyAqL1xuICBwb3N0QmFsYW5jZXM6IEFycmF5PG51bWJlcj47XG4gIC8qKiBBbiBhcnJheSBvZiBwcm9ncmFtIGxvZyBtZXNzYWdlcyBlbWl0dGVkIGR1cmluZyBhIHRyYW5zYWN0aW9uICovXG4gIGxvZ01lc3NhZ2VzPzogQXJyYXk8c3RyaW5nPiB8IG51bGw7XG4gIC8qKiBUaGUgdG9rZW4gYmFsYW5jZXMgb2YgdGhlIHRyYW5zYWN0aW9uIGFjY291bnRzIGJlZm9yZSBwcm9jZXNzaW5nICovXG4gIHByZVRva2VuQmFsYW5jZXM/OiBBcnJheTxUb2tlbkJhbGFuY2U+IHwgbnVsbDtcbiAgLyoqIFRoZSB0b2tlbiBiYWxhbmNlcyBvZiB0aGUgdHJhbnNhY3Rpb24gYWNjb3VudHMgYWZ0ZXIgcHJvY2Vzc2luZyAqL1xuICBwb3N0VG9rZW5CYWxhbmNlcz86IEFycmF5PFRva2VuQmFsYW5jZT4gfCBudWxsO1xuICAvKiogVGhlIGVycm9yIHJlc3VsdCBvZiB0cmFuc2FjdGlvbiBwcm9jZXNzaW5nICovXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvciB8IG51bGw7XG4gIC8qKiBUaGUgY29sbGVjdGlvbiBvZiBhZGRyZXNzZXMgbG9hZGVkIHVzaW5nIGFkZHJlc3MgbG9va3VwIHRhYmxlcyAqL1xuICBsb2FkZWRBZGRyZXNzZXM/OiBMb2FkZWRBZGRyZXNzZXM7XG4gIC8qKiBUaGUgY29tcHV0ZSB1bml0cyBjb25zdW1lZCBhZnRlciBwcm9jZXNzaW5nIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBjb21wdXRlVW5pdHNDb25zdW1lZD86IG51bWJlcjtcbn07XG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5leHBvcnQgdHlwZSBUcmFuc2FjdGlvblJlc3BvbnNlID0ge1xuICAvKiogVGhlIHNsb3QgZHVyaW5nIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiB3YXMgcHJvY2Vzc2VkICovXG4gIHNsb3Q6IG51bWJlcjtcbiAgLyoqIFRoZSB0cmFuc2FjdGlvbiAqL1xuICB0cmFuc2FjdGlvbjoge1xuICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gbWVzc2FnZSAqL1xuICAgIG1lc3NhZ2U6IE1lc3NhZ2U7XG4gICAgLyoqIFRoZSB0cmFuc2FjdGlvbiBzaWduYXR1cmVzICovXG4gICAgc2lnbmF0dXJlczogc3RyaW5nW107XG4gIH07XG4gIC8qKiBNZXRhZGF0YSBwcm9kdWNlZCBmcm9tIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBtZXRhOiBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGEgfCBudWxsO1xuICAvKiogVGhlIHVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRyYW5zYWN0aW9uIHdhcyBwcm9jZXNzZWQgKi9cbiAgYmxvY2tUaW1lPzogbnVtYmVyIHwgbnVsbDtcbn07XG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5leHBvcnQgdHlwZSBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlID0ge1xuICAvKiogVGhlIHNsb3QgZHVyaW5nIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiB3YXMgcHJvY2Vzc2VkICovXG4gIHNsb3Q6IG51bWJlcjtcbiAgLyoqIFRoZSB0cmFuc2FjdGlvbiAqL1xuICB0cmFuc2FjdGlvbjoge1xuICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gbWVzc2FnZSAqL1xuICAgIG1lc3NhZ2U6IFZlcnNpb25lZE1lc3NhZ2U7XG4gICAgLyoqIFRoZSB0cmFuc2FjdGlvbiBzaWduYXR1cmVzICovXG4gICAgc2lnbmF0dXJlczogc3RyaW5nW107XG4gIH07XG4gIC8qKiBNZXRhZGF0YSBwcm9kdWNlZCBmcm9tIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBtZXRhOiBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGEgfCBudWxsO1xuICAvKiogVGhlIHVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRyYW5zYWN0aW9uIHdhcyBwcm9jZXNzZWQgKi9cbiAgYmxvY2tUaW1lPzogbnVtYmVyIHwgbnVsbDtcbiAgLyoqIFRoZSB0cmFuc2FjdGlvbiB2ZXJzaW9uICovXG4gIHZlcnNpb24/OiBUcmFuc2FjdGlvblZlcnNpb247XG59O1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgUlBDIEFQSVxuICovXG50eXBlIE1lc3NhZ2VSZXNwb25zZSA9IHtcbiAgYWNjb3VudEtleXM6IHN0cmluZ1tdO1xuICBoZWFkZXI6IE1lc3NhZ2VIZWFkZXI7XG4gIGluc3RydWN0aW9uczogQ29tcGlsZWRJbnN0cnVjdGlvbltdO1xuICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZztcbiAgYWRkcmVzc1RhYmxlTG9va3Vwcz86IFBhcnNlZEFkZHJlc3NUYWJsZUxvb2t1cFtdO1xufTtcblxuLyoqXG4gKiBBIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLlxuICovXG5leHBvcnQgdHlwZSBDb25maXJtZWRUcmFuc2FjdGlvbiA9IHtcbiAgLyoqIFRoZSBzbG90IGR1cmluZyB3aGljaCB0aGUgdHJhbnNhY3Rpb24gd2FzIHByb2Nlc3NlZCAqL1xuICBzbG90OiBudW1iZXI7XG4gIC8qKiBUaGUgZGV0YWlscyBvZiB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uO1xuICAvKiogTWV0YWRhdGEgcHJvZHVjZWQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgbWV0YTogQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhIHwgbnVsbDtcbiAgLyoqIFRoZSB1bml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSB0cmFuc2FjdGlvbiB3YXMgcHJvY2Vzc2VkICovXG4gIGJsb2NrVGltZT86IG51bWJlciB8IG51bGw7XG59O1xuXG4vKipcbiAqIEEgcGFydGlhbGx5IGRlY29kZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IHR5cGUgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uID0ge1xuICAvKiogUHJvZ3JhbSBpZCBjYWxsZWQgYnkgdGhpcyBpbnN0cnVjdGlvbiAqL1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbiAgLyoqIFB1YmxpYyBrZXlzIG9mIGFjY291bnRzIHBhc3NlZCB0byB0aGlzIGluc3RydWN0aW9uICovXG4gIGFjY291bnRzOiBBcnJheTxQdWJsaWNLZXk+O1xuICAvKiogUmF3IGJhc2UtNTggaW5zdHJ1Y3Rpb24gZGF0YSAqL1xuICBkYXRhOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgYWNjb3VudFxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRNZXNzYWdlQWNjb3VudCA9IHtcbiAgLyoqIFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgKi9cbiAgcHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBJbmRpY2F0ZXMgaWYgdGhlIGFjY291bnQgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBzaWduZXI6IGJvb2xlYW47XG4gIC8qKiBJbmRpY2F0ZXMgaWYgdGhlIGFjY291bnQgaXMgd3JpdGFibGUgZm9yIHRoaXMgdHJhbnNhY3Rpb24gKi9cbiAgd3JpdGFibGU6IGJvb2xlYW47XG4gIC8qKiBJbmRpY2F0ZXMgaWYgdGhlIGFjY291bnQga2V5IGNhbWUgZnJvbSB0aGUgdHJhbnNhY3Rpb24gb3IgYSBsb29rdXAgdGFibGUgKi9cbiAgc291cmNlPzogJ3RyYW5zYWN0aW9uJyB8ICdsb29rdXBUYWJsZSc7XG59O1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnNlZEluc3RydWN0aW9uID0ge1xuICAvKiogTmFtZSBvZiB0aGUgcHJvZ3JhbSBmb3IgdGhpcyBpbnN0cnVjdGlvbiAqL1xuICBwcm9ncmFtOiBzdHJpbmc7XG4gIC8qKiBJRCBvZiB0aGUgcHJvZ3JhbSBmb3IgdGhpcyBpbnN0cnVjdGlvbiAqL1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbiAgLyoqIFBhcnNlZCBpbnN0cnVjdGlvbiBpbmZvICovXG4gIHBhcnNlZDogYW55O1xufTtcblxuLyoqXG4gKiBBIHBhcnNlZCBhZGRyZXNzIHRhYmxlIGxvb2t1cFxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRBZGRyZXNzVGFibGVMb29rdXAgPSB7XG4gIC8qKiBBZGRyZXNzIGxvb2t1cCB0YWJsZSBhY2NvdW50IGtleSAqL1xuICBhY2NvdW50S2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBQYXJzZWQgaW5zdHJ1Y3Rpb24gaW5mbyAqL1xuICB3cml0YWJsZUluZGV4ZXM6IG51bWJlcltdO1xuICAvKiogUGFyc2VkIGluc3RydWN0aW9uIGluZm8gKi9cbiAgcmVhZG9ubHlJbmRleGVzOiBudW1iZXJbXTtcbn07XG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZVxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRNZXNzYWdlID0ge1xuICAvKiogQWNjb3VudHMgdXNlZCBpbiB0aGUgaW5zdHJ1Y3Rpb25zICovXG4gIGFjY291bnRLZXlzOiBQYXJzZWRNZXNzYWdlQWNjb3VudFtdO1xuICAvKiogVGhlIGF0b21pY2FsbHkgZXhlY3V0ZWQgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgaW5zdHJ1Y3Rpb25zOiAoUGFyc2VkSW5zdHJ1Y3Rpb24gfCBQYXJ0aWFsbHlEZWNvZGVkSW5zdHJ1Y3Rpb24pW107XG4gIC8qKiBSZWNlbnQgYmxvY2toYXNoICovXG4gIHJlY2VudEJsb2NraGFzaDogc3RyaW5nO1xuICAvKiogQWRkcmVzcyB0YWJsZSBsb29rdXBzIHVzZWQgdG8gbG9hZCBhZGRpdGlvbmFsIGFjY291bnRzICovXG4gIGFkZHJlc3NUYWJsZUxvb2t1cHM/OiBQYXJzZWRBZGRyZXNzVGFibGVMb29rdXBbXSB8IG51bGw7XG59O1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnNlZFRyYW5zYWN0aW9uID0ge1xuICAvKiogU2lnbmF0dXJlcyBmb3IgdGhlIHRyYW5zYWN0aW9uICovXG4gIHNpZ25hdHVyZXM6IEFycmF5PHN0cmluZz47XG4gIC8qKiBNZXNzYWdlIG9mIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBtZXNzYWdlOiBQYXJzZWRNZXNzYWdlO1xufTtcblxuLyoqXG4gKiBBIHBhcnNlZCBhbmQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uV2l0aE1ldGF9IGluc3RlYWQuXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uID0gUGFyc2VkVHJhbnNhY3Rpb25XaXRoTWV0YTtcblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyIHdpdGggbWV0YVxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRUcmFuc2FjdGlvbldpdGhNZXRhID0ge1xuICAvKiogVGhlIHNsb3QgZHVyaW5nIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiB3YXMgcHJvY2Vzc2VkICovXG4gIHNsb3Q6IG51bWJlcjtcbiAgLyoqIFRoZSBkZXRhaWxzIG9mIHRoZSB0cmFuc2FjdGlvbiAqL1xuICB0cmFuc2FjdGlvbjogUGFyc2VkVHJhbnNhY3Rpb247XG4gIC8qKiBNZXRhZGF0YSBwcm9kdWNlZCBmcm9tIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBtZXRhOiBQYXJzZWRUcmFuc2FjdGlvbk1ldGEgfCBudWxsO1xuICAvKiogVGhlIHVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRyYW5zYWN0aW9uIHdhcyBwcm9jZXNzZWQgKi9cbiAgYmxvY2tUaW1lPzogbnVtYmVyIHwgbnVsbDtcbiAgLyoqIFRoZSB2ZXJzaW9uIG9mIHRoZSB0cmFuc2FjdGlvbiBtZXNzYWdlICovXG4gIHZlcnNpb24/OiBUcmFuc2FjdGlvblZlcnNpb247XG59O1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5leHBvcnQgdHlwZSBCbG9ja1Jlc3BvbnNlID0ge1xuICAvKiogQmxvY2toYXNoIG9mIHRoaXMgYmxvY2sgKi9cbiAgYmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gIC8qKiBCbG9ja2hhc2ggb2YgdGhpcyBibG9jaydzIHBhcmVudCAqL1xuICBwcmV2aW91c0Jsb2NraGFzaDogQmxvY2toYXNoO1xuICAvKiogU2xvdCBpbmRleCBvZiB0aGlzIGJsb2NrJ3MgcGFyZW50ICovXG4gIHBhcmVudFNsb3Q6IG51bWJlcjtcbiAgLyoqIFZlY3RvciBvZiB0cmFuc2FjdGlvbnMgd2l0aCBzdGF0dXMgbWV0YSBhbmQgb3JpZ2luYWwgbWVzc2FnZSAqL1xuICB0cmFuc2FjdGlvbnM6IEFycmF5PHtcbiAgICAvKiogVGhlIHRyYW5zYWN0aW9uICovXG4gICAgdHJhbnNhY3Rpb246IHtcbiAgICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gbWVzc2FnZSAqL1xuICAgICAgbWVzc2FnZTogTWVzc2FnZTtcbiAgICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gc2lnbmF0dXJlcyAqL1xuICAgICAgc2lnbmF0dXJlczogc3RyaW5nW107XG4gICAgfTtcbiAgICAvKiogTWV0YWRhdGEgcHJvZHVjZWQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgICBtZXRhOiBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGEgfCBudWxsO1xuICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gdmVyc2lvbiAqL1xuICAgIHZlcnNpb24/OiBUcmFuc2FjdGlvblZlcnNpb247XG4gIH0+O1xuICAvKiogVmVjdG9yIG9mIGJsb2NrIHJld2FyZHMgKi9cbiAgcmV3YXJkcz86IEFycmF5PHtcbiAgICAvKiogUHVibGljIGtleSBvZiByZXdhcmQgcmVjaXBpZW50ICovXG4gICAgcHVia2V5OiBzdHJpbmc7XG4gICAgLyoqIFJld2FyZCB2YWx1ZSBpbiBsYW1wb3J0cyAqL1xuICAgIGxhbXBvcnRzOiBudW1iZXI7XG4gICAgLyoqIEFjY291bnQgYmFsYW5jZSBhZnRlciByZXdhcmQgaXMgYXBwbGllZCAqL1xuICAgIHBvc3RCYWxhbmNlOiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiBUeXBlIG9mIHJld2FyZCByZWNlaXZlZCAqL1xuICAgIHJld2FyZFR5cGU6IHN0cmluZyB8IG51bGw7XG4gICAgLyoqIFZvdGUgYWNjb3VudCBjb21taXNzaW9uIHdoZW4gdGhlIHJld2FyZCB3YXMgY3JlZGl0ZWQsIG9ubHkgcHJlc2VudCBmb3Igdm90aW5nIGFuZCBzdGFraW5nIHJld2FyZHMgKi9cbiAgICBjb21taXNzaW9uPzogbnVtYmVyIHwgbnVsbDtcbiAgfT47XG4gIC8qKiBUaGUgdW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYmxvY2sgd2FzIHByb2Nlc3NlZCAqL1xuICBibG9ja1RpbWU6IG51bWJlciB8IG51bGw7XG59O1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cbmV4cG9ydCB0eXBlIEFjY291bnRzTW9kZUJsb2NrUmVzcG9uc2UgPSBWZXJzaW9uZWRBY2NvdW50c01vZGVCbG9ja1Jlc3BvbnNlO1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuZXhwb3J0IHR5cGUgTm9uZU1vZGVCbG9ja1Jlc3BvbnNlID0gVmVyc2lvbmVkTm9uZU1vZGVCbG9ja1Jlc3BvbnNlO1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnNlZEJsb2NrUmVzcG9uc2UgPSB7XG4gIC8qKiBCbG9ja2hhc2ggb2YgdGhpcyBibG9jayAqL1xuICBibG9ja2hhc2g6IEJsb2NraGFzaDtcbiAgLyoqIEJsb2NraGFzaCBvZiB0aGlzIGJsb2NrJ3MgcGFyZW50ICovXG4gIHByZXZpb3VzQmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gIC8qKiBTbG90IGluZGV4IG9mIHRoaXMgYmxvY2sncyBwYXJlbnQgKi9cbiAgcGFyZW50U2xvdDogbnVtYmVyO1xuICAvKiogVmVjdG9yIG9mIHRyYW5zYWN0aW9ucyB3aXRoIHN0YXR1cyBtZXRhIGFuZCBvcmlnaW5hbCBtZXNzYWdlICovXG4gIHRyYW5zYWN0aW9uczogQXJyYXk8e1xuICAgIC8qKiBUaGUgZGV0YWlscyBvZiB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgICB0cmFuc2FjdGlvbjogUGFyc2VkVHJhbnNhY3Rpb247XG4gICAgLyoqIE1ldGFkYXRhIHByb2R1Y2VkIGZyb20gdGhlIHRyYW5zYWN0aW9uICovXG4gICAgbWV0YTogUGFyc2VkVHJhbnNhY3Rpb25NZXRhIHwgbnVsbDtcbiAgICAvKiogVGhlIHRyYW5zYWN0aW9uIHZlcnNpb24gKi9cbiAgICB2ZXJzaW9uPzogVHJhbnNhY3Rpb25WZXJzaW9uO1xuICB9PjtcbiAgLyoqIFZlY3RvciBvZiBibG9jayByZXdhcmRzICovXG4gIHJld2FyZHM/OiBBcnJheTx7XG4gICAgLyoqIFB1YmxpYyBrZXkgb2YgcmV3YXJkIHJlY2lwaWVudCAqL1xuICAgIHB1YmtleTogc3RyaW5nO1xuICAgIC8qKiBSZXdhcmQgdmFsdWUgaW4gbGFtcG9ydHMgKi9cbiAgICBsYW1wb3J0czogbnVtYmVyO1xuICAgIC8qKiBBY2NvdW50IGJhbGFuY2UgYWZ0ZXIgcmV3YXJkIGlzIGFwcGxpZWQgKi9cbiAgICBwb3N0QmFsYW5jZTogbnVtYmVyIHwgbnVsbDtcbiAgICAvKiogVHlwZSBvZiByZXdhcmQgcmVjZWl2ZWQgKi9cbiAgICByZXdhcmRUeXBlOiBzdHJpbmcgfCBudWxsO1xuICAgIC8qKiBWb3RlIGFjY291bnQgY29tbWlzc2lvbiB3aGVuIHRoZSByZXdhcmQgd2FzIGNyZWRpdGVkLCBvbmx5IHByZXNlbnQgZm9yIHZvdGluZyBhbmQgc3Rha2luZyByZXdhcmRzICovXG4gICAgY29tbWlzc2lvbj86IG51bWJlciB8IG51bGw7XG4gIH0+O1xuICAvKiogVGhlIHVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGJsb2NrIHdhcyBwcm9jZXNzZWQgKi9cbiAgYmxvY2tUaW1lOiBudW1iZXIgfCBudWxsO1xuICAvKiogVGhlIG51bWJlciBvZiBibG9ja3MgYmVuZWF0aCB0aGlzIGJsb2NrICovXG4gIGJsb2NrSGVpZ2h0OiBudW1iZXIgfCBudWxsO1xufTtcblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUmVzcG9uc2UgPSBPbWl0PFxuICBQYXJzZWRCbG9ja1Jlc3BvbnNlLFxuICAndHJhbnNhY3Rpb25zJ1xuPiAmIHtcbiAgdHJhbnNhY3Rpb25zOiBBcnJheTxcbiAgICBPbWl0PFBhcnNlZEJsb2NrUmVzcG9uc2VbJ3RyYW5zYWN0aW9ucyddW251bWJlcl0sICd0cmFuc2FjdGlvbic+ICYge1xuICAgICAgdHJhbnNhY3Rpb246IFBpY2s8XG4gICAgICAgIFBhcnNlZEJsb2NrUmVzcG9uc2VbJ3RyYW5zYWN0aW9ucyddW251bWJlcl1bJ3RyYW5zYWN0aW9uJ10sXG4gICAgICAgICdzaWduYXR1cmVzJ1xuICAgICAgPiAmIHtcbiAgICAgICAgYWNjb3VudEtleXM6IFBhcnNlZE1lc3NhZ2VBY2NvdW50W107XG4gICAgICB9O1xuICAgIH1cbiAgPjtcbn07XG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnNlZE5vbmVNb2RlQmxvY2tSZXNwb25zZSA9IE9taXQ8XG4gIFBhcnNlZEJsb2NrUmVzcG9uc2UsXG4gICd0cmFuc2FjdGlvbnMnXG4+O1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5leHBvcnQgdHlwZSBWZXJzaW9uZWRCbG9ja1Jlc3BvbnNlID0ge1xuICAvKiogQmxvY2toYXNoIG9mIHRoaXMgYmxvY2sgKi9cbiAgYmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gIC8qKiBCbG9ja2hhc2ggb2YgdGhpcyBibG9jaydzIHBhcmVudCAqL1xuICBwcmV2aW91c0Jsb2NraGFzaDogQmxvY2toYXNoO1xuICAvKiogU2xvdCBpbmRleCBvZiB0aGlzIGJsb2NrJ3MgcGFyZW50ICovXG4gIHBhcmVudFNsb3Q6IG51bWJlcjtcbiAgLyoqIFZlY3RvciBvZiB0cmFuc2FjdGlvbnMgd2l0aCBzdGF0dXMgbWV0YSBhbmQgb3JpZ2luYWwgbWVzc2FnZSAqL1xuICB0cmFuc2FjdGlvbnM6IEFycmF5PHtcbiAgICAvKiogVGhlIHRyYW5zYWN0aW9uICovXG4gICAgdHJhbnNhY3Rpb246IHtcbiAgICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gbWVzc2FnZSAqL1xuICAgICAgbWVzc2FnZTogVmVyc2lvbmVkTWVzc2FnZTtcbiAgICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gc2lnbmF0dXJlcyAqL1xuICAgICAgc2lnbmF0dXJlczogc3RyaW5nW107XG4gICAgfTtcbiAgICAvKiogTWV0YWRhdGEgcHJvZHVjZWQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgICBtZXRhOiBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGEgfCBudWxsO1xuICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gdmVyc2lvbiAqL1xuICAgIHZlcnNpb24/OiBUcmFuc2FjdGlvblZlcnNpb247XG4gIH0+O1xuICAvKiogVmVjdG9yIG9mIGJsb2NrIHJld2FyZHMgKi9cbiAgcmV3YXJkcz86IEFycmF5PHtcbiAgICAvKiogUHVibGljIGtleSBvZiByZXdhcmQgcmVjaXBpZW50ICovXG4gICAgcHVia2V5OiBzdHJpbmc7XG4gICAgLyoqIFJld2FyZCB2YWx1ZSBpbiBsYW1wb3J0cyAqL1xuICAgIGxhbXBvcnRzOiBudW1iZXI7XG4gICAgLyoqIEFjY291bnQgYmFsYW5jZSBhZnRlciByZXdhcmQgaXMgYXBwbGllZCAqL1xuICAgIHBvc3RCYWxhbmNlOiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiBUeXBlIG9mIHJld2FyZCByZWNlaXZlZCAqL1xuICAgIHJld2FyZFR5cGU6IHN0cmluZyB8IG51bGw7XG4gICAgLyoqIFZvdGUgYWNjb3VudCBjb21taXNzaW9uIHdoZW4gdGhlIHJld2FyZCB3YXMgY3JlZGl0ZWQsIG9ubHkgcHJlc2VudCBmb3Igdm90aW5nIGFuZCBzdGFraW5nIHJld2FyZHMgKi9cbiAgICBjb21taXNzaW9uPzogbnVtYmVyIHwgbnVsbDtcbiAgfT47XG4gIC8qKiBUaGUgdW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYmxvY2sgd2FzIHByb2Nlc3NlZCAqL1xuICBibG9ja1RpbWU6IG51bWJlciB8IG51bGw7XG59O1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cbmV4cG9ydCB0eXBlIFZlcnNpb25lZEFjY291bnRzTW9kZUJsb2NrUmVzcG9uc2UgPSBPbWl0PFxuICBWZXJzaW9uZWRCbG9ja1Jlc3BvbnNlLFxuICAndHJhbnNhY3Rpb25zJ1xuPiAmIHtcbiAgdHJhbnNhY3Rpb25zOiBBcnJheTxcbiAgICBPbWl0PFZlcnNpb25lZEJsb2NrUmVzcG9uc2VbJ3RyYW5zYWN0aW9ucyddW251bWJlcl0sICd0cmFuc2FjdGlvbic+ICYge1xuICAgICAgdHJhbnNhY3Rpb246IFBpY2s8XG4gICAgICAgIFZlcnNpb25lZEJsb2NrUmVzcG9uc2VbJ3RyYW5zYWN0aW9ucyddW251bWJlcl1bJ3RyYW5zYWN0aW9uJ10sXG4gICAgICAgICdzaWduYXR1cmVzJ1xuICAgICAgPiAmIHtcbiAgICAgICAgYWNjb3VudEtleXM6IFBhcnNlZE1lc3NhZ2VBY2NvdW50W107XG4gICAgICB9O1xuICAgIH1cbiAgPjtcbn07XG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5leHBvcnQgdHlwZSBWZXJzaW9uZWROb25lTW9kZUJsb2NrUmVzcG9uc2UgPSBPbWl0PFxuICBWZXJzaW9uZWRCbG9ja1Jlc3BvbnNlLFxuICAndHJhbnNhY3Rpb25zJ1xuPjtcblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBibG9jayBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLlxuICovXG5leHBvcnQgdHlwZSBDb25maXJtZWRCbG9jayA9IHtcbiAgLyoqIEJsb2NraGFzaCBvZiB0aGlzIGJsb2NrICovXG4gIGJsb2NraGFzaDogQmxvY2toYXNoO1xuICAvKiogQmxvY2toYXNoIG9mIHRoaXMgYmxvY2sncyBwYXJlbnQgKi9cbiAgcHJldmlvdXNCbG9ja2hhc2g6IEJsb2NraGFzaDtcbiAgLyoqIFNsb3QgaW5kZXggb2YgdGhpcyBibG9jaydzIHBhcmVudCAqL1xuICBwYXJlbnRTbG90OiBudW1iZXI7XG4gIC8qKiBWZWN0b3Igb2YgdHJhbnNhY3Rpb25zIGFuZCBzdGF0dXMgbWV0YXMgKi9cbiAgdHJhbnNhY3Rpb25zOiBBcnJheTx7XG4gICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uO1xuICAgIG1ldGE6IENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YSB8IG51bGw7XG4gIH0+O1xuICAvKiogVmVjdG9yIG9mIGJsb2NrIHJld2FyZHMgKi9cbiAgcmV3YXJkcz86IEFycmF5PHtcbiAgICBwdWJrZXk6IHN0cmluZztcbiAgICBsYW1wb3J0czogbnVtYmVyO1xuICAgIHBvc3RCYWxhbmNlOiBudW1iZXIgfCBudWxsO1xuICAgIHJld2FyZFR5cGU6IHN0cmluZyB8IG51bGw7XG4gICAgY29tbWlzc2lvbj86IG51bWJlciB8IG51bGw7XG4gIH0+O1xuICAvKiogVGhlIHVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGJsb2NrIHdhcyBwcm9jZXNzZWQgKi9cbiAgYmxvY2tUaW1lOiBudW1iZXIgfCBudWxsO1xufTtcblxuLyoqXG4gKiBBIEJsb2NrIG9uIHRoZSBsZWRnZXIgd2l0aCBzaWduYXR1cmVzIG9ubHlcbiAqL1xuZXhwb3J0IHR5cGUgQmxvY2tTaWduYXR1cmVzID0ge1xuICAvKiogQmxvY2toYXNoIG9mIHRoaXMgYmxvY2sgKi9cbiAgYmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gIC8qKiBCbG9ja2hhc2ggb2YgdGhpcyBibG9jaydzIHBhcmVudCAqL1xuICBwcmV2aW91c0Jsb2NraGFzaDogQmxvY2toYXNoO1xuICAvKiogU2xvdCBpbmRleCBvZiB0aGlzIGJsb2NrJ3MgcGFyZW50ICovXG4gIHBhcmVudFNsb3Q6IG51bWJlcjtcbiAgLyoqIFZlY3RvciBvZiBzaWduYXR1cmVzICovXG4gIHNpZ25hdHVyZXM6IEFycmF5PHN0cmluZz47XG4gIC8qKiBUaGUgdW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYmxvY2sgd2FzIHByb2Nlc3NlZCAqL1xuICBibG9ja1RpbWU6IG51bWJlciB8IG51bGw7XG59O1xuXG4vKipcbiAqIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIEJsb2NrUHJvZHVjdGlvbiA9IFJlYWRvbmx5PHtcbiAgLyoqIGEgZGljdGlvbmFyeSBvZiB2YWxpZGF0b3IgaWRlbnRpdGllcywgYXMgYmFzZS01OCBlbmNvZGVkIHN0cmluZ3MuIFZhbHVlIGlzIGEgdHdvIGVsZW1lbnQgYXJyYXkgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGxlYWRlciBzbG90cyBhbmQgdGhlIG51bWJlciBvZiBibG9ja3MgcHJvZHVjZWQgKi9cbiAgYnlJZGVudGl0eTogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgUmVhZG9ubHlBcnJheTxudW1iZXI+Pj47XG4gIC8qKiBCbG9jayBwcm9kdWN0aW9uIHNsb3QgcmFuZ2UgKi9cbiAgcmFuZ2U6IFJlYWRvbmx5PHtcbiAgICAvKiogZmlyc3Qgc2xvdCBvZiB0aGUgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiAoaW5jbHVzaXZlKSAqL1xuICAgIGZpcnN0U2xvdDogbnVtYmVyO1xuICAgIC8qKiBsYXN0IHNsb3Qgb2YgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiAoaW5jbHVzaXZlKSAqL1xuICAgIGxhc3RTbG90OiBudW1iZXI7XG4gIH0+O1xufT47XG5cbmV4cG9ydCB0eXBlIEdldEJsb2NrUHJvZHVjdGlvbkNvbmZpZyA9IHtcbiAgLyoqIE9wdGlvbmFsIGNvbW1pdG1lbnQgbGV2ZWwgKi9cbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKiBTbG90IHJhbmdlIHRvIHJldHVybiBibG9jayBwcm9kdWN0aW9uIGZvci4gSWYgcGFyYW1ldGVyIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gY3VycmVudCBlcG9jaC4gKi9cbiAgcmFuZ2U/OiB7XG4gICAgLyoqIGZpcnN0IHNsb3QgdG8gcmV0dXJuIGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24gZm9yIChpbmNsdXNpdmUpICovXG4gICAgZmlyc3RTbG90OiBudW1iZXI7XG4gICAgLyoqIGxhc3Qgc2xvdCB0byByZXR1cm4gYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiBmb3IgKGluY2x1c2l2ZSkuIElmIHBhcmFtZXRlciBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIHRoZSBoaWdoZXN0IHNsb3QgKi9cbiAgICBsYXN0U2xvdD86IG51bWJlcjtcbiAgfTtcbiAgLyoqIE9ubHkgcmV0dXJuIHJlc3VsdHMgZm9yIHRoaXMgdmFsaWRhdG9yIGlkZW50aXR5IChiYXNlLTU4IGVuY29kZWQpICovXG4gIGlkZW50aXR5Pzogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tQcm9kdWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFxuICBwaWNrKHtcbiAgICBieUlkZW50aXR5OiByZWNvcmQoc3RyaW5nKCksIGFycmF5KG51bWJlcigpKSksXG4gICAgcmFuZ2U6IHBpY2soe1xuICAgICAgZmlyc3RTbG90OiBudW1iZXIoKSxcbiAgICAgIGxhc3RTbG90OiBudW1iZXIoKSxcbiAgICB9KSxcbiAgfSksXG4pO1xuXG4vKipcbiAqIEEgcGVyZm9ybWFuY2Ugc2FtcGxlXG4gKi9cbmV4cG9ydCB0eXBlIFBlcmZTYW1wbGUgPSB7XG4gIC8qKiBTbG90IG51bWJlciBvZiBzYW1wbGUgKi9cbiAgc2xvdDogbnVtYmVyO1xuICAvKiogTnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBpbiBhIHNhbXBsZSB3aW5kb3cgKi9cbiAgbnVtVHJhbnNhY3Rpb25zOiBudW1iZXI7XG4gIC8qKiBOdW1iZXIgb2Ygc2xvdHMgaW4gYSBzYW1wbGUgd2luZG93ICovXG4gIG51bVNsb3RzOiBudW1iZXI7XG4gIC8qKiBTYW1wbGUgd2luZG93IGluIHNlY29uZHMgKi9cbiAgc2FtcGxlUGVyaW9kU2VjczogbnVtYmVyO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlUnBjQ2xpZW50KFxuICB1cmw6IHN0cmluZyxcbiAgaHR0cEhlYWRlcnM/OiBIdHRwSGVhZGVycyxcbiAgY3VzdG9tRmV0Y2g/OiBGZXRjaEZuLFxuICBmZXRjaE1pZGRsZXdhcmU/OiBGZXRjaE1pZGRsZXdhcmUsXG4gIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0PzogYm9vbGVhbixcbiAgaHR0cEFnZW50PzogTm9kZUh0dHBBZ2VudCB8IE5vZGVIdHRwc0FnZW50IHwgZmFsc2UsXG4pOiBScGNDbGllbnQge1xuICBjb25zdCBmZXRjaCA9IGN1c3RvbUZldGNoID8gY3VzdG9tRmV0Y2ggOiBmZXRjaEltcGw7XG4gIGxldCBhZ2VudDogTm9kZUh0dHBBZ2VudCB8IE5vZGVIdHRwc0FnZW50IHwgdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuQlJPV1NFUikge1xuICAgIGlmIChodHRwQWdlbnQgIT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnWW91IGhhdmUgc3VwcGxpZWQgYW4gYGh0dHBBZ2VudGAgd2hlbiBjcmVhdGluZyBhIGBDb25uZWN0aW9uYCBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuJyArXG4gICAgICAgICAgJ0l0IGhhcyBiZWVuIGlnbm9yZWQ7IGBodHRwQWdlbnRgIGlzIG9ubHkgdXNlZCBpbiBOb2RlIGVudmlyb25tZW50cy4nLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGh0dHBBZ2VudCA9PSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xuICAgICAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gT25lIHNlY29uZCBmZXdlciB0aGFuIHRoZSBTb2xhbmEgUlBDJ3Mga2VlcGFsaXZlIHRpbWVvdXQuXG4gICAgICAgICAgLy8gUmVhZCBtb3JlOiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8yNzg1OSNpc3N1ZWNvbW1lbnQtMTM0MDA5Nzg4OVxuICAgICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0OiAxOTAwMCxcbiAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgbWF4U29ja2V0czogMjUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykpIHtcbiAgICAgICAgICBhZ2VudCA9IG5ldyBIdHRwc0tlZXBBbGl2ZUFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cEtlZXBBbGl2ZUFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGh0dHBBZ2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbiAgICAgICAgaWYgKGlzSHR0cHMgJiYgIShodHRwQWdlbnQgaW5zdGFuY2VvZiBOb2RlSHR0cHNBZ2VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGVuZHBvaW50IGAnICtcbiAgICAgICAgICAgICAgdXJsICtcbiAgICAgICAgICAgICAgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHBzLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgK1xuICAgICAgICAgICAgICAnYGh0dHAuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0h0dHBzICYmIGh0dHBBZ2VudCBpbnN0YW5jZW9mIE5vZGVIdHRwc0FnZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBlbmRwb2ludCBgJyArXG4gICAgICAgICAgICAgIHVybCArXG4gICAgICAgICAgICAgICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgK1xuICAgICAgICAgICAgICAnYGh0dHBzLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgZmV0Y2hXaXRoTWlkZGxld2FyZTogRmV0Y2hGbiB8IHVuZGVmaW5lZDtcblxuICBpZiAoZmV0Y2hNaWRkbGV3YXJlKSB7XG4gICAgZmV0Y2hXaXRoTWlkZGxld2FyZSA9IGFzeW5jIChpbmZvLCBpbml0KSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEZldGNoQXJncyA9IGF3YWl0IG5ldyBQcm9taXNlPFBhcmFtZXRlcnM8RmV0Y2hGbj4+KFxuICAgICAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZldGNoTWlkZGxld2FyZShpbmZvLCBpbml0LCAobW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXQpID0+XG4gICAgICAgICAgICAgIHJlc29sdmUoW21vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0XSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2goLi4ubW9kaWZpZWRGZXRjaEFyZ3MpO1xuICAgIH07XG4gIH1cblxuICBjb25zdCBjbGllbnRCcm93c2VyID0gbmV3IFJwY0NsaWVudChhc3luYyAocmVxdWVzdCwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgYWdlbnQsXG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgaHR0cEhlYWRlcnMgfHwge30sXG4gICAgICAgIENPTU1PTl9IVFRQX0hFQURFUlMsXG4gICAgICApLFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPSA1O1xuICAgICAgbGV0IHJlczogUmVzcG9uc2U7XG4gICAgICBsZXQgd2FpdFRpbWUgPSA1MDA7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChmZXRjaFdpdGhNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2hXaXRoTWlkZGxld2FyZSh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzLnN0YXR1cyAhPT0gNDI5IC8qIFRvbyBtYW55IHJlcXVlc3RzICovKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyAtPSAxO1xuICAgICAgICBpZiAodG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9LiAgUmV0cnlpbmcgYWZ0ZXIgJHt3YWl0VGltZX1tcyBkZWxheS4uLmAsXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHNsZWVwKHdhaXRUaW1lKTtcbiAgICAgICAgd2FpdFRpbWUgKj0gMjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9OiAke3RleHR9YCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSwge30pO1xuXG4gIHJldHVybiBjbGllbnRCcm93c2VyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVScGNSZXF1ZXN0KGNsaWVudDogUnBjQ2xpZW50KTogUnBjUmVxdWVzdCB7XG4gIHJldHVybiAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgYXJncywgKGVycjogYW55LCByZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0KGNsaWVudDogUnBjQ2xpZW50KTogUnBjQmF0Y2hSZXF1ZXN0IHtcbiAgcmV0dXJuIChyZXF1ZXN0czogUnBjUGFyYW1zW10pID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gRG8gbm90aGluZyBpZiByZXF1ZXN0cyBpcyBlbXB0eVxuICAgICAgaWYgKHJlcXVlc3RzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG5cbiAgICAgIGNvbnN0IGJhdGNoID0gcmVxdWVzdHMubWFwKChwYXJhbXM6IFJwY1BhcmFtcykgPT4ge1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3QocGFyYW1zLm1ldGhvZE5hbWUsIHBhcmFtcy5hcmdzKTtcbiAgICAgIH0pO1xuXG4gICAgICBjbGllbnQucmVxdWVzdChiYXRjaCwgKGVycjogYW55LCByZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uR292ZXJub3JcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvblJhdGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoXG4gIEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoSW5mb1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hJbmZvUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaEluZm9SZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaFNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaFNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGVhZGVyU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcIm1pbmltdW1MZWRnZXJTbG90XCIgYW5kIFwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9ja1wiIG1lc3NhZ2VzXG4gKi9cbmNvbnN0IFNsb3RScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcblxuLyoqXG4gKiBTdXBwbHlcbiAqL1xuZXhwb3J0IHR5cGUgU3VwcGx5ID0ge1xuICAvKiogVG90YWwgc3VwcGx5IGluIGxhbXBvcnRzICovXG4gIHRvdGFsOiBudW1iZXI7XG4gIC8qKiBDaXJjdWxhdGluZyBzdXBwbHkgaW4gbGFtcG9ydHMgKi9cbiAgY2lyY3VsYXRpbmc6IG51bWJlcjtcbiAgLyoqIE5vbi1jaXJjdWxhdGluZyBzdXBwbHkgaW4gbGFtcG9ydHMgKi9cbiAgbm9uQ2lyY3VsYXRpbmc6IG51bWJlcjtcbiAgLyoqIExpc3Qgb2Ygbm9uLWNpcmN1bGF0aW5nIGFjY291bnQgYWRkcmVzc2VzICovXG4gIG5vbkNpcmN1bGF0aW5nQWNjb3VudHM6IEFycmF5PFB1YmxpY0tleT47XG59O1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTdXBwbHlcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFN1cHBseVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFxuICBwaWNrKHtcbiAgICB0b3RhbDogbnVtYmVyKCksXG4gICAgY2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICAgIG5vbkNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgICBub25DaXJjdWxhdGluZ0FjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgfSksXG4pO1xuXG4vKipcbiAqIFRva2VuIGFtb3VudCBvYmplY3Qgd2hpY2ggcmV0dXJucyBhIHRva2VuIGFtb3VudCBpbiBkaWZmZXJlbnQgZm9ybWF0c1xuICogZm9yIHZhcmlvdXMgY2xpZW50IHVzZSBjYXNlcy5cbiAqL1xuZXhwb3J0IHR5cGUgVG9rZW5BbW91bnQgPSB7XG4gIC8qKiBSYXcgYW1vdW50IG9mIHRva2VucyBhcyBzdHJpbmcgaWdub3JpbmcgZGVjaW1hbHMgKi9cbiAgYW1vdW50OiBzdHJpbmc7XG4gIC8qKiBOdW1iZXIgb2YgZGVjaW1hbHMgY29uZmlndXJlZCBmb3IgdG9rZW4ncyBtaW50ICovXG4gIGRlY2ltYWxzOiBudW1iZXI7XG4gIC8qKiBUb2tlbiBhbW91bnQgYXMgZmxvYXQsIGFjY291bnRzIGZvciBkZWNpbWFscyAqL1xuICB1aUFtb3VudDogbnVtYmVyIHwgbnVsbDtcbiAgLyoqIFRva2VuIGFtb3VudCBhcyBzdHJpbmcsIGFjY291bnRzIGZvciBkZWNpbWFscyAqL1xuICB1aUFtb3VudFN0cmluZz86IHN0cmluZztcbn07XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgc3RydWN0dXJlIGZvciB0b2tlbiBhbW91bnRzXG4gKi9cbmNvbnN0IFRva2VuQW1vdW50UmVzdWx0ID0gcGljayh7XG4gIGFtb3VudDogc3RyaW5nKCksXG4gIHVpQW1vdW50OiBudWxsYWJsZShudW1iZXIoKSksXG4gIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IG9wdGlvbmFsKHN0cmluZygpKSxcbn0pO1xuXG4vKipcbiAqIFRva2VuIGFkZHJlc3MgYW5kIGJhbGFuY2UuXG4gKi9cbmV4cG9ydCB0eXBlIFRva2VuQWNjb3VudEJhbGFuY2VQYWlyID0ge1xuICAvKiogQWRkcmVzcyBvZiB0aGUgdG9rZW4gYWNjb3VudCAqL1xuICBhZGRyZXNzOiBQdWJsaWNLZXk7XG4gIC8qKiBSYXcgYW1vdW50IG9mIHRva2VucyBhcyBzdHJpbmcgaWdub3JpbmcgZGVjaW1hbHMgKi9cbiAgYW1vdW50OiBzdHJpbmc7XG4gIC8qKiBOdW1iZXIgb2YgZGVjaW1hbHMgY29uZmlndXJlZCBmb3IgdG9rZW4ncyBtaW50ICovXG4gIGRlY2ltYWxzOiBudW1iZXI7XG4gIC8qKiBUb2tlbiBhbW91bnQgYXMgZmxvYXQsIGFjY291bnRzIGZvciBkZWNpbWFscyAqL1xuICB1aUFtb3VudDogbnVtYmVyIHwgbnVsbDtcbiAgLyoqIFRva2VuIGFtb3VudCBhcyBzdHJpbmcsIGFjY291bnRzIGZvciBkZWNpbWFscyAqL1xuICB1aUFtb3VudFN0cmluZz86IHN0cmluZztcbn07XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuTGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFxuICBhcnJheShcbiAgICBwaWNrKHtcbiAgICAgIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgICBhbW91bnQ6IHN0cmluZygpLFxuICAgICAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgICAgIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgICAgIHVpQW1vdW50U3RyaW5nOiBvcHRpb25hbChzdHJpbmcoKSksXG4gICAgfSksXG4gICksXG4pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChcbiAgYXJyYXkoXG4gICAgcGljayh7XG4gICAgICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgICBhY2NvdW50OiBwaWNrKHtcbiAgICAgICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgICAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICAgICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgICAgICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gICAgICAgIHJlbnRFcG9jaDogbnVtYmVyKCksXG4gICAgICB9KSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbmNvbnN0IFBhcnNlZEFjY291bnREYXRhUmVzdWx0ID0gcGljayh7XG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgc3BhY2U6IG51bWJlcigpLFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZSB3aXRoIHBhcnNlZCBkYXRhXG4gKi9cbmNvbnN0IEdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoXG4gIGFycmF5KFxuICAgIHBpY2soe1xuICAgICAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgICAgYWNjb3VudDogcGljayh7XG4gICAgICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICAgICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICAgICAgZGF0YTogUGFyc2VkQWNjb3VudERhdGFSZXN1bHQsXG4gICAgICAgIHJlbnRFcG9jaDogbnVtYmVyKCksXG4gICAgICB9KSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogUGFpciBvZiBhbiBhY2NvdW50IGFkZHJlc3MgYW5kIGl0cyBiYWxhbmNlXG4gKi9cbmV4cG9ydCB0eXBlIEFjY291bnRCYWxhbmNlUGFpciA9IHtcbiAgYWRkcmVzczogUHVibGljS2V5O1xuICBsYW1wb3J0czogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChcbiAgYXJyYXkoXG4gICAgcGljayh7XG4gICAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIH0pLFxuICApLFxuKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQWNjb3VudEluZm9SZXN1bHQgPSBwaWNrKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKCksXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHBpY2soe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0LFxufSk7XG5cbmNvbnN0IFBhcnNlZE9yUmF3QWNjb3VudERhdGEgPSBjb2VyY2UoXG4gIHVuaW9uKFtpbnN0YW5jZShCdWZmZXIpLCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLFxuICB1bmlvbihbUmF3QWNjb3VudERhdGFSZXN1bHQsIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksXG4gIHZhbHVlID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG4pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHBpY2soe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IFBhcnNlZE9yUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKCksXG59KTtcblxuY29uc3QgS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHBpY2soe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0LFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0YWtlQWN0aXZhdGlvblJlc3VsdCA9IHBpY2soe1xuICBzdGF0ZTogdW5pb24oW1xuICAgIGxpdGVyYWwoJ2FjdGl2ZScpLFxuICAgIGxpdGVyYWwoJ2luYWN0aXZlJyksXG4gICAgbGl0ZXJhbCgnYWN0aXZhdGluZycpLFxuICAgIGxpdGVyYWwoJ2RlYWN0aXZhdGluZycpLFxuICBdKSxcbiAgYWN0aXZlOiBudW1iZXIoKSxcbiAgaW5hY3RpdmU6IG51bWJlcigpLFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlwiIG1lc3NhZ2VcbiAqL1xuXG5jb25zdCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KFxuICBhcnJheShcbiAgICBwaWNrKHtcbiAgICAgIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gICAgICBzbG90OiBudW1iZXIoKSxcbiAgICAgIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgICAgIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgICAgIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoXG4gIGFycmF5KFxuICAgIHBpY2soe1xuICAgICAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgICAgIHNsb3Q6IG51bWJlcigpLFxuICAgICAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICAgICAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICAgICAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICAgIH0pLFxuICApLFxuKTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImFjY291bnROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSBwaWNrKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KEFjY291bnRJbmZvUmVzdWx0KSxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQgPSBwaWNrKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBBY2NvdW50SW5mb1Jlc3VsdCxcbn0pO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicHJvZ3JhbU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSBwaWNrKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCksXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdEluZm9SZXN1bHQgPSBwaWNrKHtcbiAgcGFyZW50OiBudW1iZXIoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHJvb3Q6IG51bWJlcigpLFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3ROb3RpZmljYXRpb25SZXN1bHQgPSBwaWNrKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90SW5mb1Jlc3VsdCxcbn0pO1xuXG4vKipcbiAqIFNsb3QgdXBkYXRlcyB3aGljaCBjYW4gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIGxpdmUgcHJvZ3Jlc3Mgb2YgYSBjbHVzdGVyLlxuICogLSBgXCJmaXJzdFNocmVkUmVjZWl2ZWRcImA6IGNvbm5lY3RlZCBub2RlIHJlY2VpdmVkIHRoZSBmaXJzdCBzaHJlZCBvZiBhIGJsb2NrLlxuICogSW5kaWNhdGVzIHRoYXQgYSBuZXcgYmxvY2sgdGhhdCBpcyBiZWluZyBwcm9kdWNlZC5cbiAqIC0gYFwiY29tcGxldGVkXCJgOiBjb25uZWN0ZWQgbm9kZSBoYXMgcmVjZWl2ZWQgYWxsIHNocmVkcyBvZiBhIGJsb2NrLiBJbmRpY2F0ZXNcbiAqIGEgYmxvY2sgd2FzIHJlY2VudGx5IHByb2R1Y2VkLlxuICogLSBgXCJvcHRpbWlzdGljQ29uZmlybWF0aW9uXCJgOiBibG9jayB3YXMgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkIGJ5IHRoZVxuICogY2x1c3Rlci4gSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCBhbiBvcHRpbWlzdGljIGNvbmZpcm1hdGlvbiBub3RpZmljYXRpb25cbiAqIHdpbGwgYmUgc2VudCBmb3IgZXZlcnkgZmluYWxpemVkIGJsb2Nrcy5cbiAqIC0gYFwicm9vdFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIHJvb3RlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJjcmVhdGVkQmFua1wiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyBzdGFydGVkIHZhbGlkYXRpbmcgdGhpcyBibG9jay5cbiAqIC0gYFwiZnJvemVuXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHZhbGlkYXRlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJkZWFkXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgZmFpbGVkIHRvIHZhbGlkYXRlIHRoaXMgYmxvY2suXG4gKi9cbmV4cG9ydCB0eXBlIFNsb3RVcGRhdGUgPVxuICB8IHtcbiAgICAgIHR5cGU6ICdmaXJzdFNocmVkUmVjZWl2ZWQnO1xuICAgICAgc2xvdDogbnVtYmVyO1xuICAgICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6ICdjb21wbGV0ZWQnO1xuICAgICAgc2xvdDogbnVtYmVyO1xuICAgICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6ICdjcmVhdGVkQmFuayc7XG4gICAgICBzbG90OiBudW1iZXI7XG4gICAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICAgIHBhcmVudDogbnVtYmVyO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiAnZnJvemVuJztcbiAgICAgIHNsb3Q6IG51bWJlcjtcbiAgICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgICAgc3RhdHM6IHtcbiAgICAgICAgbnVtVHJhbnNhY3Rpb25FbnRyaWVzOiBudW1iZXI7XG4gICAgICAgIG51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnM6IG51bWJlcjtcbiAgICAgICAgbnVtRmFpbGVkVHJhbnNhY3Rpb25zOiBudW1iZXI7XG4gICAgICAgIG1heFRyYW5zYWN0aW9uc1BlckVudHJ5OiBudW1iZXI7XG4gICAgICB9O1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiAnZGVhZCc7XG4gICAgICBzbG90OiBudW1iZXI7XG4gICAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICAgIGVycjogc3RyaW5nO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiAnb3B0aW1pc3RpY0NvbmZpcm1hdGlvbic7XG4gICAgICBzbG90OiBudW1iZXI7XG4gICAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogJ3Jvb3QnO1xuICAgICAgc2xvdDogbnVtYmVyO1xuICAgICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgfTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZVJlc3VsdCA9IHVuaW9uKFtcbiAgcGljayh7XG4gICAgdHlwZTogdW5pb24oW1xuICAgICAgbGl0ZXJhbCgnZmlyc3RTaHJlZFJlY2VpdmVkJyksXG4gICAgICBsaXRlcmFsKCdjb21wbGV0ZWQnKSxcbiAgICAgIGxpdGVyYWwoJ29wdGltaXN0aWNDb25maXJtYXRpb24nKSxcbiAgICAgIGxpdGVyYWwoJ3Jvb3QnKSxcbiAgICBdKSxcbiAgICBzbG90OiBudW1iZXIoKSxcbiAgICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICB9KSxcbiAgcGljayh7XG4gICAgdHlwZTogbGl0ZXJhbCgnY3JlYXRlZEJhbmsnKSxcbiAgICBwYXJlbnQ6IG51bWJlcigpLFxuICAgIHNsb3Q6IG51bWJlcigpLFxuICAgIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIH0pLFxuICBwaWNrKHtcbiAgICB0eXBlOiBsaXRlcmFsKCdmcm96ZW4nKSxcbiAgICBzbG90OiBudW1iZXIoKSxcbiAgICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICAgIHN0YXRzOiBwaWNrKHtcbiAgICAgIG51bVRyYW5zYWN0aW9uRW50cmllczogbnVtYmVyKCksXG4gICAgICBudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgICAgIG51bUZhaWxlZFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgICBtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeTogbnVtYmVyKCksXG4gICAgfSksXG4gIH0pLFxuICBwaWNrKHtcbiAgICB0eXBlOiBsaXRlcmFsKCdkZWFkJyksXG4gICAgc2xvdDogbnVtYmVyKCksXG4gICAgdGltZXN0YW1wOiBudW1iZXIoKSxcbiAgICBlcnI6IHN0cmluZygpLFxuICB9KSxcbl0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90c1VwZGF0ZXNOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQgPSBwaWNrKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90VXBkYXRlUmVzdWx0LFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNpZ25hdHVyZU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0ID0gcGljayh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChcbiAgICB1bmlvbihbU2lnbmF0dXJlU3RhdHVzUmVzdWx0LCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdF0pLFxuICApLFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJvb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJvb3ROb3RpZmljYXRpb25SZXN1bHQgPSBwaWNrKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBudW1iZXIoKSxcbn0pO1xuXG5jb25zdCBDb250YWN0SW5mb1Jlc3VsdCA9IHBpY2soe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBnb3NzaXA6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgdHB1OiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHJwYzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB2ZXJzaW9uOiBudWxsYWJsZShzdHJpbmcoKSksXG59KTtcblxuY29uc3QgVm90ZUFjY291bnRJbmZvUmVzdWx0ID0gcGljayh7XG4gIHZvdGVQdWJrZXk6IHN0cmluZygpLFxuICBub2RlUHVia2V5OiBzdHJpbmcoKSxcbiAgYWN0aXZhdGVkU3Rha2U6IG51bWJlcigpLFxuICBlcG9jaFZvdGVBY2NvdW50OiBib29sZWFuKCksXG4gIGVwb2NoQ3JlZGl0czogYXJyYXkodHVwbGUoW251bWJlcigpLCBudW1iZXIoKSwgbnVtYmVyKCldKSksXG4gIGNvbW1pc3Npb246IG51bWJlcigpLFxuICBsYXN0Vm90ZTogbnVtYmVyKCksXG4gIHJvb3RTbG90OiBudWxsYWJsZShudW1iZXIoKSksXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Vm90ZUFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRWb3RlQWNjb3VudHMgPSBqc29uUnBjUmVzdWx0KFxuICBwaWNrKHtcbiAgICBjdXJyZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpLFxuICAgIGRlbGlucXVlbnQ6IGFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdCksXG4gIH0pLFxuKTtcblxuY29uc3QgQ29uZmlybWF0aW9uU3RhdHVzID0gdW5pb24oW1xuICBsaXRlcmFsKCdwcm9jZXNzZWQnKSxcbiAgbGl0ZXJhbCgnY29uZmlybWVkJyksXG4gIGxpdGVyYWwoJ2ZpbmFsaXplZCcpLFxuXSk7XG5cbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlID0gcGljayh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBjb25maXJtYXRpb25zOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgY29uZmlybWF0aW9uU3RhdHVzOiBvcHRpb25hbChDb25maXJtYXRpb25TdGF0dXMpLFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZVN0YXR1c2VzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFxuICBhcnJheShudWxsYWJsZShTaWduYXR1cmVTdGF0dXNSZXNwb25zZSkpLFxuKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcblxuY29uc3QgQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0ID0gcGljayh7XG4gIGFjY291bnRLZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHdyaXRhYmxlSW5kZXhlczogYXJyYXkobnVtYmVyKCkpLFxuICByZWFkb25seUluZGV4ZXM6IGFycmF5KG51bWJlcigpKSxcbn0pO1xuXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHBpY2soe1xuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHBpY2soe1xuICAgIGFjY291bnRLZXlzOiBhcnJheShzdHJpbmcoKSksXG4gICAgaGVhZGVyOiBwaWNrKHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBudW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogbnVtYmVyKCksXG4gICAgfSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShcbiAgICAgIHBpY2soe1xuICAgICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpLFxuICAgICAgfSksXG4gICAgKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpLFxuICB9KSxcbn0pO1xuXG5jb25zdCBBbm5vdGF0ZWRBY2NvdW50S2V5ID0gcGljayh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgc2lnbmVyOiBib29sZWFuKCksXG4gIHdyaXRhYmxlOiBib29sZWFuKCksXG4gIHNvdXJjZTogb3B0aW9uYWwodW5pb24oW2xpdGVyYWwoJ3RyYW5zYWN0aW9uJyksIGxpdGVyYWwoJ2xvb2t1cFRhYmxlJyldKSksXG59KTtcblxuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQgPSBwaWNrKHtcbiAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG59KTtcblxuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQgPSBwaWNrKHtcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmcsXG59KTtcblxuY29uc3QgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQgPSBwaWNrKHtcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxufSk7XG5cbmNvbnN0IEluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW1xuICBSYXdJbnN0cnVjdGlvblJlc3VsdCxcbiAgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQsXG5dKTtcblxuY29uc3QgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW1xuICBwaWNrKHtcbiAgICBwYXJzZWQ6IHVua25vd24oKSxcbiAgICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgICBwcm9ncmFtSWQ6IHN0cmluZygpLFxuICB9KSxcbiAgcGljayh7XG4gICAgYWNjb3VudHM6IGFycmF5KHN0cmluZygpKSxcbiAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICBwcm9ncmFtSWQ6IHN0cmluZygpLFxuICB9KSxcbl0pO1xuXG5jb25zdCBQYXJzZWRPclJhd0luc3RydWN0aW9uID0gY29lcmNlKFxuICBJbnN0cnVjdGlvblJlc3VsdCxcbiAgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0LFxuICB2YWx1ZSA9PiB7XG4gICAgaWYgKCdhY2NvdW50cycgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFJhd0luc3RydWN0aW9uUmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICAgIH1cbiAgfSxcbik7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gcGljayh7XG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgbWVzc2FnZTogcGljayh7XG4gICAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkoUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKSksXG4gIH0pLFxufSk7XG5cbmNvbnN0IFRva2VuQmFsYW5jZVJlc3VsdCA9IHBpY2soe1xuICBhY2NvdW50SW5kZXg6IG51bWJlcigpLFxuICBtaW50OiBzdHJpbmcoKSxcbiAgb3duZXI6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgdWlUb2tlbkFtb3VudDogVG9rZW5BbW91bnRSZXN1bHQsXG59KTtcblxuY29uc3QgTG9hZGVkQWRkcmVzc2VzUmVzdWx0ID0gcGljayh7XG4gIHdyaXRhYmxlOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgcmVhZG9ubHk6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHBpY2soe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChcbiAgICBudWxsYWJsZShcbiAgICAgIGFycmF5KFxuICAgICAgICBwaWNrKHtcbiAgICAgICAgICBpbmRleDogbnVtYmVyKCksXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShcbiAgICAgICAgICAgIHBpY2soe1xuICAgICAgICAgICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgICAgICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgICAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICksXG4gICksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpLFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHBpY2soe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChcbiAgICBudWxsYWJsZShcbiAgICAgIGFycmF5KFxuICAgICAgICBwaWNrKHtcbiAgICAgICAgICBpbmRleDogbnVtYmVyKCksXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICksXG4gICksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpLFxufSk7XG5cbmNvbnN0IFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCA9IHVuaW9uKFtsaXRlcmFsKDApLCBsaXRlcmFsKCdsZWdhY3knKV0pO1xuXG4vKiogQGludGVybmFsICovXG5jb25zdCBSZXdhcmRzUmVzdWx0ID0gcGljayh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgcmV3YXJkVHlwZTogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoXG4gIG51bGxhYmxlKFxuICAgIHBpY2soe1xuICAgICAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICAgIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICAgIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICAgICAgdHJhbnNhY3Rpb25zOiBhcnJheShcbiAgICAgICAgcGljayh7XG4gICAgICAgICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgICAgICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgICAgICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICAgICAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gICAgICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpLFxuICAgIH0pLFxuICApLFxuKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYG5vbmVgXG4gKi9cbmNvbnN0IEdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KFxuICBudWxsYWJsZShcbiAgICBwaWNrKHtcbiAgICAgIGJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgICAgIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgICAgIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICAgICAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KFxuICBudWxsYWJsZShcbiAgICBwaWNrKHtcbiAgICAgIGJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgICAgIHRyYW5zYWN0aW9uczogYXJyYXkoXG4gICAgICAgIHBpY2soe1xuICAgICAgICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICAgICAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgICAgICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCksXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICAgIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgICAgIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICAgICAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KFxuICBudWxsYWJsZShcbiAgICBwaWNrKHtcbiAgICAgIGJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgICAgIHRyYW5zYWN0aW9uczogYXJyYXkoXG4gICAgICAgIHBpY2soe1xuICAgICAgICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICAgICAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgICAgICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCksXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICAgIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgICAgIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICAgICAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2UgIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoXG4gIG51bGxhYmxlKFxuICAgIHBpY2soe1xuICAgICAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICAgIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICAgIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICAgICAgdHJhbnNhY3Rpb25zOiBhcnJheShcbiAgICAgICAgcGljayh7XG4gICAgICAgICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgICAgICAgIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgICAgICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICAgICAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gICAgICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpLFxuICAgIH0pLFxuICApLFxuKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xuY29uc3QgR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoXG4gIG51bGxhYmxlKFxuICAgIHBpY2soe1xuICAgICAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICAgIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICAgIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICAgICAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICAgICAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gICAgICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpLFxuICAgIH0pLFxuICApLFxuKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkQmxvY2tcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRCbG9ja1JwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KFxuICBudWxsYWJsZShcbiAgICBwaWNrKHtcbiAgICAgIGJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgICAgIHRyYW5zYWN0aW9uczogYXJyYXkoXG4gICAgICAgIHBpY2soe1xuICAgICAgICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICAgICAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgICAgICB9KSxcbiAgICAgICksXG4gICAgICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gICAgICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KFxuICBudWxsYWJsZShcbiAgICBwaWNrKHtcbiAgICAgIGJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gICAgICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgICAgIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgICAgIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICAgIH0pLFxuICApLFxuKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VHJhbnNhY3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChcbiAgbnVsbGFibGUoXG4gICAgcGljayh7XG4gICAgICBzbG90OiBudW1iZXIoKSxcbiAgICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gICAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpLFxuICAgIH0pLFxuICApLFxuKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoXG4gIG51bGxhYmxlKFxuICAgIHBpY2soe1xuICAgICAgc2xvdDogbnVtYmVyKCksXG4gICAgICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgICAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICAgICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudEJsb2NraGFzaFwiIG1lc3NhZ2VcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFxuICBwaWNrKHtcbiAgICBibG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGZlZUNhbGN1bGF0b3I6IHBpY2soe1xuICAgICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IG51bWJlcigpLFxuICAgIH0pLFxuICB9KSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExhdGVzdEJsb2NraGFzaFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoXG4gIHBpY2soe1xuICAgIGJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IG51bWJlcigpLFxuICB9KSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImlzQmxvY2toYXNoVmFsaWRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChib29sZWFuKCkpO1xuXG5jb25zdCBQZXJmU2FtcGxlUmVzdWx0ID0gcGljayh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBudW1UcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICBudW1TbG90czogbnVtYmVyKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IG51bWJlcigpLFxufSk7XG5cbi8qXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgXCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoXG4gIGFycmF5KFBlcmZTYW1wbGVSZXN1bHQpLFxuKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFxuICBudWxsYWJsZShcbiAgICBwaWNrKHtcbiAgICAgIGZlZUNhbGN1bGF0b3I6IHBpY2soe1xuICAgICAgICBsYW1wb3J0c1BlclNpZ25hdHVyZTogbnVtYmVyKCksXG4gICAgICB9KSxcbiAgICB9KSxcbiAgKSxcbik7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJlcXVlc3RBaXJkcm9wXCIgbWVzc2FnZVxuICovXG5jb25zdCBSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzZW5kVHJhbnNhY3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBsYXRlc3Qgc2xvdCBiZWluZyBwcm9jZXNzZWQgYnkgYSBub2RlXG4gKi9cbmV4cG9ydCB0eXBlIFNsb3RJbmZvID0ge1xuICAvKiogQ3VycmVudGx5IHByb2Nlc3Npbmcgc2xvdCAqL1xuICBzbG90OiBudW1iZXI7XG4gIC8qKiBQYXJlbnQgb2YgdGhlIGN1cnJlbnQgc2xvdCAqL1xuICBwYXJlbnQ6IG51bWJlcjtcbiAgLyoqIFRoZSByb290IGJsb2NrIG9mIHRoZSBjdXJyZW50IHNsb3QncyBmb3JrICovXG4gIHJvb3Q6IG51bWJlcjtcbn07XG5cbi8qKlxuICogUGFyc2VkIGFjY291bnQgZGF0YVxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRBY2NvdW50RGF0YSA9IHtcbiAgLyoqIE5hbWUgb2YgdGhlIHByb2dyYW0gdGhhdCBvd25zIHRoaXMgYWNjb3VudCAqL1xuICBwcm9ncmFtOiBzdHJpbmc7XG4gIC8qKiBQYXJzZWQgYWNjb3VudCBkYXRhICovXG4gIHBhcnNlZDogYW55O1xuICAvKiogU3BhY2UgdXNlZCBieSBhY2NvdW50IGRhdGEgKi9cbiAgc3BhY2U6IG51bWJlcjtcbn07XG5cbi8qKlxuICogU3Rha2UgQWN0aXZhdGlvbiBkYXRhXG4gKi9cbmV4cG9ydCB0eXBlIFN0YWtlQWN0aXZhdGlvbkRhdGEgPSB7XG4gIC8qKiB0aGUgc3Rha2UgYWNjb3VudCdzIGFjdGl2YXRpb24gc3RhdGUgKi9cbiAgc3RhdGU6ICdhY3RpdmUnIHwgJ2luYWN0aXZlJyB8ICdhY3RpdmF0aW5nJyB8ICdkZWFjdGl2YXRpbmcnO1xuICAvKiogc3Rha2UgYWN0aXZlIGR1cmluZyB0aGUgZXBvY2ggKi9cbiAgYWN0aXZlOiBudW1iZXI7XG4gIC8qKiBzdGFrZSBpbmFjdGl2ZSBkdXJpbmcgdGhlIGVwb2NoICovXG4gIGluYWN0aXZlOiBudW1iZXI7XG59O1xuXG4vKipcbiAqIERhdGEgc2xpY2UgYXJndW1lbnQgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5leHBvcnQgdHlwZSBEYXRhU2xpY2UgPSB7XG4gIC8qKiBvZmZzZXQgb2YgZGF0YSBzbGljZSAqL1xuICBvZmZzZXQ6IG51bWJlcjtcbiAgLyoqIGxlbmd0aCBvZiBkYXRhIHNsaWNlICovXG4gIGxlbmd0aDogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBNZW1vcnkgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5leHBvcnQgdHlwZSBNZW1jbXBGaWx0ZXIgPSB7XG4gIG1lbWNtcDoge1xuICAgIC8qKiBvZmZzZXQgaW50byBwcm9ncmFtIGFjY291bnQgZGF0YSB0byBzdGFydCBjb21wYXJpc29uICovXG4gICAgb2Zmc2V0OiBudW1iZXI7XG4gIH0gJiAoXG4gICAgfCB7XG4gICAgICAgIGVuY29kaW5nPzogJ2Jhc2U1OCc7IC8vIEJhc2UtNTggaXMgdGhlIGRlZmF1bHQgd2hlbiBub3Qgc3VwcGxpZWQuXG4gICAgICAgIC8qKiBkYXRhIHRvIG1hdGNoLCBhcyBiYXNlLTU4IGVuY29kZWQgc3RyaW5nIGFuZCBsaW1pdGVkIHRvIGxlc3MgdGhhbiAxMjkgYnl0ZXMgKi9cbiAgICAgICAgYnl0ZXM6IHN0cmluZztcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnO1xuICAgICAgICAvKiogZGF0YSB0byBtYXRjaCwgYXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZyAqL1xuICAgICAgICBieXRlczogc3RyaW5nO1xuICAgICAgfVxuICApO1xufTtcblxuLyoqXG4gKiBEYXRhIHNpemUgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5leHBvcnQgdHlwZSBEYXRhU2l6ZUZpbHRlciA9IHtcbiAgLyoqIFNpemUgb2YgZGF0YSBmb3IgcHJvZ3JhbSBhY2NvdW50IGRhdGEgbGVuZ3RoIGNvbXBhcmlzb24gKi9cbiAgZGF0YVNpemU6IG51bWJlcjtcbn07XG5cbi8qKlxuICogQSBmaWx0ZXIgb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuZXhwb3J0IHR5cGUgR2V0UHJvZ3JhbUFjY291bnRzRmlsdGVyID0gTWVtY21wRmlsdGVyIHwgRGF0YVNpemVGaWx0ZXI7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGdldFByb2dyYW1BY2NvdW50cyByZXF1ZXN0c1xuICovXG5leHBvcnQgdHlwZSBHZXRQcm9ncmFtQWNjb3VudHNDb25maWcgPSB7XG4gIC8qKiBPcHRpb25hbCBjb21taXRtZW50IGxldmVsICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogT3B0aW9uYWwgZW5jb2RpbmcgZm9yIGFjY291bnQgZGF0YSAoZGVmYXVsdCBiYXNlNjQpXG4gICAqIFRvIHVzZSBcImpzb25QYXJzZWRcIiBlbmNvZGluZywgcGxlYXNlIHJlZmVyIHRvIGBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNgIGluIGNvbm5lY3Rpb24udHNcbiAgICogKi9cbiAgZW5jb2Rpbmc/OiAnYmFzZTY0JztcbiAgLyoqIE9wdGlvbmFsIGRhdGEgc2xpY2UgdG8gbGltaXQgdGhlIHJldHVybmVkIGFjY291bnQgZGF0YSAqL1xuICBkYXRhU2xpY2U/OiBEYXRhU2xpY2U7XG4gIC8qKiBPcHRpb25hbCBhcnJheSBvZiBmaWx0ZXJzIHRvIGFwcGx5IHRvIGFjY291bnRzICovXG4gIGZpbHRlcnM/OiBHZXRQcm9ncmFtQWNjb3VudHNGaWx0ZXJbXTtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xuICAvKiogd3JhcCB0aGUgcmVzdWx0IGluIGFuIFJwY1Jlc3BvbnNlIEpTT04gb2JqZWN0ICovXG4gIHdpdGhDb250ZXh0PzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlID0gcmVhZG9ubHkgUmVhZG9ubHk8e1xuICBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXI+O1xuICAvKiogdGhlIGFjY291bnQgUHVia2V5IGFzIGJhc2UtNTggZW5jb2RlZCBzdHJpbmcgKi9cbiAgcHVia2V5OiBQdWJsaWNLZXk7XG59PltdO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNcbiAqL1xuZXhwb3J0IHR5cGUgR2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzQ29uZmlnID0ge1xuICAvKiogT3B0aW9uYWwgY29tbWl0bWVudCBsZXZlbCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIE9wdGlvbmFsIGFycmF5IG9mIGZpbHRlcnMgdG8gYXBwbHkgdG8gYWNjb3VudHMgKi9cbiAgZmlsdGVycz86IEdldFByb2dyYW1BY2NvdW50c0ZpbHRlcltdO1xuICAvKiogVGhlIG1pbmltdW0gc2xvdCB0aGF0IHRoZSByZXF1ZXN0IGNhbiBiZSBldmFsdWF0ZWQgYXQgKi9cbiAgbWluQ29udGV4dFNsb3Q/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRNdWx0aXBsZUFjY291bnRzXG4gKi9cbmV4cG9ydCB0eXBlIEdldE11bHRpcGxlQWNjb3VudHNDb25maWcgPSB7XG4gIC8qKiBPcHRpb25hbCBjb21taXRtZW50IGxldmVsICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogVGhlIG1pbmltdW0gc2xvdCB0aGF0IHRoZSByZXF1ZXN0IGNhbiBiZSBldmFsdWF0ZWQgYXQgKi9cbiAgbWluQ29udGV4dFNsb3Q/OiBudW1iZXI7XG4gIC8qKiBPcHRpb25hbCBkYXRhIHNsaWNlIHRvIGxpbWl0IHRoZSByZXR1cm5lZCBhY2NvdW50IGRhdGEgKi9cbiAgZGF0YVNsaWNlPzogRGF0YVNsaWNlO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuZXhwb3J0IHR5cGUgR2V0U3Rha2VBY3RpdmF0aW9uQ29uZmlnID0ge1xuICAvKiogT3B0aW9uYWwgY29tbWl0bWVudCBsZXZlbCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIEVwb2NoIGZvciB3aGljaCB0byBjYWxjdWxhdGUgYWN0aXZhdGlvbiBkZXRhaWxzLiBJZiBwYXJhbWV0ZXIgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBjdXJyZW50IGVwb2NoICovXG4gIGVwb2NoPzogbnVtYmVyO1xuICAvKiogVGhlIG1pbmltdW0gc2xvdCB0aGF0IHRoZSByZXF1ZXN0IGNhbiBiZSBldmFsdWF0ZWQgYXQgKi9cbiAgbWluQ29udGV4dFNsb3Q/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5leHBvcnQgdHlwZSBHZXRUb2tlbkFjY291bnRzQnlPd25lckNvbmZpZyA9IHtcbiAgLyoqIE9wdGlvbmFsIGNvbW1pdG1lbnQgbGV2ZWwgKi9cbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKiBUaGUgbWluaW11bSBzbG90IHRoYXQgdGhlIHJlcXVlc3QgY2FuIGJlIGV2YWx1YXRlZCBhdCAqL1xuICBtaW5Db250ZXh0U2xvdD86IG51bWJlcjtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cbmV4cG9ydCB0eXBlIEdldFRyYW5zYWN0aW9uQ291bnRDb25maWcgPSB7XG4gIC8qKiBPcHRpb25hbCBjb21taXRtZW50IGxldmVsICovXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogVGhlIG1pbmltdW0gc2xvdCB0aGF0IHRoZSByZXF1ZXN0IGNhbiBiZSBldmFsdWF0ZWQgYXQgKi9cbiAgbWluQ29udGV4dFNsb3Q/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VgXG4gKi9cbmV4cG9ydCB0eXBlIEdldE5vbmNlQ29uZmlnID0ge1xuICAvKiogT3B0aW9uYWwgY29tbWl0bWVudCBsZXZlbCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldE5vbmNlQW5kQ29udGV4dGBcbiAqL1xuZXhwb3J0IHR5cGUgR2V0Tm9uY2VBbmRDb250ZXh0Q29uZmlnID0ge1xuICAvKiogT3B0aW9uYWwgY29tbWl0bWVudCBsZXZlbCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIFRoZSBtaW5pbXVtIHNsb3QgdGhhdCB0aGUgcmVxdWVzdCBjYW4gYmUgZXZhbHVhdGVkIGF0ICovXG4gIG1pbkNvbnRleHRTbG90PzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgQWNjb3VudFN1YnNjcmlwdGlvbkNvbmZpZyA9IFJlYWRvbmx5PHtcbiAgLyoqIE9wdGlvbmFsIGNvbW1pdG1lbnQgbGV2ZWwgKi9cbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIC8qKlxuICAgKiBFbmNvZGluZyBmb3JtYXQgZm9yIEFjY291bnQgZGF0YVxuICAgKiAgIC0gYGJhc2U1OGAgaXMgc2xvdy5cbiAgICogICAtIGBqc29uUGFyc2VkYCBlbmNvZGluZyBhdHRlbXB0cyB0byB1c2UgcHJvZ3JhbS1zcGVjaWZpYyBzdGF0ZSBwYXJzZXJzIHRvIHJldHVybiBtb3JlXG4gICAqICAgICAgaHVtYW4tcmVhZGFibGUgYW5kIGV4cGxpY2l0IGFjY291bnQgc3RhdGUgZGF0YVxuICAgKiAgIC0gSWYgYGpzb25QYXJzZWRgIGlzIHJlcXVlc3RlZCBidXQgYSBwYXJzZXIgY2Fubm90IGJlIGZvdW5kLCB0aGUgZmllbGQgZmFsbHMgYmFjayB0byBgYmFzZTY0YFxuICAgKiAgICAgZW5jb2RpbmcsIGRldGVjdGFibGUgd2hlbiB0aGUgYGRhdGFgIGZpZWxkIGlzIHR5cGUgYHN0cmluZ2AuXG4gICAqL1xuICBlbmNvZGluZz86ICdiYXNlNTgnIHwgJ2Jhc2U2NCcgfCAnYmFzZTY0K3pzdGQnIHwgJ2pzb25QYXJzZWQnO1xufT47XG5cbmV4cG9ydCB0eXBlIFByb2dyYW1BY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnID0gUmVhZG9ubHk8e1xuICAvKiogT3B0aW9uYWwgY29tbWl0bWVudCBsZXZlbCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqXG4gICAqIEVuY29kaW5nIGZvcm1hdCBmb3IgQWNjb3VudCBkYXRhXG4gICAqICAgLSBgYmFzZTU4YCBpcyBzbG93LlxuICAgKiAgIC0gYGpzb25QYXJzZWRgIGVuY29kaW5nIGF0dGVtcHRzIHRvIHVzZSBwcm9ncmFtLXNwZWNpZmljIHN0YXRlIHBhcnNlcnMgdG8gcmV0dXJuIG1vcmVcbiAgICogICAgICBodW1hbi1yZWFkYWJsZSBhbmQgZXhwbGljaXQgYWNjb3VudCBzdGF0ZSBkYXRhXG4gICAqICAgLSBJZiBganNvblBhcnNlZGAgaXMgcmVxdWVzdGVkIGJ1dCBhIHBhcnNlciBjYW5ub3QgYmUgZm91bmQsIHRoZSBmaWVsZCBmYWxscyBiYWNrIHRvIGBiYXNlNjRgXG4gICAqICAgICBlbmNvZGluZywgZGV0ZWN0YWJsZSB3aGVuIHRoZSBgZGF0YWAgZmllbGQgaXMgdHlwZSBgc3RyaW5nYC5cbiAgICovXG4gIGVuY29kaW5nPzogJ2Jhc2U1OCcgfCAnYmFzZTY0JyB8ICdiYXNlNjQrenN0ZCcgfCAnanNvblBhcnNlZCc7XG4gIC8qKlxuICAgKiBGaWx0ZXIgcmVzdWx0cyB1c2luZyB2YXJpb3VzIGZpbHRlciBvYmplY3RzXG4gICAqIFRoZSByZXN1bHRhbnQgYWNjb3VudCBtdXN0IG1lZXQgQUxMIGZpbHRlciBjcml0ZXJpYSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuZWQgcmVzdWx0c1xuICAgKi9cbiAgZmlsdGVycz86IEdldFByb2dyYW1BY2NvdW50c0ZpbHRlcltdO1xufT47XG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhbiBhY2NvdW50XG4gKi9cbmV4cG9ydCB0eXBlIEFjY291bnRJbmZvPFQ+ID0ge1xuICAvKiogYHRydWVgIGlmIHRoaXMgYWNjb3VudCdzIGRhdGEgY29udGFpbnMgYSBsb2FkZWQgcHJvZ3JhbSAqL1xuICBleGVjdXRhYmxlOiBib29sZWFuO1xuICAvKiogSWRlbnRpZmllciBvZiB0aGUgcHJvZ3JhbSB0aGF0IG93bnMgdGhlIGFjY291bnQgKi9cbiAgb3duZXI6IFB1YmxpY0tleTtcbiAgLyoqIE51bWJlciBvZiBsYW1wb3J0cyBhc3NpZ25lZCB0byB0aGUgYWNjb3VudCAqL1xuICBsYW1wb3J0czogbnVtYmVyO1xuICAvKiogT3B0aW9uYWwgZGF0YSBhc3NpZ25lZCB0byB0aGUgYWNjb3VudCAqL1xuICBkYXRhOiBUO1xuICAvKiogT3B0aW9uYWwgcmVudCBlcG9jaCBpbmZvIGZvciBhY2NvdW50ICovXG4gIHJlbnRFcG9jaD86IG51bWJlcjtcbn07XG5cbi8qKlxuICogQWNjb3VudCBpbmZvcm1hdGlvbiBpZGVudGlmaWVkIGJ5IHB1YmtleVxuICovXG5leHBvcnQgdHlwZSBLZXllZEFjY291bnRJbmZvID0ge1xuICBhY2NvdW50SWQ6IFB1YmxpY0tleTtcbiAgYWNjb3VudEluZm86IEFjY291bnRJbmZvPEJ1ZmZlcj47XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIEFjY291bnRDaGFuZ2VDYWxsYmFjayA9IChcbiAgYWNjb3VudEluZm86IEFjY291bnRJbmZvPEJ1ZmZlcj4sXG4gIGNvbnRleHQ6IENvbnRleHQsXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHByb2dyYW0gYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5leHBvcnQgdHlwZSBQcm9ncmFtQWNjb3VudENoYW5nZUNhbGxiYWNrID0gKFxuICBrZXllZEFjY291bnRJbmZvOiBLZXllZEFjY291bnRJbmZvLFxuICBjb250ZXh0OiBDb250ZXh0LFxuKSA9PiB2b2lkO1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIFNsb3RDaGFuZ2VDYWxsYmFjayA9IChzbG90SW5mbzogU2xvdEluZm8pID0+IHZvaWQ7XG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgU2xvdFVwZGF0ZUNhbGxiYWNrID0gKHNsb3RVcGRhdGU6IFNsb3RVcGRhdGUpID0+IHZvaWQ7XG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBzdGF0dXMgbm90aWZpY2F0aW9uc1xuICovXG5leHBvcnQgdHlwZSBTaWduYXR1cmVSZXN1bHRDYWxsYmFjayA9IChcbiAgc2lnbmF0dXJlUmVzdWx0OiBTaWduYXR1cmVSZXN1bHQsXG4gIGNvbnRleHQ6IENvbnRleHQsXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb24gd2l0aCB0cmFuc2FjdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IHR5cGUgU2lnbmF0dXJlU3RhdHVzTm90aWZpY2F0aW9uID0ge1xuICB0eXBlOiAnc3RhdHVzJztcbiAgcmVzdWx0OiBTaWduYXR1cmVSZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNpZ25hdHVyZSByZWNlaXZlZCBub3RpZmljYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgU2lnbmF0dXJlUmVjZWl2ZWROb3RpZmljYXRpb24gPSB7XG4gIHR5cGU6ICdyZWNlaXZlZCc7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICovXG5leHBvcnQgdHlwZSBTaWduYXR1cmVTdWJzY3JpcHRpb25DYWxsYmFjayA9IChcbiAgbm90aWZpY2F0aW9uOiBTaWduYXR1cmVTdGF0dXNOb3RpZmljYXRpb24gfCBTaWduYXR1cmVSZWNlaXZlZE5vdGlmaWNhdGlvbixcbiAgY29udGV4dDogQ29udGV4dCxcbikgPT4gdm9pZDtcblxuLyoqXG4gKiBTaWduYXR1cmUgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgU2lnbmF0dXJlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IHtcbiAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gIGVuYWJsZVJlY2VpdmVkTm90aWZpY2F0aW9uPzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHJvb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgUm9vdENoYW5nZUNhbGxiYWNrID0gKHJvb3Q6IG51bWJlcikgPT4gdm9pZDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9nc1Jlc3VsdCA9IHBpY2soe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGxvZ3M6IGFycmF5KHN0cmluZygpKSxcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbn0pO1xuXG4vKipcbiAqIExvZ3MgcmVzdWx0LlxuICovXG5leHBvcnQgdHlwZSBMb2dzID0ge1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3IgfCBudWxsO1xuICBsb2dzOiBzdHJpbmdbXTtcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJsb2dzTm90aWZpY2F0aW9uXCIgbWVzc2FnZS5cbiAqL1xuY29uc3QgTG9nc05vdGlmaWNhdGlvblJlc3VsdCA9IHBpY2soe1xuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoTG9nc1Jlc3VsdCksXG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG59KTtcblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxvZyBzdWJzY3JpcHRpb25zLlxuICovXG5leHBvcnQgdHlwZSBMb2dzRmlsdGVyID0gUHVibGljS2V5IHwgJ2FsbCcgfCAnYWxsV2l0aFZvdGVzJztcblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbG9nIG5vdGlmaWNhdGlvbnMuXG4gKi9cbmV4cG9ydCB0eXBlIExvZ3NDYWxsYmFjayA9IChsb2dzOiBMb2dzLCBjdHg6IENvbnRleHQpID0+IHZvaWQ7XG5cbi8qKlxuICogU2lnbmF0dXJlIHJlc3VsdFxuICovXG5leHBvcnQgdHlwZSBTaWduYXR1cmVSZXN1bHQgPSB7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvciB8IG51bGw7XG59O1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGVycm9yXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uRXJyb3IgPSB7fSB8IHN0cmluZztcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RhdHVzXG4gKiA8cHJlPlxuICogICAncHJvY2Vzc2VkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNvbm5lY3RlZCBub2RlXG4gKiAgICdjb25maXJtZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdGF0dXMgPVxuICB8ICdwcm9jZXNzZWQnXG4gIHwgJ2NvbmZpcm1lZCdcbiAgfCAnZmluYWxpemVkJztcblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzXG4gKi9cbmV4cG9ydCB0eXBlIFNpZ25hdHVyZVN0YXR1cyA9IHtcbiAgLyoqIHdoZW4gdGhlIHRyYW5zYWN0aW9uIHdhcyBwcm9jZXNzZWQgKi9cbiAgc2xvdDogbnVtYmVyO1xuICAvKiogdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBoYXZlIGJlZW4gY29uZmlybWVkIGFuZCB2b3RlZCBvbiBpbiB0aGUgZm9yayBjb250YWluaW5nIGBzbG90YCAqL1xuICBjb25maXJtYXRpb25zOiBudW1iZXIgfCBudWxsO1xuICAvKiogdHJhbnNhY3Rpb24gZXJyb3IsIGlmIGFueSAqL1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3IgfCBudWxsO1xuICAvKiogY2x1c3RlciBjb25maXJtYXRpb24gc3RhdHVzLCBpZiBkYXRhIGF2YWlsYWJsZS4gUG9zc2libGUgcmVzcG9uc2VzOiBgcHJvY2Vzc2VkYCwgYGNvbmZpcm1lZGAsIGBmaW5hbGl6ZWRgICovXG4gIGNvbmZpcm1hdGlvblN0YXR1cz86IFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RhdHVzO1xufTtcblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBzaWduYXR1cmUgd2l0aCBpdHMgc3RhdHVzXG4gKi9cbmV4cG9ydCB0eXBlIENvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSB7XG4gIC8qKiB0aGUgdHJhbnNhY3Rpb24gc2lnbmF0dXJlICovXG4gIHNpZ25hdHVyZTogc3RyaW5nO1xuICAvKiogd2hlbiB0aGUgdHJhbnNhY3Rpb24gd2FzIHByb2Nlc3NlZCAqL1xuICBzbG90OiBudW1iZXI7XG4gIC8qKiBlcnJvciwgaWYgYW55ICovXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvciB8IG51bGw7XG4gIC8qKiBtZW1vIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJhbnNhY3Rpb24sIGlmIGFueSAqL1xuICBtZW1vOiBzdHJpbmcgfCBudWxsO1xuICAvKiogVGhlIHVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRyYW5zYWN0aW9uIHdhcyBwcm9jZXNzZWQgKi9cbiAgYmxvY2tUaW1lPzogbnVtYmVyIHwgbnVsbDtcbiAgLyoqIENsdXN0ZXIgY29uZmlybWF0aW9uIHN0YXR1cywgaWYgYXZhaWxhYmxlLiBQb3NzaWJsZSB2YWx1ZXM6IGBwcm9jZXNzZWRgLCBgY29uZmlybWVkYCwgYGZpbmFsaXplZGAgKi9cbiAgY29uZmlybWF0aW9uU3RhdHVzPzogVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdGF0dXM7XG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCBkZWZpbmluZyBoZWFkZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgUlBDIHNlcnZlclxuICovXG5leHBvcnQgdHlwZSBIdHRwSGVhZGVycyA9IHtcbiAgW2hlYWRlcjogc3RyaW5nXTogc3RyaW5nO1xufSAmIHtcbiAgLy8gUHJvaGliaXRlZCBoZWFkZXJzOyBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICdzb2xhbmEtY2xpZW50Jz86IG5ldmVyO1xufTtcblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgSmF2YVNjcmlwdCBgZmV0Y2goKWAgQVBJXG4gKi9cbmV4cG9ydCB0eXBlIEZldGNoRm4gPSB0eXBlb2YgZmV0Y2hJbXBsO1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgdXNlZCB0byBhdWdtZW50IHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAqL1xuZXhwb3J0IHR5cGUgRmV0Y2hNaWRkbGV3YXJlID0gKFxuICBpbmZvOiBQYXJhbWV0ZXJzPEZldGNoRm4+WzBdLFxuICBpbml0OiBQYXJhbWV0ZXJzPEZldGNoRm4+WzFdLFxuICBmZXRjaDogKC4uLmE6IFBhcmFtZXRlcnM8RmV0Y2hGbj4pID0+IHZvaWQsXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgaW5zdGFudGlhdGluZyBhIENvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IHR5cGUgQ29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgLyoqXG4gICAqIEFuIGBodHRwLkFnZW50YCB0aGF0IHdpbGwgYmUgdXNlZCB0byBtYW5hZ2Ugc29ja2V0IGNvbm5lY3Rpb25zIChlZy4gdG8gaW1wbGVtZW50IGNvbm5lY3Rpb25cbiAgICogcGVyc2lzdGVuY2UpLiBTZXQgdGhpcyB0byBgZmFsc2VgIHRvIGNyZWF0ZSBhIGNvbm5lY3Rpb24gdGhhdCB1c2VzIG5vIGFnZW50LiBUaGlzIGFwcGxpZXMgdG9cbiAgICogTm9kZSBlbnZpcm9ubWVudHMgb25seS5cbiAgICovXG4gIGh0dHBBZ2VudD86IE5vZGVIdHRwQWdlbnQgfCBOb2RlSHR0cHNBZ2VudCB8IGZhbHNlO1xuICAvKiogT3B0aW9uYWwgY29tbWl0bWVudCBsZXZlbCAqL1xuICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgLyoqIE9wdGlvbmFsIGVuZHBvaW50IFVSTCB0byB0aGUgZnVsbG5vZGUgSlNPTiBSUEMgUHViU3ViIFdlYlNvY2tldCBFbmRwb2ludCAqL1xuICB3c0VuZHBvaW50Pzogc3RyaW5nO1xuICAvKiogT3B0aW9uYWwgSFRUUCBoZWFkZXJzIG9iamVjdCAqL1xuICBodHRwSGVhZGVycz86IEh0dHBIZWFkZXJzO1xuICAvKiogT3B0aW9uYWwgY3VzdG9tIGZldGNoIGZ1bmN0aW9uICovXG4gIGZldGNoPzogRmV0Y2hGbjtcbiAgLyoqIE9wdGlvbmFsIGZldGNoIG1pZGRsZXdhcmUgY2FsbGJhY2sgKi9cbiAgZmV0Y2hNaWRkbGV3YXJlPzogRmV0Y2hNaWRkbGV3YXJlO1xuICAvKiogT3B0aW9uYWwgRGlzYWJsZSByZXRyeWluZyBjYWxscyB3aGVuIHNlcnZlciByZXNwb25kcyB3aXRoIEhUVFAgNDI5IChUb28gTWFueSBSZXF1ZXN0cykgKi9cbiAgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ/OiBib29sZWFuO1xuICAvKiogdGltZSB0byBhbGxvdyBmb3IgdGhlIHNlcnZlciB0byBpbml0aWFsbHkgcHJvY2VzcyBhIHRyYW5zYWN0aW9uIChpbiBtaWxsaXNlY29uZHMpICovXG4gIGNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0PzogbnVtYmVyO1xufTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgQ09NTU9OX0hUVFBfSEVBREVSUyA9IHtcbiAgJ3NvbGFuYS1jbGllbnQnOiBganMvJHtwcm9jZXNzLmVudi5ucG1fcGFja2FnZV92ZXJzaW9uID8/ICdVTktOT1dOJ31gLFxufTtcblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gYSBmdWxsbm9kZSBKU09OIFJQQyBlbmRwb2ludFxuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvbiB7XG4gIC8qKiBAaW50ZXJuYWwgKi8gX2NvbW1pdG1lbnQ/OiBDb21taXRtZW50O1xuICAvKiogQGludGVybmFsICovIF9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dD86IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqLyBfcnBjRW5kcG9pbnQ6IHN0cmluZztcbiAgLyoqIEBpbnRlcm5hbCAqLyBfcnBjV3NFbmRwb2ludDogc3RyaW5nO1xuICAvKiogQGludGVybmFsICovIF9ycGNDbGllbnQ6IFJwY0NsaWVudDtcbiAgLyoqIEBpbnRlcm5hbCAqLyBfcnBjUmVxdWVzdDogUnBjUmVxdWVzdDtcbiAgLyoqIEBpbnRlcm5hbCAqLyBfcnBjQmF0Y2hSZXF1ZXN0OiBScGNCYXRjaFJlcXVlc3Q7XG4gIC8qKiBAaW50ZXJuYWwgKi8gX3JwY1dlYlNvY2tldDogUnBjV2ViU29ja2V0Q2xpZW50O1xuICAvKiogQGludGVybmFsICovIF9ycGNXZWJTb2NrZXRDb25uZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLyoqIEBpbnRlcm5hbCAqLyBfcnBjV2ViU29ja2V0SGVhcnRiZWF0OiBSZXR1cm5UeXBlPFxuICAgIHR5cGVvZiBzZXRJbnRlcnZhbFxuICA+IHwgbnVsbCA9IG51bGw7XG4gIC8qKiBAaW50ZXJuYWwgKi8gX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0OiBSZXR1cm5UeXBlPFxuICAgIHR5cGVvZiBzZXRUaW1lb3V0XG4gID4gfCBudWxsID0gbnVsbDtcbiAgLyoqIEBpbnRlcm5hbFxuICAgKiBBIG51bWJlciB0aGF0IHdlIGluY3JlbWVudCBldmVyeSB0aW1lIGFuIGFjdGl2ZSBjb25uZWN0aW9uIGNsb3Nlcy5cbiAgICogVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2FtZSBzb2NrZXQgY29ubmVjdGlvbiB0aGF0IHdhcyBvcGVuXG4gICAqIHdoZW4gYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgaXMgdGhlIHNhbWUgb25lIHRoYXQncyBhY3RpdmUgd2hlblxuICAgKiBpdHMgY29udGludWF0aW9uIGZpcmVzLlxuICAgKlxuICAgKi8gcHJpdmF0ZSBfcnBjV2ViU29ja2V0R2VuZXJhdGlvbjogbnVtYmVyID0gMDtcblxuICAvKiogQGludGVybmFsICovIF9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAvKiogQGludGVybmFsICovIF9wb2xsaW5nQmxvY2toYXNoOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKiBAaW50ZXJuYWwgKi8gX2Jsb2NraGFzaEluZm86IHtcbiAgICBsYXRlc3RCbG9ja2hhc2g6IEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodCB8IG51bGw7XG4gICAgbGFzdEZldGNoOiBudW1iZXI7XG4gICAgc2ltdWxhdGVkU2lnbmF0dXJlczogQXJyYXk8c3RyaW5nPjtcbiAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IEFycmF5PHN0cmluZz47XG4gIH0gPSB7XG4gICAgbGF0ZXN0QmxvY2toYXNoOiBudWxsLFxuICAgIGxhc3RGZXRjaDogMCxcbiAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdLFxuICB9O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi8gcHJpdmF0ZSBfbmV4dENsaWVudFN1YnNjcmlwdGlvbklkOiBDbGllbnRTdWJzY3JpcHRpb25JZCA9IDA7XG4gIC8qKiBAaW50ZXJuYWwgKi8gcHJpdmF0ZSBfc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQ6IHtcbiAgICBbY2xpZW50U3Vic2NyaXB0aW9uSWQ6IENsaWVudFN1YnNjcmlwdGlvbklkXTpcbiAgICAgIHwgU3Vic2NyaXB0aW9uRGlzcG9zZUZuXG4gICAgICB8IHVuZGVmaW5lZDtcbiAgfSA9IHt9O1xuICAvKiogQGludGVybmFsICovIHByaXZhdGUgX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkOiB7XG4gICAgW2NsaWVudFN1YnNjcmlwdGlvbklkOiBDbGllbnRTdWJzY3JpcHRpb25JZF06XG4gICAgICB8IFN1YnNjcmlwdGlvbkNvbmZpZ0hhc2hcbiAgICAgIHwgdW5kZWZpbmVkO1xuICB9ID0ge307XG4gIC8qKiBAaW50ZXJuYWwgKi8gcHJpdmF0ZSBfc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2g6IHtcbiAgICBbaGFzaDogU3Vic2NyaXB0aW9uQ29uZmlnSGFzaF06XG4gICAgICB8IFNldDxTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrPlxuICAgICAgfCB1bmRlZmluZWQ7XG4gIH0gPSB7fTtcbiAgLyoqIEBpbnRlcm5hbCAqLyBwcml2YXRlIF9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkOiB7XG4gICAgW3NlcnZlclN1YnNjcmlwdGlvbklkOiBTZXJ2ZXJTdWJzY3JpcHRpb25JZF06XG4gICAgICB8IFNldDxTdWJzY3JpcHRpb25Db25maWdbJ2NhbGxiYWNrJ10+XG4gICAgICB8IHVuZGVmaW5lZDtcbiAgfSA9IHt9O1xuICAvKiogQGludGVybmFsICovIHByaXZhdGUgX3N1YnNjcmlwdGlvbnNCeUhhc2g6IHtcbiAgICBbaGFzaDogU3Vic2NyaXB0aW9uQ29uZmlnSGFzaF06IFN1YnNjcmlwdGlvbiB8IHVuZGVmaW5lZDtcbiAgfSA9IHt9O1xuICAvKipcbiAgICogU3BlY2lhbCBjYXNlLlxuICAgKiBBZnRlciBhIHNpZ25hdHVyZSBpcyBwcm9jZXNzZWQsIFJQQ3MgYXV0b21hdGljYWxseSBkaXNwb3NlIG9mIHRoZVxuICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgKiB3aGV0aGVyIHRoZSBjbGllbnQgaXMgZGVhbGluZyB3aXRoIGEgbm90LXlldC1wcm9jZXNzZWQgc2lnbmF0dXJlXG4gICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAqIGNsZWFyIG91dCB0aGUgc3Vic2NyaXB0aW9uIGxvY2FsbHkgd2l0aG91dCB0ZWxsaW5nIHRoZSBzZXJ2ZXIpLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICovXG4gIC8qKiBAaW50ZXJuYWwgKi8gcHJpdmF0ZSBfc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjOiBTZXQ8U2VydmVyU3Vic2NyaXB0aW9uSWQ+ID1cbiAgICBuZXcgU2V0KCk7XG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaCBhIEpTT04gUlBDIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGVuZHBvaW50IFVSTCB0byB0aGUgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnRPckNvbmZpZyBvcHRpb25hbCBkZWZhdWx0IGNvbW1pdG1lbnQgbGV2ZWwgb3Igb3B0aW9uYWwgQ29ubmVjdGlvbkNvbmZpZyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgQ29ubmVjdGlvbkNvbmZpZyxcbiAgKSB7XG4gICAgbGV0IHdzRW5kcG9pbnQ7XG4gICAgbGV0IGh0dHBIZWFkZXJzO1xuICAgIGxldCBmZXRjaDtcbiAgICBsZXQgZmV0Y2hNaWRkbGV3YXJlO1xuICAgIGxldCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICBsZXQgaHR0cEFnZW50O1xuICAgIGlmIChjb21taXRtZW50T3JDb25maWcgJiYgdHlwZW9mIGNvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBjb21taXRtZW50T3JDb25maWc7XG4gICAgfSBlbHNlIGlmIChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBjb21taXRtZW50T3JDb25maWcuY29tbWl0bWVudDtcbiAgICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID1cbiAgICAgICAgY29tbWl0bWVudE9yQ29uZmlnLmNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0O1xuICAgICAgd3NFbmRwb2ludCA9IGNvbW1pdG1lbnRPckNvbmZpZy53c0VuZHBvaW50O1xuICAgICAgaHR0cEhlYWRlcnMgPSBjb21taXRtZW50T3JDb25maWcuaHR0cEhlYWRlcnM7XG4gICAgICBmZXRjaCA9IGNvbW1pdG1lbnRPckNvbmZpZy5mZXRjaDtcbiAgICAgIGZldGNoTWlkZGxld2FyZSA9IGNvbW1pdG1lbnRPckNvbmZpZy5mZXRjaE1pZGRsZXdhcmU7XG4gICAgICBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9IGNvbW1pdG1lbnRPckNvbmZpZy5kaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICAgIGh0dHBBZ2VudCA9IGNvbW1pdG1lbnRPckNvbmZpZy5odHRwQWdlbnQ7XG4gICAgfVxuXG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSBhc3NlcnRFbmRwb2ludFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHdzRW5kcG9pbnQgfHwgbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCk7XG5cbiAgICB0aGlzLl9ycGNDbGllbnQgPSBjcmVhdGVScGNDbGllbnQoXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGh0dHBIZWFkZXJzLFxuICAgICAgZmV0Y2gsXG4gICAgICBmZXRjaE1pZGRsZXdhcmUsXG4gICAgICBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCxcbiAgICAgIGh0dHBBZ2VudCxcbiAgICApO1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSBjcmVhdGVScGNSZXF1ZXN0KHRoaXMuX3JwY0NsaWVudCk7XG4gICAgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0ID0gY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0KHRoaXMuX3JwY0NsaWVudCk7XG5cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSBuZXcgUnBjV2ViU29ja2V0Q2xpZW50KHRoaXMuX3JwY1dzRW5kcG9pbnQsIHtcbiAgICAgIGF1dG9jb25uZWN0OiBmYWxzZSxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiBJbmZpbml0eSxcbiAgICB9KTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ29wZW4nLCB0aGlzLl93c09uT3Blbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Vycm9yJywgdGhpcy5fd3NPbkVycm9yLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignY2xvc2UnLCB0aGlzLl93c09uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKFxuICAgICAgJ2FjY291bnROb3RpZmljYXRpb24nLFxuICAgICAgdGhpcy5fd3NPbkFjY291bnROb3RpZmljYXRpb24uYmluZCh0aGlzKSxcbiAgICApO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbihcbiAgICAgICdwcm9ncmFtTm90aWZpY2F0aW9uJyxcbiAgICAgIHRoaXMuX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpLFxuICAgICk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKFxuICAgICAgJ3Nsb3ROb3RpZmljYXRpb24nLFxuICAgICAgdGhpcy5fd3NPblNsb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSxcbiAgICApO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbihcbiAgICAgICdzbG90c1VwZGF0ZXNOb3RpZmljYXRpb24nLFxuICAgICAgdGhpcy5fd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uLmJpbmQodGhpcyksXG4gICAgKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oXG4gICAgICAnc2lnbmF0dXJlTm90aWZpY2F0aW9uJyxcbiAgICAgIHRoaXMuX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24uYmluZCh0aGlzKSxcbiAgICApO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbihcbiAgICAgICdyb290Tm90aWZpY2F0aW9uJyxcbiAgICAgIHRoaXMuX3dzT25Sb290Tm90aWZpY2F0aW9uLmJpbmQodGhpcyksXG4gICAgKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oXG4gICAgICAnbG9nc05vdGlmaWNhdGlvbicsXG4gICAgICB0aGlzLl93c09uTG9nc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29tbWl0bWVudCB1c2VkIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGNvbW1pdG1lbnQoKTogQ29tbWl0bWVudCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1pdG1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFJQQyBlbmRwb2ludFxuICAgKi9cbiAgZ2V0IHJwY0VuZHBvaW50KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3JwY0VuZHBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXksIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2VBbmRDb250ZXh0KFxuICAgIHB1YmxpY0tleTogUHVibGljS2V5LFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRCYWxhbmNlQ29uZmlnLFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxudW1iZXI+PiB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbcHVibGljS2V5LnRvQmFzZTU4KCldLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLyxcbiAgICAgIGNvbmZpZyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICBgZmFpbGVkIHRvIGdldCBiYWxhbmNlIGZvciAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlKFxuICAgIHB1YmxpY0tleTogUHVibGljS2V5LFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRCYWxhbmNlQ29uZmlnLFxuICApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEJhbGFuY2VBbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKVxuICAgICAgLnRoZW4oeCA9PiB4LnZhbHVlKVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ZhaWxlZCB0byBnZXQgYmFsYW5jZSBvZiBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVzdGltYXRlZCBwcm9kdWN0aW9uIHRpbWUgb2YgYSBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tUaW1lKHNsb3Q6IG51bWJlcik6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrVGltZScsIFtzbG90XSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudWxsYWJsZShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoXG4gICAgICAgIHJlcy5lcnJvcixcbiAgICAgICAgYGZhaWxlZCB0byBnZXQgYmxvY2sgdGltZSBmb3Igc2xvdCAke3Nsb3R9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsb3dlc3Qgc2xvdCB0aGF0IHRoZSBub2RlIGhhcyBpbmZvcm1hdGlvbiBhYm91dCBpbiBpdHMgbGVkZ2VyLlxuICAgKiBUaGlzIHZhbHVlIG1heSBpbmNyZWFzZSBvdmVyIHRpbWUgaWYgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB0byBwdXJnZSBvbGRlciBsZWRnZXIgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUxlZGdlclNsb3QoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdtaW5pbXVtTGVkZ2VyU2xvdCcsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgICdmYWlsZWQgdG8gZ2V0IG1pbmltdW0gbGVkZ2VyIHNsb3QnLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNsb3Qgb2YgdGhlIGxvd2VzdCBjb25maXJtZWQgYmxvY2sgdGhhdCBoYXMgbm90IGJlZW4gcHVyZ2VkIGZyb20gdGhlIGxlZGdlclxuICAgKi9cbiAgYXN5bmMgZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZpcnN0QXZhaWxhYmxlQmxvY2snLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2xvdFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgICdmYWlsZWQgdG8gZ2V0IGZpcnN0IGF2YWlsYWJsZSBibG9jaycsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBzdXBwbHlcbiAgICovXG4gIGFzeW5jIGdldFN1cHBseShcbiAgICBjb25maWc/OiBHZXRTdXBwbHlDb25maWcgfCBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTdXBwbHk+PiB7XG4gICAgbGV0IGNvbmZpZ0FyZzogR2V0U3VwcGx5Q29uZmlnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWdBcmcgPSB7Y29tbWl0bWVudDogY29uZmlnfTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGNvbW1pdG1lbnQ6IChjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQpIHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdXBwbHknLCBbY29uZmlnQXJnXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U3VwcGx5UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4gbWludFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5TdXBwbHkoXG4gICAgdG9rZW5NaW50QWRkcmVzczogUHVibGljS2V5LFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxUb2tlbkFtb3VudD4+IHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbk1pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlblN1cHBseScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgYSB0b2tlbiBhY2NvdW50XG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkFjY291bnRCYWxhbmNlKFxuICAgIHRva2VuQWRkcmVzczogUHVibGljS2V5LFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxUb2tlbkFtb3VudD4+IHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbkFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChUb2tlbkFtb3VudFJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICAnZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50IGJhbGFuY2UnLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIoXG4gICAgb3duZXJBZGRyZXNzOiBQdWJsaWNLZXksXG4gICAgZmlsdGVyOiBUb2tlbkFjY291bnRzRmlsdGVyLFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRUb2tlbkFjY291bnRzQnlPd25lckNvbmZpZyxcbiAgKTogUHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+PiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IF9hcmdzOiBhbnlbXSA9IFtvd25lckFkZHJlc3MudG9CYXNlNTgoKV07XG4gICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgIF9hcmdzLnB1c2goe21pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KCl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FyZ3MucHVzaCh7cHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KCl9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoXG4gICAgICAgIHJlcy5lcnJvcixcbiAgICAgICAgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88UGFyc2VkQWNjb3VudERhdGE+fT4+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyKFxuICAgIG93bmVyQWRkcmVzczogUHVibGljS2V5LFxuICAgIGZpbHRlcjogVG9rZW5BY2NvdW50c0ZpbHRlcixcbiAgICBjb21taXRtZW50PzogQ29tbWl0bWVudCxcbiAgKTogUHJvbWlzZTxcbiAgICBScGNSZXNwb25zZUFuZENvbnRleHQ8XG4gICAgICBBcnJheTx7cHVia2V5OiBQdWJsaWNLZXk7IGFjY291bnQ6IEFjY291bnRJbmZvPFBhcnNlZEFjY291bnREYXRhPn0+XG4gICAgPlxuICA+IHtcbiAgICBsZXQgX2FyZ3M6IGFueVtdID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7bWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtwcm9ncmFtSWQ6IGZpbHRlci5wcm9ncmFtSWQudG9CYXNlNTgoKX0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoX2FyZ3MsIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgIGBmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnRzIG93bmVkIGJ5IGFjY291bnQgJHtvd25lckFkZHJlc3MudG9CYXNlNTgoKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRMYXJnZXN0QWNjb3VudHMoXG4gICAgY29uZmlnPzogR2V0TGFyZ2VzdEFjY291bnRzQ29uZmlnLFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxBcnJheTxBY2NvdW50QmFsYW5jZVBhaXI+Pj4ge1xuICAgIGNvbnN0IGFyZyA9IHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGNvbW1pdG1lbnQ6IChjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQpIHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSBhcmcuZmlsdGVyIHx8IGFyZy5jb21taXRtZW50ID8gW2FyZ10gOiBbXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMYXJnZXN0QWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxhcmdlc3QgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgdG9rZW4gYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqIGZvciBhIGdpdmVuIG1pbnQuXG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkxhcmdlc3RBY2NvdW50cyhcbiAgICBtaW50QWRkcmVzczogUHVibGljS2V5LFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxBcnJheTxUb2tlbkFjY291bnRCYWxhbmNlUGFpcj4+PiB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbbWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuTGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICAnZmFpbGVkIHRvIGdldCB0b2tlbiBsYXJnZXN0IGFjY291bnRzJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXksIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRJbmZvQW5kQ29udGV4dChcbiAgICBwdWJsaWNLZXk6IFB1YmxpY0tleSxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgR2V0QWNjb3VudEluZm9Db25maWcsXG4gICk6IFByb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFjY291bnRJbmZvPEJ1ZmZlcj4gfCBudWxsPj4ge1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbcHVibGljS2V5LnRvQmFzZTU4KCldLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgICdiYXNlNjQnLFxuICAgICAgY29uZmlnLFxuICAgICk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUoXG4gICAgICB1bnNhZmVSZXMsXG4gICAgICBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpLFxuICAgICk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgIGBmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZEFjY291bnRJbmZvKFxuICAgIHB1YmxpY0tleTogUHVibGljS2V5LFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRBY2NvdW50SW5mb0NvbmZpZyxcbiAgKTogUHJvbWlzZTxcbiAgICBScGNSZXNwb25zZUFuZENvbnRleHQ8QWNjb3VudEluZm88QnVmZmVyIHwgUGFyc2VkQWNjb3VudERhdGE+IHwgbnVsbD5cbiAgPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhcbiAgICAgIFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sXG4gICAgICBjb21taXRtZW50LFxuICAgICAgJ2pzb25QYXJzZWQnLFxuICAgICAgY29uZmlnLFxuICAgICk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUoXG4gICAgICB1bnNhZmVSZXMsXG4gICAgICBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpLFxuICAgICk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgIGBmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mbyhcbiAgICBwdWJsaWNLZXk6IFB1YmxpY0tleSxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgR2V0QWNjb3VudEluZm9Db25maWcsXG4gICk6IFByb21pc2U8QWNjb3VudEluZm88QnVmZmVyPiB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQoXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgY29tbWl0bWVudE9yQ29uZmlnLFxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIGUsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzKFxuICAgIHB1YmxpY0tleXM6IFB1YmxpY0tleVtdLFxuICAgIHJhd0NvbmZpZz86IEdldE11bHRpcGxlQWNjb3VudHNDb25maWcsXG4gICk6IFByb21pc2U8XG4gICAgUnBjUmVzcG9uc2VBbmRDb250ZXh0PChBY2NvdW50SW5mbzxCdWZmZXIgfCBQYXJzZWRBY2NvdW50RGF0YT4gfCBudWxsKVtdPlxuICA+IHtcbiAgICBjb25zdCB7Y29tbWl0bWVudCwgY29uZmlnfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZShcbiAgICAgIHVuc2FmZVJlcyxcbiAgICAgIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpLFxuICAgICk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgIGBmYWlsZWQgdG8gZ2V0IGluZm8gZm9yIGFjY291bnRzICR7a2V5c31gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KFxuICAgIHB1YmxpY0tleXM6IFB1YmxpY0tleVtdLFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRNdWx0aXBsZUFjY291bnRzQ29uZmlnLFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDwoQWNjb3VudEluZm88QnVmZmVyPiB8IG51bGwpW10+PiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3Qga2V5cyA9IHB1YmxpY0tleXMubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhba2V5c10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUoXG4gICAgICB1bnNhZmVSZXMsXG4gICAgICBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpKSxcbiAgICApO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXNcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvKFxuICAgIHB1YmxpY0tleXM6IFB1YmxpY0tleVtdLFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRNdWx0aXBsZUFjY291bnRzQ29uZmlnLFxuICApOiBQcm9taXNlPChBY2NvdW50SW5mbzxCdWZmZXI+IHwgbnVsbClbXT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KFxuICAgICAgcHVibGljS2V5cyxcbiAgICAgIGNvbW1pdG1lbnRPckNvbmZpZyxcbiAgICApO1xuICAgIHJldHVybiByZXMudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlcG9jaCBhY3RpdmF0aW9uIGluZm9ybWF0aW9uIGZvciBhIHN0YWtlIGFjY291bnQgdGhhdCBoYXMgYmVlbiBkZWxlZ2F0ZWRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuMTg7IHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VBY3RpdmF0aW9uKFxuICAgIHB1YmxpY0tleTogUHVibGljS2V5LFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRTdGFrZUFjdGl2YXRpb25Db25maWcsXG4gICAgZXBvY2g/OiBudW1iZXIsXG4gICk6IFByb21pc2U8U3Rha2VBY3RpdmF0aW9uRGF0YT4ge1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbcHVibGljS2V5LnRvQmFzZTU4KCldLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLyxcbiAgICAgIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaCxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlQWN0aXZhdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoU3Rha2VBY3RpdmF0aW9uUmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgIGBmYWlsZWQgdG8gZ2V0IFN0YWtlIEFjdGl2YXRpb24gJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlcj59Pj59XG4gICAqL1xuICBhc3luYyBnZXRQcm9ncmFtQWNjb3VudHMoXG4gICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXksXG4gICAgY29uZmlnT3JDb21taXRtZW50OiBHZXRQcm9ncmFtQWNjb3VudHNDb25maWcgJlxuICAgICAgUmVhZG9ubHk8e3dpdGhDb250ZXh0OiB0cnVlfT4sXG4gICk6IFByb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlPj47XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UHJvZ3JhbUFjY291bnRzKFxuICAgIHByb2dyYW1JZDogUHVibGljS2V5LFxuICAgIGNvbmZpZ09yQ29tbWl0bWVudD86IEdldFByb2dyYW1BY2NvdW50c0NvbmZpZyB8IENvbW1pdG1lbnQsXG4gICk6IFByb21pc2U8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFByb2dyYW1BY2NvdW50cyhcbiAgICBwcm9ncmFtSWQ6IFB1YmxpY0tleSxcbiAgICBjb25maWdPckNvbW1pdG1lbnQ/OiBHZXRQcm9ncmFtQWNjb3VudHNDb25maWcgfCBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFxuICAgIHwgR2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2VcbiAgICB8IFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxHZXRQcm9ncmFtQWNjb3VudHNSZXNwb25zZT5cbiAgPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3Qge2VuY29kaW5nLCAuLi5jb25maWdXaXRob3V0RW5jb2Rpbmd9ID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGVuY29kaW5nIHx8ICdiYXNlNjQnLFxuICAgICAge1xuICAgICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmcsXG4gICAgICAgIC4uLihjb25maWdXaXRob3V0RW5jb2RpbmcuZmlsdGVyc1xuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBmaWx0ZXJzOiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhcbiAgICAgICAgICAgICAgICBjb25maWdXaXRob3V0RW5jb2RpbmcuZmlsdGVycyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IG51bGwpLFxuICAgICAgfSxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IGJhc2VTY2hlbWEgPSBhcnJheShLZXllZEFjY291bnRJbmZvUmVzdWx0KTtcbiAgICBjb25zdCByZXMgPVxuICAgICAgY29uZmlnV2l0aG91dEVuY29kaW5nLndpdGhDb250ZXh0ID09PSB0cnVlXG4gICAgICAgID8gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYmFzZVNjaGVtYSkpXG4gICAgICAgIDogY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChiYXNlU2NoZW1hKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW5kIHBhcnNlIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXIgfCBQYXJzZWRBY2NvdW50RGF0YT59Pj59XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMoXG4gICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXksXG4gICAgY29uZmlnT3JDb21taXRtZW50PzogR2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzQ29uZmlnIHwgQ29tbWl0bWVudCxcbiAgKTogUHJvbWlzZTxcbiAgICBBcnJheTx7XG4gICAgICBwdWJrZXk6IFB1YmxpY0tleTtcbiAgICAgIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlciB8IFBhcnNlZEFjY291bnREYXRhPjtcbiAgICB9PlxuICA+IHtcbiAgICBjb25zdCB7Y29tbWl0bWVudCwgY29uZmlnfSA9XG4gICAgICBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFxuICAgICAgW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSxcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAnanNvblBhcnNlZCcsXG4gICAgICBjb25maWcsXG4gICAgKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUoXG4gICAgICB1bnNhZmVSZXMsXG4gICAgICBqc29uUnBjUmVzdWx0KGFycmF5KEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSxcbiAgICApO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgY29uZmlybVRyYW5zYWN0aW9uKFxuICAgIHN0cmF0ZWd5OiBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5LFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaWduYXR1cmVSZXN1bHQ+PjtcblxuICAvKiogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgY29uZmlybVRyYW5zYWN0aW9uYCBhbmQgcGFzcyBpbiB7QGxpbmsgVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBjb25maXJtVHJhbnNhY3Rpb24oXG4gICAgc3RyYXRlZ3k6IFRyYW5zYWN0aW9uU2lnbmF0dXJlLFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaWduYXR1cmVSZXN1bHQ+PjtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvbihcbiAgICBzdHJhdGVneTogVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneSB8IFRyYW5zYWN0aW9uU2lnbmF0dXJlLFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaWduYXR1cmVSZXN1bHQ+PiB7XG4gICAgbGV0IHJhd1NpZ25hdHVyZTogc3RyaW5nO1xuXG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PSAnc3RyaW5nJykge1xuICAgICAgcmF3U2lnbmF0dXJlID0gc3RyYXRlZ3k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHN0cmF0ZWd5IGFzIFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3k7XG5cbiAgICAgIGlmIChjb25maWcuYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvbmZpZy5hYm9ydFNpZ25hbC5yZWFzb24pO1xuICAgICAgfVxuICAgICAgcmF3U2lnbmF0dXJlID0gY29uZmlnLnNpZ25hdHVyZTtcbiAgICB9XG5cbiAgICBsZXQgZGVjb2RlZFNpZ25hdHVyZTtcblxuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkU2lnbmF0dXJlID0gYnM1OC5kZWNvZGUocmF3U2lnbmF0dXJlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmF0dXJlIG11c3QgYmUgYmFzZTU4IGVuY29kZWQ6ICcgKyByYXdTaWduYXR1cmUpO1xuICAgIH1cblxuICAgIGFzc2VydChkZWNvZGVkU2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsICdzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoJyk7XG5cbiAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc2lnbmF0dXJlOiByYXdTaWduYXR1cmUsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdsYXN0VmFsaWRCbG9ja0hlaWdodCcgaW4gc3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3ksXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzdHJhdGVneSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShzaWduYWw/OiBBYm9ydFNpZ25hbCk6IFByb21pc2U8bmV2ZXI+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8bmV2ZXI+KChfLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmUsXG4gIH06IHtcbiAgICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgICBzaWduYXR1cmU6IHN0cmluZztcbiAgfSk6IHtcbiAgICBhYm9ydENvbmZpcm1hdGlvbigpOiB2b2lkO1xuICAgIGNvbmZpcm1hdGlvblByb21pc2U6IFByb21pc2U8e1xuICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQ7XG4gICAgICByZXNwb25zZTogUnBjUmVzcG9uc2VBbmRDb250ZXh0PFNpZ25hdHVyZVJlc3VsdD47XG4gICAgfT47XG4gIH0ge1xuICAgIGxldCBzaWduYXR1cmVTdWJzY3JpcHRpb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGxldCBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcjpcbiAgICAgIHwgU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VEaXNwb3NlRm5cbiAgICAgIHwgdW5kZWZpbmVkO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgY29uZmlybWF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlPHtcbiAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEO1xuICAgICAgcmVzcG9uc2U6IFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaWduYXR1cmVSZXN1bHQ+O1xuICAgIH0+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdGhpcy5vblNpZ25hdHVyZShcbiAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgKHJlc3VsdDogU2lnbmF0dXJlUmVzdWx0LCBjb250ZXh0OiBDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoe19fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELCByZXNwb25zZX0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oXG4gICAgICAgICAgcmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwID0+IHtcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPVxuICAgICAgICAgICAgICAgIHRoaXMuX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UoXG4gICAgICAgICAgICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUgPT09ICdzdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb25TZXR1cFByb21pc2U7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7Y29udGV4dCwgdmFsdWV9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlPy5lcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh2YWx1ZS5lcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzoge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJyB8fFxuICAgICAgICAgICAgICAgICAgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAnY29uZmlybWVkJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBleGhhdXN0IGVudW1zIHRvIGVuc3VyZSBmdWxsIGNvdmVyYWdlXG4gICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0Q29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKSB7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKCk7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihzaWduYXR1cmVTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHthYm9ydENvbmZpcm1hdGlvbiwgY29uZmlybWF0aW9uUHJvbWlzZX07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHthYm9ydFNpZ25hbCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQsIHNpZ25hdHVyZX0sXG4gIH06IHtcbiAgICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgICBzdHJhdGVneTogQmxvY2toZWlnaHRCYXNlZFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3k7XG4gIH0pIHtcbiAgICBsZXQgZG9uZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZTx7XG4gICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLkJMT0NLSEVJR0hUX0VYQ0VFREVEO1xuICAgIH0+KHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgY2hlY2tCbG9ja0hlaWdodCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tIZWlnaHQoY29tbWl0bWVudCk7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrSGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChjdXJyZW50QmxvY2tIZWlnaHQgPD0gbGFzdFZhbGlkQmxvY2tIZWlnaHQpIHtcbiAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe19fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuQkxPQ0tIRUlHSFRfRVhDRUVERUR9KTtcbiAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3Qge2Fib3J0Q29uZmlybWF0aW9uLCBjb25maXJtYXRpb25Qcm9taXNlfSA9XG4gICAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7Y29tbWl0bWVudCwgc2lnbmF0dXJlfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDogUnBjUmVzcG9uc2VBbmRDb250ZXh0PFNpZ25hdHVyZVJlc3VsdD47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBjYW5jZWxsYXRpb25Qcm9taXNlLFxuICAgICAgICBjb25maXJtYXRpb25Qcm9taXNlLFxuICAgICAgICBleHBpcnlQcm9taXNlLFxuICAgICAgXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgIH0sXG4gIH06IHtcbiAgICBjb21taXRtZW50PzogQ29tbWl0bWVudDtcbiAgICBzdHJhdGVneTogRHVyYWJsZU5vbmNlVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneTtcbiAgfSkge1xuICAgIGxldCBkb25lOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlPHtcbiAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuTk9OQ0VfSU5WQUxJRDtcbiAgICAgIHNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlOiBudW1iZXIgfCBudWxsO1xuICAgIH0+KHJlc29sdmUgPT4ge1xuICAgICAgbGV0IGN1cnJlbnROb25jZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBub25jZVZhbHVlO1xuICAgICAgbGV0IGxhc3RDaGVja2VkU2xvdDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICBjb25zdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7Y29udGV4dCwgdmFsdWU6IG5vbmNlQWNjb3VudH0gPSBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChcbiAgICAgICAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgbGFzdENoZWNrZWRTbG90ID0gY29udGV4dC5zbG90O1xuICAgICAgICAgIHJldHVybiBub25jZUFjY291bnQ/Lm5vbmNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgZm9yIHdoYXRldmVyIHJlYXNvbiB3ZSBjYW4ndCByZWFjaC9yZWFkIHRoZSBub25jZVxuICAgICAgICAgIC8vIGFjY291bnQsIGp1c3Qga2VlcCB1c2luZyB0aGUgbGFzdC1rbm93biB2YWx1ZS5cbiAgICAgICAgICByZXR1cm4gY3VycmVudE5vbmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjdXJyZW50Tm9uY2VWYWx1ZSA9IGF3YWl0IGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICB0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChub25jZVZhbHVlICE9PSBjdXJyZW50Tm9uY2VWYWx1ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuTk9OQ0VfSU5WQUxJRCxcbiAgICAgICAgICAgICAgc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2U6IGxhc3RDaGVja2VkU2xvdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHthYm9ydENvbmZpcm1hdGlvbiwgY29uZmlybWF0aW9uUHJvbWlzZX0gPVxuICAgICAgdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe2NvbW1pdG1lbnQsIHNpZ25hdHVyZX0pO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgIGxldCByZXN1bHQ6IFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaWduYXR1cmVSZXN1bHQ+O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgY2FuY2VsbGF0aW9uUHJvbWlzZSxcbiAgICAgICAgY29uZmlybWF0aW9uUHJvbWlzZSxcbiAgICAgICAgZXhwaXJ5UHJvbWlzZSxcbiAgICAgIF0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBpbmRlZWQgdW5jb25maXJtZWQuXG4gICAgICAgIGxldCBzaWduYXR1cmVTdGF0dXM6XG4gICAgICAgICAgfCBScGNSZXNwb25zZUFuZENvbnRleHQ8U2lnbmF0dXJlU3RhdHVzIHwgbnVsbD5cbiAgICAgICAgICB8IG51bGxcbiAgICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0dXMuY29udGV4dC5zbG90IDxcbiAgICAgICAgICAgIChvdXRjb21lLnNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlID8/IG1pbkNvbnRleHRTbG90KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoNDAwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWduYXR1cmVTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hdHVyZVN0YXR1cz8udmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBjb21taXRtZW50Rm9yU3RhdHVzID0gY29tbWl0bWVudCB8fCAnZmluYWxpemVkJztcbiAgICAgICAgICBjb25zdCB7Y29uZmlybWF0aW9uU3RhdHVzfSA9IHNpZ25hdHVyZVN0YXR1cy52YWx1ZTtcbiAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnRGb3JTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzICE9PSAncHJvY2Vzc2VkJyAmJlxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiZcbiAgICAgICAgICAgICAgICBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJlxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCdcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gRXhoYXVzdGl2ZSBzd2l0Y2guXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgKChfOiBuZXZlcikgPT4ge30pKGNvbW1pdG1lbnRGb3JTdGF0dXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBzaWduYXR1cmVTdGF0dXMuY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiB7ZXJyOiBzaWduYXR1cmVTdGF0dXMudmFsdWUuZXJyfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlLFxuICB9OiB7XG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQ7XG4gICAgc2lnbmF0dXJlOiBzdHJpbmc7XG4gIH0pIHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZTx7XG4gICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlRJTUVEX09VVDtcbiAgICAgIHRpbWVvdXRNczogbnVtYmVyO1xuICAgIH0+KHJlc29sdmUgPT4ge1xuICAgICAgbGV0IHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDYwICogMTAwMDtcbiAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOiB7XG4gICAgICAgICAgdGltZW91dE1zID0gdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgfHwgMzAgKiAxMDAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aGF1c3QgZW51bXMgdG8gZW5zdXJlIGZ1bGwgY292ZXJhZ2VcbiAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICB9XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiByZXNvbHZlKHtfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlRJTUVEX09VVCwgdGltZW91dE1zfSksXG4gICAgICAgIHRpbWVvdXRNcyxcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3Qge2Fib3J0Q29uZmlybWF0aW9uLCBjb25maXJtYXRpb25Qcm9taXNlfSA9XG4gICAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgIH0pO1xuICAgIGxldCByZXN1bHQ6IFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaWduYXR1cmVSZXN1bHQ+O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcihcbiAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgb3V0Y29tZS50aW1lb3V0TXMgLyAxMDAwLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRDbHVzdGVyTm9kZXMoKTogUHJvbWlzZTxBcnJheTxDb250YWN0SW5mbz4+IHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDbHVzdGVyTm9kZXMnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShDb250YWN0SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjbHVzdGVyIG5vZGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGFydGljaXBhdGluZyBpbiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Vm90ZUFjY291bnRzKGNvbW1pdG1lbnQ/OiBDb21taXRtZW50KTogUHJvbWlzZTxWb3RlQWNjb3VudFN0YXR1cz4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZvdGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFZvdGVBY2NvdW50cyk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdm90ZSBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IHRoYXQgdGhlIG5vZGUgaXMgcHJvY2Vzc2luZ1xuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdChcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgR2V0U2xvdENvbmZpZyxcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCB7Y29tbWl0bWVudCwgY29uZmlnfSA9XG4gICAgICBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFxuICAgICAgW10sXG4gICAgICBjb21taXRtZW50LFxuICAgICAgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLFxuICAgICAgY29uZmlnLFxuICAgICk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgbGVhZGVyIG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRTbG90TGVhZGVyKFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRTbG90TGVhZGVyQ29uZmlnLFxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbXSxcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sXG4gICAgICBjb25maWcsXG4gICAgKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGBsaW1pdGAgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIGBzdGFydFNsb3RgXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFNsb3QgZmV0Y2ggc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gdGhpcyBzbG90XG4gICAqIEBwYXJhbSBsaW1pdCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHRvIHJldHVyblxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcnMoXG4gICAgc3RhcnRTbG90OiBudW1iZXIsXG4gICAgbGltaXQ6IG51bWJlcixcbiAgKTogUHJvbWlzZTxBcnJheTxQdWJsaWNLZXk+PiB7XG4gICAgY29uc3QgYXJncyA9IFtzdGFydFNsb3QsIGxpbWl0XTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVycycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZykpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90IGxlYWRlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzIG9mIGEgc2lnbmF0dXJlXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXMoXG4gICAgc2lnbmF0dXJlOiBUcmFuc2FjdGlvblNpZ25hdHVyZSxcbiAgICBjb25maWc/OiBTaWduYXR1cmVTdGF0dXNDb25maWcsXG4gICk6IFByb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PFNpZ25hdHVyZVN0YXR1cyB8IG51bGw+PiB7XG4gICAgY29uc3Qge2NvbnRleHQsIHZhbHVlOiB2YWx1ZXN9ID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXNlcyhcbiAgICAgIFtzaWduYXR1cmVdLFxuICAgICAgY29uZmlnLFxuICAgICk7XG4gICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPT09IDEpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzWzBdO1xuICAgIHJldHVybiB7Y29udGV4dCwgdmFsdWV9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1c2VzIG9mIGEgYmF0Y2ggb2Ygc2lnbmF0dXJlc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzZXMoXG4gICAgc2lnbmF0dXJlczogQXJyYXk8VHJhbnNhY3Rpb25TaWduYXR1cmU+LFxuICAgIGNvbmZpZz86IFNpZ25hdHVyZVN0YXR1c0NvbmZpZyxcbiAgKTogUHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QXJyYXk8U2lnbmF0dXJlU3RhdHVzIHwgbnVsbD4+PiB7XG4gICAgY29uc3QgcGFyYW1zOiBhbnlbXSA9IFtzaWduYXR1cmVzXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBwYXJhbXMucHVzaChjb25maWcpO1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVTdGF0dXNlcycsIHBhcmFtcyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZSBzdGF0dXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgb2YgdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoXG4gICAgY29tbWl0bWVudE9yQ29uZmlnPzogQ29tbWl0bWVudCB8IEdldFRyYW5zYWN0aW9uQ291bnRDb25maWcsXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhcbiAgICAgIFtdLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLyxcbiAgICAgIGNvbmZpZyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uQ291bnQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGNvdW50JyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRvdGFsIGN1cnJlbmN5IHN1cHBseSBvZiB0aGUgY2x1c3RlciBpbiBsYW1wb3J0c1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4yLjguIFBsZWFzZSB1c2Uge0BsaW5rIGdldFN1cHBseX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFRvdGFsU3VwcGx5KGNvbW1pdG1lbnQ/OiBDb21taXRtZW50KTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldFN1cHBseSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0OiB0cnVlLFxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWUudG90YWw7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNsdXN0ZXIgSW5mbGF0aW9uR292ZXJub3IgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uR292ZXJub3IoXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4gICk6IFByb21pc2U8SW5mbGF0aW9uR292ZXJub3I+IHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25Hb3Zlcm5vcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgZm9yIGFuIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SZXdhcmQoXG4gICAgYWRkcmVzc2VzOiBQdWJsaWNLZXlbXSxcbiAgICBlcG9jaD86IG51bWJlcixcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgR2V0SW5mbGF0aW9uUmV3YXJkQ29uZmlnLFxuICApOiBQcm9taXNlPChJbmZsYXRpb25SZXdhcmQgfCBudWxsKVtdPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhcbiAgICAgIFthZGRyZXNzZXMubWFwKHB1YmtleSA9PiBwdWJrZXkudG9CYXNlNTgoKSldLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLyxcbiAgICAgIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaCxcbiAgICAgIH0sXG4gICAgKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SZXdhcmQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByZXdhcmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNwZWNpZmljIGluZmxhdGlvbiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SYXRlKCk6IFByb21pc2U8SW5mbGF0aW9uUmF0ZT4ge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJhdGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIEluZm8gcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hJbmZvKFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRFcG9jaEluZm9Db25maWcsXG4gICk6IFByb21pc2U8RXBvY2hJbmZvPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhcbiAgICAgIFtdLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLyxcbiAgICAgIGNvbmZpZyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoSW5mbycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoSW5mb1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggaW5mbycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggU2NoZWR1bGUgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hTY2hlZHVsZSgpOiBQcm9taXNlPEVwb2NoU2NoZWR1bGU+IHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaFNjaGVkdWxlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVwb2NoU2NoZWR1bGUgPSByZXMucmVzdWx0O1xuICAgIHJldHVybiBuZXcgRXBvY2hTY2hlZHVsZShcbiAgICAgIGVwb2NoU2NoZWR1bGUuc2xvdHNQZXJFcG9jaCxcbiAgICAgIGVwb2NoU2NoZWR1bGUubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0LFxuICAgICAgZXBvY2hTY2hlZHVsZS53YXJtdXAsXG4gICAgICBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsRXBvY2gsXG4gICAgICBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsU2xvdCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PExlYWRlclNjaGVkdWxlPj59XG4gICAqL1xuICBhc3luYyBnZXRMZWFkZXJTY2hlZHVsZSgpOiBQcm9taXNlPExlYWRlclNjaGVkdWxlPiB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGVhZGVyU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxlYWRlciBzY2hlZHVsZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbWluaW11bSBiYWxhbmNlIG5lZWRlZCB0byBleGVtcHQgYW4gYWNjb3VudCBvZiBgZGF0YUxlbmd0aGBcbiAgICogc2l6ZSBmcm9tIHJlbnRcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihcbiAgICBkYXRhTGVuZ3RoOiBudW1iZXIsXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbZGF0YUxlbmd0aF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoXG4gICAgICAnZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uJyxcbiAgICAgIGFyZ3MsXG4gICAgKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gZmV0Y2ggbWluaW11bSBiYWxhbmNlIGZvciByZW50IGV4ZW1wdGlvbicpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+Pn1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOS4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRMYXRlc3RCbG9ja2hhc2h9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQ/OiBDb21taXRtZW50KTogUHJvbWlzZTxcbiAgICBScGNSZXNwb25zZUFuZENvbnRleHQ8e1xuICAgICAgYmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gICAgICBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yO1xuICAgIH0+XG4gID4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudEJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHRScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxQZXJmU2FtcGxlPj59XG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMoXG4gICAgbGltaXQ/OiBudW1iZXIsXG4gICk6IFByb21pc2U8QXJyYXk8UGVyZlNhbXBsZT4+IHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KFxuICAgICAgJ2dldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcycsXG4gICAgICBsaW1pdCA/IFtsaW1pdF0gOiBbXSxcbiAgICApO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBjYWxjdWxhdG9yIGZvciBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS45LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEZlZUZvck1lc3NhZ2V9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoKFxuICAgIGJsb2NraGFzaDogQmxvY2toYXNoLFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxGZWVDYWxjdWxhdG9yIHwgbnVsbD4+IHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KFxuICAgICAgJ2dldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2gnLFxuICAgICAgYXJncyxcbiAgICApO1xuXG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGNhbGN1bGF0b3InKTtcbiAgICB9XG4gICAgY29uc3Qge2NvbnRleHQsIHZhbHVlfSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT09IG51bGwgPyB2YWx1ZS5mZWVDYWxjdWxhdG9yIDogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRGZWVGb3JNZXNzYWdlKFxuICAgIG1lc3NhZ2U6IFZlcnNpb25lZE1lc3NhZ2UsXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4gICk6IFByb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PG51bWJlciB8IG51bGw+PiB7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlLnNlcmlhbGl6ZSgpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbd2lyZU1lc3NhZ2VdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVGb3JNZXNzYWdlJywgYXJncyk7XG5cbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgZm9yIG1lc3NhZ2UnKTtcbiAgICB9XG4gICAgaWYgKHJlcy5yZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIHByaW9yaXRpemF0aW9uIGZlZXMgZnJvbSByZWNlbnQgYmxvY2tzLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzKFxuICAgIGNvbmZpZz86IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc0NvbmZpZyxcbiAgKTogUHJvbWlzZTxSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNbXT4ge1xuICAgIGNvbnN0IGFjY291bnRzID0gY29uZmlnPy5sb2NrZWRXcml0YWJsZUFjY291bnRzPy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gYWNjb3VudHM/Lmxlbmd0aCA/IFthY2NvdW50c10gOiBbXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KFxuICAgICAgJ2dldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcycsXG4gICAgICBhcmdzLFxuICAgICk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoXG4gICAgICAgIHJlcy5lcnJvcixcbiAgICAgICAgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHByaW9yaXRpemF0aW9uIGZlZXMnLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoKFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBQcm9taXNlPHtibG9ja2hhc2g6IEJsb2NraGFzaDsgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaChcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgR2V0TGF0ZXN0QmxvY2toYXNoQ29uZmlnLFxuICApOiBQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KFxuICAgIGNvbW1pdG1lbnRPckNvbmZpZz86IENvbW1pdG1lbnQgfCBHZXRMYXRlc3RCbG9ja2hhc2hDb25maWcsXG4gICk6IFByb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD4+IHtcbiAgICBjb25zdCB7Y29tbWl0bWVudCwgY29uZmlnfSA9XG4gICAgICBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFxuICAgICAgW10sXG4gICAgICBjb21taXRtZW50LFxuICAgICAgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLFxuICAgICAgY29uZmlnLFxuICAgICk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGF0ZXN0QmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXRlc3QgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGJsb2NraGFzaCBpcyBzdGlsbCB2YWxpZCBvciBub3RcbiAgICovXG4gIGFzeW5jIGlzQmxvY2toYXNoVmFsaWQoXG4gICAgYmxvY2toYXNoOiBCbG9ja2hhc2gsXG4gICAgcmF3Q29uZmlnPzogSXNCbG9ja2hhc2hWYWxpZENvbmZpZyxcbiAgKTogUHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8Ym9vbGVhbj4+IHtcbiAgICBjb25zdCB7Y29tbWl0bWVudCwgY29uZmlnfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbYmxvY2toYXNoXSxcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sXG4gICAgICBjb25maWcsXG4gICAgKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdpc0Jsb2NraGFzaFZhbGlkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgICdmYWlsZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBibG9ja2hhc2ggYCcgKyBibG9ja2hhc2ggKyAnYGlzIHZhbGlkJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBub2RlIHZlcnNpb25cbiAgICovXG4gIGFzeW5jIGdldFZlcnNpb24oKTogUHJvbWlzZTxWZXJzaW9uPiB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VmVyc2lvbicsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFZlcnNpb25SZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBnZW5lc2lzIGhhc2hcbiAgICovXG4gIGFzeW5jIGdldEdlbmVzaXNIYXNoKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0R2VuZXNpc0hhc2gnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGdlbmVzaXMgaGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2soXG4gICAgc2xvdDogbnVtYmVyLFxuICAgIHJhd0NvbmZpZz86IEdldEJsb2NrQ29uZmlnLFxuICApOiBQcm9taXNlPEJsb2NrUmVzcG9uc2UgfCBudWxsPjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0QmxvY2soXG4gICAgc2xvdDogbnVtYmVyLFxuICAgIHJhd0NvbmZpZzogR2V0QmxvY2tDb25maWcgJiB7dHJhbnNhY3Rpb25EZXRhaWxzOiAnYWNjb3VudHMnfSxcbiAgKTogUHJvbWlzZTxBY2NvdW50c01vZGVCbG9ja1Jlc3BvbnNlIHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldEJsb2NrKFxuICAgIHNsb3Q6IG51bWJlcixcbiAgICByYXdDb25maWc6IEdldEJsb2NrQ29uZmlnICYge3RyYW5zYWN0aW9uRGV0YWlsczogJ25vbmUnfSxcbiAgKTogUHJvbWlzZTxOb25lTW9kZUJsb2NrUmVzcG9uc2UgfCBudWxsPjtcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0QmxvY2soXG4gICAgc2xvdDogbnVtYmVyLFxuICAgIHJhd0NvbmZpZz86IEdldFZlcnNpb25lZEJsb2NrQ29uZmlnLFxuICApOiBQcm9taXNlPFZlcnNpb25lZEJsb2NrUmVzcG9uc2UgfCBudWxsPjtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldEJsb2NrKFxuICAgIHNsb3Q6IG51bWJlcixcbiAgICByYXdDb25maWc6IEdldFZlcnNpb25lZEJsb2NrQ29uZmlnICYge3RyYW5zYWN0aW9uRGV0YWlsczogJ2FjY291bnRzJ30sXG4gICk6IFByb21pc2U8VmVyc2lvbmVkQWNjb3VudHNNb2RlQmxvY2tSZXNwb25zZSB8IG51bGw+O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0QmxvY2soXG4gICAgc2xvdDogbnVtYmVyLFxuICAgIHJhd0NvbmZpZzogR2V0VmVyc2lvbmVkQmxvY2tDb25maWcgJiB7dHJhbnNhY3Rpb25EZXRhaWxzOiAnbm9uZSd9LFxuICApOiBQcm9taXNlPFZlcnNpb25lZE5vbmVNb2RlQmxvY2tSZXNwb25zZSB8IG51bGw+O1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRCbG9jayhcbiAgICBzbG90OiBudW1iZXIsXG4gICAgcmF3Q29uZmlnPzogR2V0VmVyc2lvbmVkQmxvY2tDb25maWcsXG4gICk6IFByb21pc2U8XG4gICAgfCBWZXJzaW9uZWRCbG9ja1Jlc3BvbnNlXG4gICAgfCBWZXJzaW9uZWRBY2NvdW50c01vZGVCbG9ja1Jlc3BvbnNlXG4gICAgfCBWZXJzaW9uZWROb25lTW9kZUJsb2NrUmVzcG9uc2VcbiAgICB8IG51bGxcbiAgPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChcbiAgICAgIFtzbG90XSxcbiAgICAgIGNvbW1pdG1lbnQgYXMgRmluYWxpdHksXG4gICAgICB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sXG4gICAgICBjb25maWcsXG4gICAgKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzoge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6IHtcbiAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge3Jlc3VsdH0gPSByZXM7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgICAoe3RyYW5zYWN0aW9uLCBtZXRhLCB2ZXJzaW9ufSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoXG4gICAgICAgIGUgYXMgSlNPTlJQQ0Vycm9yLFxuICAgICAgICAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQmxvY2soXG4gICAgc2xvdDogbnVtYmVyLFxuICAgIHJhd0NvbmZpZz86IEdldFZlcnNpb25lZEJsb2NrQ29uZmlnLFxuICApOiBQcm9taXNlPFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUmVzcG9uc2U+O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UGFyc2VkQmxvY2soXG4gICAgc2xvdDogbnVtYmVyLFxuICAgIHJhd0NvbmZpZzogR2V0VmVyc2lvbmVkQmxvY2tDb25maWcgJiB7dHJhbnNhY3Rpb25EZXRhaWxzOiAnYWNjb3VudHMnfSxcbiAgKTogUHJvbWlzZTxQYXJzZWRBY2NvdW50c01vZGVCbG9ja1Jlc3BvbnNlPjtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFBhcnNlZEJsb2NrKFxuICAgIHNsb3Q6IG51bWJlcixcbiAgICByYXdDb25maWc6IEdldFZlcnNpb25lZEJsb2NrQ29uZmlnICYge3RyYW5zYWN0aW9uRGV0YWlsczogJ25vbmUnfSxcbiAgKTogUHJvbWlzZTxQYXJzZWROb25lTW9kZUJsb2NrUmVzcG9uc2U+O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFBhcnNlZEJsb2NrKFxuICAgIHNsb3Q6IG51bWJlcixcbiAgICByYXdDb25maWc/OiBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZyxcbiAgKTogUHJvbWlzZTxcbiAgICB8IFBhcnNlZEJsb2NrUmVzcG9uc2VcbiAgICB8IFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUmVzcG9uc2VcbiAgICB8IFBhcnNlZE5vbmVNb2RlQmxvY2tSZXNwb25zZVxuICAgIHwgbnVsbFxuICA+IHtcbiAgICBjb25zdCB7Y29tbWl0bWVudCwgY29uZmlnfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgICAgW3Nsb3RdLFxuICAgICAgY29tbWl0bWVudCBhcyBGaW5hbGl0eSxcbiAgICAgICdqc29uUGFyc2VkJyxcbiAgICAgIGNvbmZpZyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOiB7XG4gICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzoge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSBhcyBKU09OUlBDRXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBibG9jayBoZWlnaHQgb2YgdGhlIG5vZGVcbiAgICovXG4gIGdldEJsb2NrSGVpZ2h0ID0gKCgpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXM6IHtbaGFzaDogc3RyaW5nXTogUHJvbWlzZTxudW1iZXI+fSA9IHt9O1xuICAgIHJldHVybiBhc3luYyAoXG4gICAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgR2V0QmxvY2tIZWlnaHRDb25maWcsXG4gICAgKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFxuICAgICAgICBbXSxcbiAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLFxuICAgICAgICBjb25maWcsXG4gICAgICApO1xuICAgICAgY29uc3QgcmVxdWVzdEhhc2ggPSBmYXN0U3RhYmxlU3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA9XG4gICAgICAgIHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF0gPz9cbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tIZWlnaHQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICAgICAgICAgIHJlcy5lcnJvcixcbiAgICAgICAgICAgICAgICAnZmFpbGVkIHRvIGdldCBibG9jayBoZWlnaHQgaW5mb3JtYXRpb24nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLypcbiAgICogUmV0dXJucyByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1Byb2R1Y3Rpb24oXG4gICAgY29uZmlnT3JDb21taXRtZW50PzogR2V0QmxvY2tQcm9kdWN0aW9uQ29uZmlnIHwgQ29tbWl0bWVudCxcbiAgKTogUHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QmxvY2tQcm9kdWN0aW9uPj4ge1xuICAgIGxldCBleHRyYTogT21pdDxHZXRCbG9ja1Byb2R1Y3Rpb25Db25maWcsICdjb21taXRtZW50Jz4gfCB1bmRlZmluZWQ7XG4gICAgbGV0IGNvbW1pdG1lbnQ6IENvbW1pdG1lbnQgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yQ29tbWl0bWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbW1pdG1lbnQgPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgfSBlbHNlIGlmIChjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICAgIGNvbnN0IHtjb21taXRtZW50OiBjLCAuLi5yZXN0fSA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICAgIGNvbW1pdG1lbnQgPSBjO1xuICAgICAgZXh0cmEgPSByZXN0O1xuICAgIH1cblxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBleHRyYSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tQcm9kdWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICAnZmFpbGVkIHRvIGdldCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbihcbiAgICBzaWduYXR1cmU6IHN0cmluZyxcbiAgICByYXdDb25maWc/OiBHZXRUcmFuc2FjdGlvbkNvbmZpZyxcbiAgKTogUHJvbWlzZTxUcmFuc2FjdGlvblJlc3BvbnNlIHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbihcbiAgICBzaWduYXR1cmU6IHN0cmluZyxcbiAgICByYXdDb25maWc6IEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnLFxuICApOiBQcm9taXNlPFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2UgfCBudWxsPjtcblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKFxuICAgIHNpZ25hdHVyZTogc3RyaW5nLFxuICAgIHJhd0NvbmZpZz86IEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnLFxuICApOiBQcm9taXNlPFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2UgfCBudWxsPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChcbiAgICAgIFtzaWduYXR1cmVdLFxuICAgICAgY29tbWl0bWVudCBhcyBGaW5hbGl0eSxcbiAgICAgIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLyxcbiAgICAgIGNvbmZpZyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgcmVzdWx0LnZlcnNpb24sXG4gICAgICAgICAgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UsXG4gICAgICAgICksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb24oXG4gICAgc2lnbmF0dXJlOiBUcmFuc2FjdGlvblNpZ25hdHVyZSxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZyB8IEZpbmFsaXR5LFxuICApOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uV2l0aE1ldGEgfCBudWxsPiB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoXG4gICAgICBbc2lnbmF0dXJlXSxcbiAgICAgIGNvbW1pdG1lbnQgYXMgRmluYWxpdHksXG4gICAgICAnanNvblBhcnNlZCcsXG4gICAgICBjb25maWcsXG4gICAgKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbnMoXG4gICAgc2lnbmF0dXJlczogVHJhbnNhY3Rpb25TaWduYXR1cmVbXSxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZyB8IEZpbmFsaXR5LFxuICApOiBQcm9taXNlPChQYXJzZWRUcmFuc2FjdGlvbldpdGhNZXRhIHwgbnVsbClbXT4ge1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgICAgICBbc2lnbmF0dXJlXSxcbiAgICAgICAgY29tbWl0bWVudCBhcyBGaW5hbGl0eSxcbiAgICAgICAgJ2pzb25QYXJzZWQnLFxuICAgICAgICBjb25maWcsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJncyxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAoKHVuc2FmZVJlczogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGluayBUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25zYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbnMoXG4gICAgc2lnbmF0dXJlczogVHJhbnNhY3Rpb25TaWduYXR1cmVbXSxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBHZXRUcmFuc2FjdGlvbkNvbmZpZyB8IEZpbmFsaXR5LFxuICApOiBQcm9taXNlPChUcmFuc2FjdGlvblJlc3BvbnNlIHwgbnVsbClbXT47XG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKFxuICAgIHNpZ25hdHVyZXM6IFRyYW5zYWN0aW9uU2lnbmF0dXJlW10sXG4gICAgY29tbWl0bWVudE9yQ29uZmlnOiBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZyB8IEZpbmFsaXR5LFxuICApOiBQcm9taXNlPChWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlIHwgbnVsbClbXT47XG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKFxuICAgIHNpZ25hdHVyZXM6IFRyYW5zYWN0aW9uU2lnbmF0dXJlW10sXG4gICAgY29tbWl0bWVudE9yQ29uZmlnOiBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZyB8IEZpbmFsaXR5LFxuICApOiBQcm9taXNlPChWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlIHwgbnVsbClbXT4ge1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgICAgICBbc2lnbmF0dXJlXSxcbiAgICAgICAgY29tbWl0bWVudCBhcyBGaW5hbGl0eSxcbiAgICAgICAgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLFxuICAgICAgICBjb25maWcsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJncyxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAoKHVuc2FmZVJlczogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbixcbiAgICAgICAgICAgIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlLFxuICAgICAgICAgICksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgVHJhbnNhY3Rpb25zIGFuZCB0cmFuc2FjdGlvbiBzdGF0dXNlcyBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIGZvciBhIGNvbmZpcm1lZCBibG9jay5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrKFxuICAgIHNsb3Q6IG51bWJlcixcbiAgICBjb21taXRtZW50PzogRmluYWxpdHksXG4gICk6IFByb21pc2U8Q29uZmlybWVkQmxvY2s+IHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQpO1xuXG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe3RyYW5zYWN0aW9uLCBtZXRhfSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UodHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJsb2NrLFxuICAgICAgdHJhbnNhY3Rpb25zOiBibG9jay50cmFuc2FjdGlvbnMubWFwKCh7dHJhbnNhY3Rpb24sIG1ldGF9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUoXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5tZXNzYWdlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcyxcbiAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBjb25maXJtZWQgYmxvY2tzIGJldHdlZW4gdHdvIHNsb3RzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja3MoXG4gICAgc3RhcnRTbG90OiBudW1iZXIsXG4gICAgZW5kU2xvdD86IG51bWJlcixcbiAgICBjb21taXRtZW50PzogRmluYWxpdHksXG4gICk6IFByb21pc2U8QXJyYXk8bnVtYmVyPj4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgICAgZW5kU2xvdCAhPT0gdW5kZWZpbmVkID8gW3N0YXJ0U2xvdCwgZW5kU2xvdF0gOiBbc3RhcnRTbG90XSxcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgU2lnbmF0dXJlcyBmcm9tIHRoZSBjbHVzdGVyIGZvciBhIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tTaWduYXR1cmVzKFxuICAgIHNsb3Q6IG51bWJlcixcbiAgICBjb21taXRtZW50PzogRmluYWxpdHksXG4gICk6IFByb21pc2U8QmxvY2tTaWduYXR1cmVzPiB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoXG4gICAgICBbc2xvdF0sXG4gICAgICBjb21taXRtZW50LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAge1xuICAgICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgICAgcmV3YXJkczogZmFsc2UsXG4gICAgICB9LFxuICAgICk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgY29uZmlybWVkIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrU2lnbmF0dXJlc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhcbiAgICBzbG90OiBudW1iZXIsXG4gICAgY29tbWl0bWVudD86IEZpbmFsaXR5LFxuICApOiBQcm9taXNlPEJsb2NrU2lnbmF0dXJlcz4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgICAgW3Nsb3RdLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHtcbiAgICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICAgIHJld2FyZHM6IGZhbHNlLFxuICAgICAgfSxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFRyYW5zYWN0aW9uKFxuICAgIHNpZ25hdHVyZTogVHJhbnNhY3Rpb25TaWduYXR1cmUsXG4gICAgY29tbWl0bWVudD86IEZpbmFsaXR5LFxuICApOiBQcm9taXNlPENvbmZpcm1lZFRyYW5zYWN0aW9uIHwgbnVsbD4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UocmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSByZXN1bHQudHJhbnNhY3Rpb24uc2lnbmF0dXJlcztcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbihcbiAgICBzaWduYXR1cmU6IFRyYW5zYWN0aW9uU2lnbmF0dXJlLFxuICAgIGNvbW1pdG1lbnQ/OiBGaW5hbGl0eSxcbiAgKTogUHJvbWlzZTxQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbiB8IG51bGw+IHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChcbiAgICAgIFtzaWduYXR1cmVdLFxuICAgICAgY29tbWl0bWVudCxcbiAgICAgICdqc29uUGFyc2VkJyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgdHJhbnNhY3Rpb24nLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyhcbiAgICBzaWduYXR1cmVzOiBUcmFuc2FjdGlvblNpZ25hdHVyZVtdLFxuICAgIGNvbW1pdG1lbnQ/OiBGaW5hbGl0eSxcbiAgKTogUHJvbWlzZTwoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24gfCBudWxsKVtdPiB7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoXG4gICAgICAgIFtzaWduYXR1cmVdLFxuICAgICAgICBjb21taXRtZW50LFxuICAgICAgICAnanNvblBhcnNlZCcsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJncyxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAoKHVuc2FmZVJlczogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgICAgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9ucycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW4gYWRkcmVzc1xuICAgKiB3aXRoaW4gYSBzcGVjaWZpZWQgc2xvdCByYW5nZS4gTWF4IHJhbmdlIGFsbG93ZWQgaXMgMTAsMDAwIHNsb3RzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4zLiBQbGVhc2UgdXNlIHtAbGluayBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJ9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gc3RhcnRTbG90IHN0YXJ0IHNsb3QsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0gZW5kU2xvdCBlbmQgc2xvdCwgaW5jbHVzaXZlXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyhcbiAgICBhZGRyZXNzOiBQdWJsaWNLZXksXG4gICAgc3RhcnRTbG90OiBudW1iZXIsXG4gICAgZW5kU2xvdDogbnVtYmVyLFxuICApOiBQcm9taXNlPEFycmF5PFRyYW5zYWN0aW9uU2lnbmF0dXJlPj4ge1xuICAgIGxldCBvcHRpb25zOiBhbnkgPSB7fTtcblxuICAgIGxldCBmaXJzdEF2YWlsYWJsZUJsb2NrID0gYXdhaXQgdGhpcy5nZXRGaXJzdEF2YWlsYWJsZUJsb2NrKCk7XG4gICAgd2hpbGUgKCEoJ3VudGlsJyBpbiBvcHRpb25zKSkge1xuICAgICAgc3RhcnRTbG90LS07XG4gICAgICBpZiAoc3RhcnRTbG90IDw9IDAgfHwgc3RhcnRTbG90IDwgZmlyc3RBdmFpbGFibGVCbG9jaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhcbiAgICAgICAgICBzdGFydFNsb3QsXG4gICAgICAgICAgJ2ZpbmFsaXplZCcsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChibG9jay5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRpb25zLnVudGlsID1cbiAgICAgICAgICAgIGJsb2NrLnNpZ25hdHVyZXNbYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdza2lwcGVkJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaGlnaGVzdENvbmZpcm1lZFJvb3QgPSBhd2FpdCB0aGlzLmdldFNsb3QoJ2ZpbmFsaXplZCcpO1xuICAgIHdoaWxlICghKCdiZWZvcmUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBlbmRTbG90Kys7XG4gICAgICBpZiAoZW5kU2xvdCA+IGhpZ2hlc3RDb25maXJtZWRSb290KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKGVuZFNsb3QpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmUgPVxuICAgICAgICAgICAgYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihcbiAgICAgIGFkZHJlc3MsXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gICAgcmV0dXJuIGNvbmZpcm1lZFNpZ25hdHVyZUluZm8ubWFwKGluZm8gPT4gaW5mby5zaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3N9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoXG4gICAgYWRkcmVzczogUHVibGljS2V5LFxuICAgIG9wdGlvbnM/OiBDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJPcHRpb25zLFxuICAgIGNvbW1pdG1lbnQ/OiBGaW5hbGl0eSxcbiAgKTogUHJvbWlzZTxBcnJheTxDb25maXJtZWRTaWduYXR1cmVJbmZvPj4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgICAgW2FkZHJlc3MudG9CYXNlNTgoKV0sXG4gICAgICBjb21taXRtZW50LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoXG4gICAgICAnZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyJyxcbiAgICAgIGFyZ3MsXG4gICAgKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAqIGFkZHJlc3MgYmFja3dhcmRzIGluIHRpbWUgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIG9yIG1vc3QgcmVjZW50IGNvbmZpcm1lZCBibG9ja1xuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzKFxuICAgIGFkZHJlc3M6IFB1YmxpY0tleSxcbiAgICBvcHRpb25zPzogU2lnbmF0dXJlc0ZvckFkZHJlc3NPcHRpb25zLFxuICAgIGNvbW1pdG1lbnQ/OiBGaW5hbGl0eSxcbiAgKTogUHJvbWlzZTxBcnJheTxDb25maXJtZWRTaWduYXR1cmVJbmZvPj4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgICAgW2FkZHJlc3MudG9CYXNlNTgoKV0sXG4gICAgICBjb21taXRtZW50LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZXNGb3JBZGRyZXNzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihcbiAgICAgICAgcmVzLmVycm9yLFxuICAgICAgICAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgZ2V0QWRkcmVzc0xvb2t1cFRhYmxlKFxuICAgIGFjY291bnRLZXk6IFB1YmxpY0tleSxcbiAgICBjb25maWc/OiBHZXRBY2NvdW50SW5mb0NvbmZpZyxcbiAgKTogUHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCB8IG51bGw+PiB7XG4gICAgY29uc3Qge2NvbnRleHQsIHZhbHVlOiBhY2NvdW50SW5mb30gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChcbiAgICAgIGFjY291bnRLZXksXG4gICAgICBjb25maWcsXG4gICAgKTtcblxuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50KHtcbiAgICAgICAga2V5OiBhY2NvdW50S2V5LFxuICAgICAgICBzdGF0ZTogQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudC5kZXNlcmlhbGl6ZShhY2NvdW50SW5mby5kYXRhKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlQW5kQ29udGV4dChcbiAgICBub25jZUFjY291bnQ6IFB1YmxpY0tleSxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgR2V0Tm9uY2VBbmRDb250ZXh0Q29uZmlnLFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxOb25jZUFjY291bnQgfCBudWxsPj4ge1xuICAgIGNvbnN0IHtjb250ZXh0LCB2YWx1ZTogYWNjb3VudEluZm99ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQoXG4gICAgICBub25jZUFjY291bnQsXG4gICAgICBjb21taXRtZW50T3JDb25maWcsXG4gICAgKTtcblxuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IE5vbmNlQWNjb3VudC5mcm9tQWNjb3VudERhdGEoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2UoXG4gICAgbm9uY2VBY2NvdW50OiBQdWJsaWNLZXksXG4gICAgY29tbWl0bWVudE9yQ29uZmlnPzogQ29tbWl0bWVudCB8IEdldE5vbmNlQ29uZmlnLFxuICApOiBQcm9taXNlPE5vbmNlQWNjb3VudCB8IG51bGw+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpXG4gICAgICAudGhlbih4ID0+IHgudmFsdWUpXG4gICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGdldCBub25jZSBmb3IgYWNjb3VudCAnICtcbiAgICAgICAgICAgIG5vbmNlQWNjb3VudC50b0Jhc2U1OCgpICtcbiAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgZSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYW4gYWxsb2NhdGlvbiBvZiBsYW1wb3J0cyB0byB0aGUgc3BlY2lmaWVkIGFkZHJlc3NcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIExBTVBPUlRTX1BFUl9TT0wgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG4gICAqXG4gICAqIChhc3luYyAoKSA9PiB7XG4gICAqICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFwiaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tXCIsIFwiY29uZmlybWVkXCIpO1xuICAgKiAgIGNvbnN0IG15QWRkcmVzcyA9IG5ldyBQdWJsaWNLZXkoXCIybnIxYkhGVDg2Vzl0R255dm1ZVzR2Y0hLc1FCM3NWUWZuZGRhc3o0a0V4TVwiKTtcbiAgICogICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3RBaXJkcm9wKG15QWRkcmVzcywgTEFNUE9SVFNfUEVSX1NPTCk7XG4gICAqICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICogfSkoKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyByZXF1ZXN0QWlyZHJvcChcbiAgICB0bzogUHVibGljS2V5LFxuICAgIGxhbXBvcnRzOiBudW1iZXIsXG4gICk6IFByb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+IHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdyZXF1ZXN0QWlyZHJvcCcsIFtcbiAgICAgIHRvLnRvQmFzZTU4KCksXG4gICAgICBsYW1wb3J0cyxcbiAgICBdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKFxuICAgICAgICByZXMuZXJyb3IsXG4gICAgICAgIGBhaXJkcm9wIHRvICR7dG8udG9CYXNlNTgoKX0gZmFpbGVkYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChcbiAgICBkaXNhYmxlQ2FjaGU6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0PiB7XG4gICAgaWYgKCFkaXNhYmxlQ2FjaGUpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHBvbGxpbmcgdG8gZmluaXNoXG4gICAgICB3aGlsZSAodGhpcy5fcG9sbGluZ0Jsb2NraGFzaCkge1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGltZVNpbmNlRmV0Y2ggPSBEYXRlLm5vdygpIC0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXN0RmV0Y2g7XG4gICAgICBjb25zdCBleHBpcmVkID0gdGltZVNpbmNlRmV0Y2ggPj0gQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVM7XG4gICAgICBpZiAodGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2ggIT09IG51bGwgJiYgIWV4cGlyZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9wb2xsTmV3QmxvY2toYXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcG9sbE5ld0Jsb2NraGFzaCgpOiBQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD4ge1xuICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgY2FjaGVkTGF0ZXN0QmxvY2toYXNoID0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICBjb25zdCBjYWNoZWRCbG9ja2hhc2ggPSBjYWNoZWRMYXRlc3RCbG9ja2hhc2hcbiAgICAgICAgPyBjYWNoZWRMYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaCgnZmluYWxpemVkJyk7XG5cbiAgICAgICAgaWYgKGNhY2hlZEJsb2NraGFzaCAhPT0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCkge1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICAgICAgICBsYXRlc3RCbG9ja2hhc2gsXG4gICAgICAgICAgICBsYXN0RmV0Y2g6IERhdGUubm93KCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW10sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gbGF0ZXN0QmxvY2toYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xlZXAgZm9yIGFwcHJveGltYXRlbHkgaGFsZiBhIHNsb3RcbiAgICAgICAgYXdhaXQgc2xlZXAoTVNfUEVSX1NMT1QgLyAyKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5hYmxlIHRvIG9idGFpbiBhIG5ldyBibG9ja2hhc2ggYWZ0ZXIgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCxcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25cbiAgICovXG4gIGFzeW5jIGdldFN0YWtlTWluaW11bURlbGVnYXRpb24oXG4gICAgY29uZmlnPzogR2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbkNvbmZpZyxcbiAgKTogUHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8bnVtYmVyPj4ge1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWc6IGNvbmZpZ0FyZ30gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnQXJnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoXG4gICAgICAgIHJlcy5lcnJvcixcbiAgICAgICAgYGZhaWxlZCB0byBnZXQgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2ltdWxhdGVUcmFuc2FjdGlvbn0gd2l0aCB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259IGFuZCB7QGxpbmsgU2ltdWxhdGVUcmFuc2FjdGlvbkNvbmZpZ30gcGFyYW1ldGVyc1xuICAgKi9cbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihcbiAgICB0cmFuc2FjdGlvbk9yTWVzc2FnZTogVHJhbnNhY3Rpb24gfCBNZXNzYWdlLFxuICAgIHNpZ25lcnM/OiBBcnJheTxTaWduZXI+LFxuICAgIGluY2x1ZGVBY2NvdW50cz86IGJvb2xlYW4gfCBBcnJheTxQdWJsaWNLZXk+LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlPj47XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihcbiAgICB0cmFuc2FjdGlvbjogVmVyc2lvbmVkVHJhbnNhY3Rpb24sXG4gICAgY29uZmlnPzogU2ltdWxhdGVUcmFuc2FjdGlvbkNvbmZpZyxcbiAgKTogUHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8U2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZT4+O1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24oXG4gICAgdHJhbnNhY3Rpb25Pck1lc3NhZ2U6IFZlcnNpb25lZFRyYW5zYWN0aW9uIHwgVHJhbnNhY3Rpb24gfCBNZXNzYWdlLFxuICAgIGNvbmZpZ09yU2lnbmVycz86IFNpbXVsYXRlVHJhbnNhY3Rpb25Db25maWcgfCBBcnJheTxTaWduZXI+LFxuICAgIGluY2x1ZGVBY2NvdW50cz86IGJvb2xlYW4gfCBBcnJheTxQdWJsaWNLZXk+LFxuICApOiBQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlPj4ge1xuICAgIGlmICgnbWVzc2FnZScgaW4gdHJhbnNhY3Rpb25Pck1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHZlcnNpb25lZFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB2ZXJzaW9uZWRUeC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9XG4gICAgICAgIEJ1ZmZlci5mcm9tKHdpcmVUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbmZpZzogYW55ID0gY29uZmlnT3JTaWduZXJzIHx8IHt9O1xuICAgICAgY29uZmlnLmVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICBpZiAoISgnY29tbWl0bWVudCcgaW4gY29uZmlnKSkge1xuICAgICAgICBjb25maWcuY29tbWl0bWVudCA9IHRoaXMuY29tbWl0bWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBjb25maWdPclNpZ25lcnMgJiZcbiAgICAgICAgdHlwZW9mIGNvbmZpZ09yU2lnbmVycyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2lubmVySW5zdHJ1Y3Rpb25zJyBpbiBjb25maWdPclNpZ25lcnNcbiAgICAgICkge1xuICAgICAgICBjb25maWcuaW5uZXJJbnN0cnVjdGlvbnMgPSBjb25maWdPclNpZ25lcnMuaW5uZXJJbnN0cnVjdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2ltdWxhdGVUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2ltdWxhdGUgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgaWYgKHRyYW5zYWN0aW9uT3JNZXNzYWdlIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAgIGxldCBvcmlnaW5hbFR4OiBUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gb3JpZ2luYWxUeC5mZWVQYXllcjtcbiAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucyA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlLmluc3RydWN0aW9ucztcbiAgICAgIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyA9IG9yaWdpbmFsVHgubm9uY2VJbmZvO1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcyA9IG9yaWdpbmFsVHguc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbk9yTWVzc2FnZSk7XG4gICAgICAvLyBIQUNLOiB0aGlzIGZ1bmN0aW9uIHJlbGllcyBvbiBtdXRhdGluZyB0aGUgcG9wdWxhdGVkIHRyYW5zYWN0aW9uXG4gICAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9qc29uID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChjb25maWdPclNpZ25lcnMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb25maWdPclNpZ25lcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmVycyA9IGNvbmZpZ09yU2lnbmVycztcbiAgICBpZiAodHJhbnNhY3Rpb24ubm9uY2VJbmZvICYmIHNpZ25lcnMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID1cbiAgICAgICAgICBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG5cbiAgICAgICAgaWYgKCFzaWduZXJzKSBicmVhaztcblxuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpICYmXG4gICAgICAgICAgIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0gdHJhbnNhY3Rpb24uX2NvbXBpbGUoKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gd2lyZVRyYW5zYWN0aW9uLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBjb25maWc6IGFueSA9IHtcbiAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudCxcbiAgICB9O1xuXG4gICAgaWYgKGluY2x1ZGVBY2NvdW50cykge1xuICAgICAgY29uc3QgYWRkcmVzc2VzID0gKFxuICAgICAgICBBcnJheS5pc0FycmF5KGluY2x1ZGVBY2NvdW50cylcbiAgICAgICAgICA/IGluY2x1ZGVBY2NvdW50c1xuICAgICAgICAgIDogbWVzc2FnZS5ub25Qcm9ncmFtSWRzKClcbiAgICAgICkubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG5cbiAgICAgIGNvbmZpZ1snYWNjb3VudHMnXSA9IHtcbiAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICBhZGRyZXNzZXMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzaWduZXJzKSB7XG4gICAgICBjb25maWcuc2lnVmVyaWZ5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBjb25maWdPclNpZ25lcnMgJiZcbiAgICAgIHR5cGVvZiBjb25maWdPclNpZ25lcnMgPT09ICdvYmplY3QnICYmXG4gICAgICAnaW5uZXJJbnN0cnVjdGlvbnMnIGluIGNvbmZpZ09yU2lnbmVyc1xuICAgICkge1xuICAgICAgY29uZmlnLmlubmVySW5zdHJ1Y3Rpb25zID0gY29uZmlnT3JTaWduZXJzLmlubmVySW5zdHJ1Y3Rpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICAgIGlmIChsb2dzICYmIEFycmF5LmlzQXJyYXkobG9ncykpIHtcbiAgICAgICAgICBjb25zdCB0cmFjZUluZGVudCA9ICdcXG4gICAgJztcbiAgICAgICAgICBjb25zdCBsb2dUcmFjZSA9IHRyYWNlSW5kZW50ICsgbG9ncy5qb2luKHRyYWNlSW5kZW50KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5lcnJvci5tZXNzYWdlLCBsb2dUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6ICcnLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlLFxuICAgICAgICBsb2dzOiBsb2dzLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzZW5kVHJhbnNhY3Rpb259IHdpdGggYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259XG4gICAqL1xuICBzZW5kVHJhbnNhY3Rpb24oXG4gICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLFxuICAgIHNpZ25lcnM6IEFycmF5PFNpZ25lcj4sXG4gICAgb3B0aW9ucz86IFNlbmRPcHRpb25zLFxuICApOiBQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPjtcblxuICAvKipcbiAgICogU2VuZCBhIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBzZW5kVHJhbnNhY3Rpb24oXG4gICAgdHJhbnNhY3Rpb246IFZlcnNpb25lZFRyYW5zYWN0aW9uLFxuICAgIG9wdGlvbnM/OiBTZW5kT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT47XG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24oXG4gICAgdHJhbnNhY3Rpb246IFZlcnNpb25lZFRyYW5zYWN0aW9uIHwgVHJhbnNhY3Rpb24sXG4gICAgc2lnbmVyc09yT3B0aW9ucz86IEFycmF5PFNpZ25lcj4gfCBTZW5kT3B0aW9ucyxcbiAgICBvcHRpb25zPzogU2VuZE9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+IHtcbiAgICBpZiAoJ3ZlcnNpb24nIGluIHRyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmVycyA9IHNpZ25lcnNPck9wdGlvbnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPVxuICAgICAgICAgIGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkIGFuZCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0XG4gICAqL1xuICBhc3luYyBzZW5kUmF3VHJhbnNhY3Rpb24oXG4gICAgcmF3VHJhbnNhY3Rpb246IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+LFxuICAgIG9wdGlvbnM/OiBTZW5kT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT4ge1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHRvQnVmZmVyKHJhd1RyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kRW5jb2RlZFRyYW5zYWN0aW9uKFxuICAgICAgZW5jb2RlZFRyYW5zYWN0aW9uLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQsIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICogd2lyZSBmb3JtYXQsIGFuZCBlbmNvZGVkIGFzIGEgYmFzZTY0IHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgc2VuZEVuY29kZWRUcmFuc2FjdGlvbihcbiAgICBlbmNvZGVkVHJhbnNhY3Rpb246IHN0cmluZyxcbiAgICBvcHRpb25zPzogU2VuZE9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+IHtcbiAgICBjb25zdCBjb25maWc6IGFueSA9IHtlbmNvZGluZzogJ2Jhc2U2NCd9O1xuICAgIGNvbnN0IHNraXBQcmVmbGlnaHQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcFByZWZsaWdodDtcbiAgICBjb25zdCBwcmVmbGlnaHRDb21taXRtZW50ID1cbiAgICAgIHNraXBQcmVmbGlnaHQgPT09IHRydWVcbiAgICAgICAgPyAncHJvY2Vzc2VkJyAvLyBGSVhNRSBSZW1vdmUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvcHVsbC80ODMgaXMgZGVwbG95ZWQuXG4gICAgICAgIDogKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50KSB8fCB0aGlzLmNvbW1pdG1lbnQ7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWluQ29udGV4dFNsb3QgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1pbkNvbnRleHRTbG90ID0gb3B0aW9ucy5taW5Db250ZXh0U2xvdDtcbiAgICB9XG4gICAgaWYgKHNraXBQcmVmbGlnaHQpIHtcbiAgICAgIGNvbmZpZy5za2lwUHJlZmxpZ2h0ID0gc2tpcFByZWZsaWdodDtcbiAgICB9XG4gICAgaWYgKHByZWZsaWdodENvbW1pdG1lbnQpIHtcbiAgICAgIGNvbmZpZy5wcmVmbGlnaHRDb21taXRtZW50ID0gcHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzZW5kVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgbGV0IGxvZ3MgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoJ2RhdGEnIGluIHJlcy5lcnJvcikge1xuICAgICAgICBsb2dzID0gcmVzLmVycm9yLmRhdGEubG9ncztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiBza2lwUHJlZmxpZ2h0ID8gJ3NlbmQnIDogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnJyxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiByZXMuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgbG9nczogbG9ncyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uT3BlbigpIHtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIC8vIFBpbmcgc2VydmVyIGV2ZXJ5IDVzIHRvIHByZXZlbnQgaWRsZSB0aW1lb3V0c1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQubm90aWZ5KCdwaW5nJyk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH0pKCk7XG4gICAgfSwgNTAwMCk7XG4gICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25FcnJvcihlcnI6IEVycm9yKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgY29uc29sZS5lcnJvcignd3MgZXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25DbG9zZShjb2RlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uID1cbiAgICAgICh0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uICsgMSkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDEwMDApIHtcbiAgICAgIC8vIGV4cGxpY2l0IGNsb3NlLCBjaGVjayBpZiBhbnkgc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gbWFkZSBzaW5jZSBjbG9zZVxuICAgICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGltcGxpY2l0IGNsb3NlLCBwcmVwYXJlIHN1YnNjcmlwdGlvbnMgZm9yIGF1dG8tcmVjb25uZWN0XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKFxuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCBhcyBSZWNvcmQ8U3Vic2NyaXB0aW9uQ29uZmlnSGFzaCwgU3Vic2NyaXB0aW9uPixcbiAgICApLmZvckVhY2goKFtoYXNoLCBzdWJzY3JpcHRpb25dKSA9PiB7XG4gICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgIHN0YXRlOiAncGVuZGluZycsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX3NldFN1YnNjcmlwdGlvbihcbiAgICBoYXNoOiBTdWJzY3JpcHRpb25Db25maWdIYXNoLFxuICAgIG5leHRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbixcbiAgKSB7XG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXT8uc3RhdGU7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSA9IG5leHRTdWJzY3JpcHRpb247XG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbmV4dFN1YnNjcmlwdGlvbi5zdGF0ZSkge1xuICAgICAgY29uc3Qgc3RhdGVDaGFuZ2VDYWxsYmFja3MgPVxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXTtcbiAgICAgIGlmIChzdGF0ZUNoYW5nZUNhbGxiYWNrcykge1xuICAgICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2IobmV4dFN1YnNjcmlwdGlvbi5zdGF0ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UoXG4gICAgY2xpZW50U3Vic2NyaXB0aW9uSWQ6IENsaWVudFN1YnNjcmlwdGlvbklkLFxuICAgIGNhbGxiYWNrOiBTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrLFxuICApOiBTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZURpc3Bvc2VGbiB7XG4gICAgY29uc3QgaGFzaCA9XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGhhc2ggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZUNoYW5nZUNhbGxiYWNrcyA9ICh0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtcbiAgICAgIGhhc2hcbiAgICBdIHx8PSBuZXcgU2V0KCkpO1xuICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF91cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IgaWYgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBFcnJvciB3aGVuIGNsb3Npbmcgc29ja2V0IGNvbm5lY3Rpb246ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uID0gdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbjtcbiAgICBjb25zdCBpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiA9PT0gdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbjtcbiAgICB9O1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAvLyBEb24ndCBiZSB0ZW1wdGVkIHRvIGNoYW5nZSB0aGlzIHRvIGBPYmplY3QuZW50cmllc2AuIFdlIGNhbGxcbiAgICAgIC8vIGBfdXBkYXRlU3Vic2NyaXB0aW9uc2AgcmVjdXJzaXZlbHkgd2hlbiBwcm9jZXNzaW5nIHRoZSBzdGF0ZSxcbiAgICAgIC8vIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgbG9vayB1cCB0aGUgKmN1cnJlbnQqIHZlcnNpb24gb2ZcbiAgICAgIC8vIGVhY2ggc3Vic2NyaXB0aW9uLCBldmVyeSB0aW1lIHdlIHByb2Nlc3MgYSBoYXNoLlxuICAgICAgT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkubWFwKGFzeW5jIGhhc2ggPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBUaGlzIGVudHJ5IGhhcyBzaW5jZSBiZWVuIGRlbGV0ZWQuIFNraXAuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgICAgY2FzZSAndW5zdWJzY3JpYmVkJzpcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFlvdSBjYW4gZW5kIHVwIGhlcmUgd2hlbjpcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogLSBhIHN1YnNjcmlwdGlvbiBoYXMgcmVjZW50bHkgdW5zdWJzY3JpYmVkXG4gICAgICAgICAgICAgICAqICAgd2l0aG91dCBoYXZpbmcgbmV3IGNhbGxiYWNrcyBhZGRlZCB0byBpdFxuICAgICAgICAgICAgICAgKiAgIHdoaWxlIHRoZSB1bnN1YnNjcmliZSB3YXMgaW4gZmxpZ2h0LCBvclxuICAgICAgICAgICAgICAgKiAtIHdoZW4gYSBwZW5kaW5nIHN1YnNjcmlwdGlvbiBoYXMgaXRzXG4gICAgICAgICAgICAgICAqICAgbGlzdGVuZXJzIHJlbW92ZWQgYmVmb3JlIGEgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgICAgICogICBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEJlaW5nIHRoYXQgbm9ib2R5IGlzIGludGVyZXN0ZWQgaW4gdGhpc1xuICAgICAgICAgICAgICAgKiBzdWJzY3JpcHRpb24gYW55IGxvbmdlciwgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uc3RhdGUgPT09ICd1bnN1YnNjcmliZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbXG4gICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uc2VydmVyU3Vic2NyaXB0aW9uSWRcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge2FyZ3MsIG1ldGhvZH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Vic2NyaWJpbmcnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1YnNjcmlwdGlvbklkOiBTZXJ2ZXJTdWJzY3JpcHRpb25JZCA9XG4gICAgICAgICAgICAgICAgICAoYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwobWV0aG9kLCBhcmdzKSkgYXMgbnVtYmVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Vic2NyaWJlZCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtcbiAgICAgICAgICAgICAgICAgIHNlcnZlclN1YnNjcmlwdGlvbklkXG4gICAgICAgICAgICAgICAgXSA9IHN1YnNjcmlwdGlvbi5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYCR7bWV0aG9kfSBlcnJvciBmb3IgYXJndW1lbnRgLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdWJzY3JpYmVkJzpcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gQnkgdGhlIHRpbWUgd2Ugc3VjY2Vzc2Z1bGx5IHNldCB1cCBhIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBzZXJ2ZXIsIHRoZSBjbGllbnQgc3RvcHBlZCBjYXJpbmcgYWJvdXQgaXQuXG4gICAgICAgICAgICAgIC8vIFRlYXIgaXQgZG93biBub3cuXG4gICAgICAgICAgICAgIGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qge3NlcnZlclN1YnNjcmlwdGlvbklkLCB1bnN1YnNjcmliZU1ldGhvZH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmhhcyhzZXJ2ZXJTdWJzY3JpcHRpb25JZClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICogSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgc3Vic2NyaXB0aW9uIHRoYXQgaGFzIGJlZW4gYXV0by1cbiAgICAgICAgICAgICAgICAgICAqIGRpc3Bvc2VkIGJ5IHRoZSBSUEMsIHRoZW4gd2UgY2FuIHNraXAgdGhlIFJQQyBjYWxsIHRvXG4gICAgICAgICAgICAgICAgICAgKiB0ZWFyIGRvd24gdGhlIHN1YnNjcmlwdGlvbiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmluZycsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJyxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwodW5zdWJzY3JpYmVNZXRob2QsIFtcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke3Vuc3Vic2NyaWJlTWV0aG9kfSBlcnJvcjpgLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJlZCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3Vic2NyaWJpbmcnOlxuICAgICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJpbmcnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb248XG4gICAgVENhbGxiYWNrIGV4dGVuZHMgU3Vic2NyaXB0aW9uQ29uZmlnWydjYWxsYmFjayddLFxuICA+KFxuICAgIHNlcnZlclN1YnNjcmlwdGlvbklkOiBTZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICBjYWxsYmFja0FyZ3M6IFBhcmFtZXRlcnM8VENhbGxiYWNrPixcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgY2FsbGJhY2tzID1cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc2VydmVyU3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjYihcbiAgICAgICAgICAvLyBJIGZhaWxlZCB0byBmaW5kIGEgd2F5IHRvIGNvbnZpbmNlIFR5cGVTY3JpcHQgdGhhdCBgY2JgIGlzIG9mIHR5cGVcbiAgICAgICAgICAvLyBgVENhbGxiYWNrYCB3aGljaCBpcyBjZXJ0YWlubHkgY29tcGF0aWJsZSB3aXRoIGBQYXJhbWV0ZXJzPFRDYWxsYmFjaz5gLlxuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ3NjE1XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIC4uLmNhbGxiYWNrQXJncyxcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IG9iamVjdCkge1xuICAgIGNvbnN0IHtyZXN1bHQsIHN1YnNjcmlwdGlvbn0gPSBjcmVhdGUoXG4gICAgICBub3RpZmljYXRpb24sXG4gICAgICBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0LFxuICAgICk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uPEFjY291bnRDaGFuZ2VDYWxsYmFjaz4oc3Vic2NyaXB0aW9uLCBbXG4gICAgICByZXN1bHQudmFsdWUsXG4gICAgICByZXN1bHQuY29udGV4dCxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX21ha2VTdWJzY3JpcHRpb24oXG4gICAgc3Vic2NyaXB0aW9uQ29uZmlnOiBTdWJzY3JpcHRpb25Db25maWcsXG4gICAgLyoqXG4gICAgICogV2hlbiBwcmVwYXJpbmcgYGFyZ3NgIGZvciBhIGNhbGwgdG8gYF9tYWtlU3Vic2NyaXB0aW9uYCwgYmUgc3VyZVxuICAgICAqIHRvIGNhcmVmdWxseSBhcHBseSBhIGRlZmF1bHQgYGNvbW1pdG1lbnRgIHByb3BlcnR5LCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiAtIElmIHRoZSB1c2VyIHN1cHBsaWVkIGEgYGNvbW1pdG1lbnRgIHVzZSB0aGF0LlxuICAgICAqIC0gT3RoZXJ3aXNlLCBpZiB0aGUgYENvbm5lY3Rpb246OmNvbW1pdG1lbnRgIGlzIHNldCwgdXNlIHRoYXQuXG4gICAgICogLSBPdGhlcndpc2UsIHNldCBpdCB0byB0aGUgUlBDIHNlcnZlciBkZWZhdWx0OiBgZmluYWxpemVkYC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCB0aGVzZSB0d28gZnVuZGFtZW50YWxseVxuICAgICAqIGlkZW50aWNhbCBzdWJzY3JpcHRpb25zIHByb2R1Y2UgdGhlIHNhbWUgaWRlbnRpZnlpbmcgaGFzaDpcbiAgICAgKlxuICAgICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aXRob3V0IHNwZWNpZnlpbmcgYSBjb21taXRtZW50LlxuICAgICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aGVyZSB0aGUgY29tbWl0bWVudCBzcGVjaWZpZWQgaXMgdGhlIHNhbWVcbiAgICAgKiAgIGFzIHRoZSBkZWZhdWx0IGFwcGxpZWQgdG8gdGhlIHN1YnNjcmlwdGlvbiBhYm92ZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU7IHRoZXNlIHR3byBzdWJzY3JpcHRpb25zIG11c3QgcHJvZHVjZSB0aGUgc2FtZSBoYXNoOlxuICAgICAqXG4gICAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgXG4gICAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgIHdpdGggY29tbWl0bWVudFxuICAgICAqICAgYCdmaW5hbGl6ZWQnYC5cbiAgICAgKlxuICAgICAqIFNlZSB0aGUgJ21ha2luZyBhIHN1YnNjcmlwdGlvbiB3aXRoIGRlZmF1bHRlZCBwYXJhbXMgb21pdHRlZCcgdGVzdFxuICAgICAqIGluIGBjb25uZWN0aW9uLXN1YnNjcmlwdGlvbnMudHNgIGZvciBtb3JlLlxuICAgICAqL1xuICAgIGFyZ3M6IElXU1JlcXVlc3RQYXJhbXMsXG4gICk6IENsaWVudFN1YnNjcmlwdGlvbklkIHtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCsrO1xuICAgIGNvbnN0IGhhc2ggPSBmYXN0U3RhYmxlU3RyaW5naWZ5KFtzdWJzY3JpcHRpb25Db25maWcubWV0aG9kLCBhcmdzXSk7XG4gICAgY29uc3QgZXhpc3RpbmdTdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgIGlmIChleGlzdGluZ1N1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0ge1xuICAgICAgICAuLi5zdWJzY3JpcHRpb25Db25maWcsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNhbGxiYWNrczogbmV3IFNldChbc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrXSksXG4gICAgICAgIHN0YXRlOiAncGVuZGluZycsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbi5jYWxsYmFja3MuYWRkKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGhhc2g7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbXG4gICAgICBjbGllbnRTdWJzY3JpcHRpb25JZFxuICAgIF0gPSBhc3luYyAoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbXG4gICAgICAgIGNsaWVudFN1YnNjcmlwdGlvbklkXG4gICAgICBdO1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgYSBcXGBTdWJzY3JpcHRpb25cXGAgd2hlbiB0ZWFyaW5nIGRvd24gY2xpZW50IHN1YnNjcmlwdGlvbiAjJHtjbGllbnRTdWJzY3JpcHRpb25JZH1gLFxuICAgICAgKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFja3MuZGVsZXRlKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGFjY291bnQgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25BY2NvdW50Q2hhbmdlKFxuICAgIHB1YmxpY0tleTogUHVibGljS2V5LFxuICAgIGNhbGxiYWNrOiBBY2NvdW50Q2hhbmdlQ2FsbGJhY2ssXG4gICAgY29uZmlnPzogQWNjb3VudFN1YnNjcmlwdGlvbkNvbmZpZyxcbiAgKTogQ2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBwYXNzIGluIGFuIHtAbGluayBBY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnfSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIG9uQWNjb3VudENoYW5nZShcbiAgICBwdWJsaWNLZXk6IFB1YmxpY0tleSxcbiAgICBjYWxsYmFjazogQWNjb3VudENoYW5nZUNhbGxiYWNrLFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICApOiBDbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBvbkFjY291bnRDaGFuZ2UoXG4gICAgcHVibGljS2V5OiBQdWJsaWNLZXksXG4gICAgY2FsbGJhY2s6IEFjY291bnRDaGFuZ2VDYWxsYmFjayxcbiAgICBjb21taXRtZW50T3JDb25maWc/OiBDb21taXRtZW50IHwgQWNjb3VudFN1YnNjcmlwdGlvbkNvbmZpZyxcbiAgKTogQ2xpZW50U3Vic2NyaXB0aW9uSWQge1xuICAgIGNvbnN0IHtjb21taXRtZW50LCBjb25maWd9ID1cbiAgICAgIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbcHVibGljS2V5LnRvQmFzZTU4KCldLFxuICAgICAgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLCAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICAgJ2Jhc2U2NCcsXG4gICAgICBjb25maWcsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbihcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG1ldGhvZDogJ2FjY291bnRTdWJzY3JpYmUnLFxuICAgICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2FjY291bnRVbnN1YnNjcmliZScsXG4gICAgICB9LFxuICAgICAgYXJncyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKFxuICAgIGNsaWVudFN1YnNjcmlwdGlvbklkOiBDbGllbnRTdWJzY3JpcHRpb25JZCxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oXG4gICAgICBjbGllbnRTdWJzY3JpcHRpb25JZCxcbiAgICAgICdhY2NvdW50IGNoYW5nZScsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBPYmplY3QpIHtcbiAgICBjb25zdCB7cmVzdWx0LCBzdWJzY3JpcHRpb259ID0gY3JlYXRlKFxuICAgICAgbm90aWZpY2F0aW9uLFxuICAgICAgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQsXG4gICAgKTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb248UHJvZ3JhbUFjY291bnRDaGFuZ2VDYWxsYmFjaz4oc3Vic2NyaXB0aW9uLCBbXG4gICAgICB7XG4gICAgICAgIGFjY291bnRJZDogcmVzdWx0LnZhbHVlLnB1YmtleSxcbiAgICAgICAgYWNjb3VudEluZm86IHJlc3VsdC52YWx1ZS5hY2NvdW50LFxuICAgICAgfSxcbiAgICAgIHJlc3VsdC5jb250ZXh0LFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBhY2NvdW50cyBvd25lZCBieSB0aGVcbiAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblByb2dyYW1BY2NvdW50Q2hhbmdlKFxuICAgIHByb2dyYW1JZDogUHVibGljS2V5LFxuICAgIGNhbGxiYWNrOiBQcm9ncmFtQWNjb3VudENoYW5nZUNhbGxiYWNrLFxuICAgIGNvbmZpZz86IFByb2dyYW1BY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnLFxuICApOiBDbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIHBhc3MgaW4gYSB7QGxpbmsgUHJvZ3JhbUFjY291bnRTdWJzY3JpcHRpb25Db25maWd9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgb25Qcm9ncmFtQWNjb3VudENoYW5nZShcbiAgICBwcm9ncmFtSWQ6IFB1YmxpY0tleSxcbiAgICBjYWxsYmFjazogUHJvZ3JhbUFjY291bnRDaGFuZ2VDYWxsYmFjayxcbiAgICBjb21taXRtZW50PzogQ29tbWl0bWVudCxcbiAgICBmaWx0ZXJzPzogR2V0UHJvZ3JhbUFjY291bnRzRmlsdGVyW10sXG4gICk6IENsaWVudFN1YnNjcmlwdGlvbklkO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIG9uUHJvZ3JhbUFjY291bnRDaGFuZ2UoXG4gICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXksXG4gICAgY2FsbGJhY2s6IFByb2dyYW1BY2NvdW50Q2hhbmdlQ2FsbGJhY2ssXG4gICAgY29tbWl0bWVudE9yQ29uZmlnPzogQ29tbWl0bWVudCB8IFByb2dyYW1BY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnLFxuICAgIG1heWJlRmlsdGVycz86IEdldFByb2dyYW1BY2NvdW50c0ZpbHRlcltdLFxuICApOiBDbGllbnRTdWJzY3JpcHRpb25JZCB7XG4gICAgY29uc3Qge2NvbW1pdG1lbnQsIGNvbmZpZ30gPVxuICAgICAgZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhcbiAgICAgIFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sXG4gICAgICBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgICAnYmFzZTY0JyAvKiBlbmNvZGluZyAqLyxcbiAgICAgIGNvbmZpZ1xuICAgICAgICA/IGNvbmZpZ1xuICAgICAgICA6IG1heWJlRmlsdGVyc1xuICAgICAgICAgID8ge2ZpbHRlcnM6IGFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzKG1heWJlRmlsdGVycyl9XG4gICAgICAgICAgOiB1bmRlZmluZWQgLyogZXh0cmEgKi8sXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbihcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG1ldGhvZDogJ3Byb2dyYW1TdWJzY3JpYmUnLFxuICAgICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Byb2dyYW1VbnN1YnNjcmliZScsXG4gICAgICB9LFxuICAgICAgYXJncyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lcihcbiAgICBjbGllbnRTdWJzY3JpcHRpb25JZDogQ2xpZW50U3Vic2NyaXB0aW9uSWQsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKFxuICAgICAgY2xpZW50U3Vic2NyaXB0aW9uSWQsXG4gICAgICAncHJvZ3JhbSBhY2NvdW50IGNoYW5nZScsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIGxvZ3MgYXJlIGVtaXR0ZWQuXG4gICAqL1xuICBvbkxvZ3MoXG4gICAgZmlsdGVyOiBMb2dzRmlsdGVyLFxuICAgIGNhbGxiYWNrOiBMb2dzQ2FsbGJhY2ssXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4gICk6IENsaWVudFN1YnNjcmlwdGlvbklkIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFxuICAgICAgW3R5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8ge21lbnRpb25zOiBbZmlsdGVyLnRvU3RyaW5nKCldfSA6IGZpbHRlcl0sXG4gICAgICBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbihcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG1ldGhvZDogJ2xvZ3NTdWJzY3JpYmUnLFxuICAgICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2xvZ3NVbnN1YnNjcmliZScsXG4gICAgICB9LFxuICAgICAgYXJncyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBsb2dzIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlT25Mb2dzTGlzdGVuZXIoXG4gICAgY2xpZW50U3Vic2NyaXB0aW9uSWQ6IENsaWVudFN1YnNjcmlwdGlvbklkLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2xvZ3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uTG9nc05vdGlmaWNhdGlvbihub3RpZmljYXRpb246IE9iamVjdCkge1xuICAgIGNvbnN0IHtyZXN1bHQsIHN1YnNjcmlwdGlvbn0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBMb2dzTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb248TG9nc0NhbGxiYWNrPihzdWJzY3JpcHRpb24sIFtcbiAgICAgIHJlc3VsdC52YWx1ZSxcbiAgICAgIHJlc3VsdC5jb250ZXh0LFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TbG90Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogT2JqZWN0KSB7XG4gICAgY29uc3Qge3Jlc3VsdCwgc3Vic2NyaXB0aW9ufSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3ROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbjxTbG90Q2hhbmdlQ2FsbGJhY2s+KHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2xvdENoYW5nZShjYWxsYmFjazogU2xvdENoYW5nZUNhbGxiYWNrKTogQ2xpZW50U3Vic2NyaXB0aW9uSWQge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKFxuICAgICAge1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbWV0aG9kOiAnc2xvdFN1YnNjcmliZScsXG4gICAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2xvdFVuc3Vic2NyaWJlJyxcbiAgICAgIH0sXG4gICAgICBbXSAvKiBhcmdzICovLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lcihcbiAgICBjbGllbnRTdWJzY3JpcHRpb25JZDogQ2xpZW50U3Vic2NyaXB0aW9uSWQsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKFxuICAgICAgY2xpZW50U3Vic2NyaXB0aW9uSWQsXG4gICAgICAnc2xvdCBjaGFuZ2UnLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogT2JqZWN0KSB7XG4gICAgY29uc3Qge3Jlc3VsdCwgc3Vic2NyaXB0aW9ufSA9IGNyZWF0ZShcbiAgICAgIG5vdGlmaWNhdGlvbixcbiAgICAgIFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQsXG4gICAgKTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb248U2xvdFVwZGF0ZUNhbGxiYWNrPihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IHVwZGF0ZXMuIHtAbGluayBTbG90VXBkYXRlfSdzXG4gICAqIG1heSBiZSB1c2VmdWwgdG8gdHJhY2sgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHNsb3QgdXBkYXRlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TbG90VXBkYXRlKGNhbGxiYWNrOiBTbG90VXBkYXRlQ2FsbGJhY2spOiBDbGllbnRTdWJzY3JpcHRpb25JZCB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oXG4gICAgICB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBtZXRob2Q6ICdzbG90c1VwZGF0ZXNTdWJzY3JpYmUnLFxuICAgICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RzVXBkYXRlc1Vuc3Vic2NyaWJlJyxcbiAgICAgIH0sXG4gICAgICBbXSAvKiBhcmdzICovLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIoXG4gICAgY2xpZW50U3Vic2NyaXB0aW9uSWQ6IENsaWVudFN1YnNjcmlwdGlvbklkLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihcbiAgICAgIGNsaWVudFN1YnNjcmlwdGlvbklkLFxuICAgICAgJ3Nsb3QgdXBkYXRlJyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBwcml2YXRlIGFzeW5jIF91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihcbiAgICBjbGllbnRTdWJzY3JpcHRpb25JZDogQ2xpZW50U3Vic2NyaXB0aW9uSWQsXG4gICAgc3Vic2NyaXB0aW9uTmFtZTogc3RyaW5nLFxuICApIHtcbiAgICBjb25zdCBkaXNwb3NlID1cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW1xuICAgICAgICBjbGllbnRTdWJzY3JpcHRpb25JZFxuICAgICAgXTtcbiAgICBpZiAoZGlzcG9zZSkge1xuICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdJZ25vcmVkIHVuc3Vic2NyaWJlIHJlcXVlc3QgYmVjYXVzZSBhbiBhY3RpdmUgc3Vic2NyaXB0aW9uIHdpdGggaWQgJyArXG4gICAgICAgICAgYFxcYCR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9XFxgIGZvciAnJHtzdWJzY3JpcHRpb25OYW1lfScgZXZlbnRzIGAgK1xuICAgICAgICAgICdjb3VsZCBub3QgYmUgZm91bmQuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgX2J1aWxkQXJncyhcbiAgICBhcmdzOiBBcnJheTxhbnk+LFxuICAgIG92ZXJyaWRlPzogQ29tbWl0bWVudCxcbiAgICBlbmNvZGluZz86ICdqc29uUGFyc2VkJyB8ICdiYXNlNjQnLFxuICAgIGV4dHJhPzogYW55LFxuICApOiBBcnJheTxhbnk+IHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCB8fCBlbmNvZGluZyB8fCBleHRyYSkge1xuICAgICAgbGV0IG9wdGlvbnM6IGFueSA9IHt9O1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgIGlmIChjb21taXRtZW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29tbWl0bWVudCA9IGNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZXh0cmEpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFxuICAgIGFyZ3M6IEFycmF5PGFueT4sXG4gICAgb3ZlcnJpZGU/OiBGaW5hbGl0eSxcbiAgICBlbmNvZGluZz86ICdqc29uUGFyc2VkJyB8ICdiYXNlNjQnLFxuICAgIGV4dHJhPzogYW55LFxuICApOiBBcnJheTxhbnk+IHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCAmJiAhWydjb25maXJtZWQnLCAnZmluYWxpemVkJ10uaW5jbHVkZXMoY29tbWl0bWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VzaW5nIENvbm5lY3Rpb24gd2l0aCBkZWZhdWx0IGNvbW1pdG1lbnQ6IGAnICtcbiAgICAgICAgICB0aGlzLl9jb21taXRtZW50ICtcbiAgICAgICAgICAnYCwgYnV0IG1ldGhvZCByZXF1aXJlcyBhdCBsZWFzdCBgY29uZmlybWVkYCcsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBPYmplY3QpIHtcbiAgICBjb25zdCB7cmVzdWx0LCBzdWJzY3JpcHRpb259ID0gY3JlYXRlKFxuICAgICAgbm90aWZpY2F0aW9uLFxuICAgICAgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0LFxuICAgICk7XG4gICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gJ3JlY2VpdmVkU2lnbmF0dXJlJykge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgKiBBZnRlciBhIHNpZ25hdHVyZSBpcyBwcm9jZXNzZWQsIFJQQ3MgYXV0b21hdGljYWxseSBkaXNwb3NlIG9mIHRoZVxuICAgICAgICogc3Vic2NyaXB0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gV2UgbmVlZCB0byB0cmFjayB3aGljaCBvZiB0aGVzZVxuICAgICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICAgKiB3aGV0aGVyIHRoZSBjbGllbnQgaXMgZGVhbGluZyB3aXRoIGEgbm90LXlldC1wcm9jZXNzZWQgc2lnbmF0dXJlXG4gICAgICAgKiAoaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHRlYXIgZG93biB0aGUgc2VydmVyIHN1YnNjcmlwdGlvbikgb3IgYW5cbiAgICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgICAqIGNsZWFyIG91dCB0aGUgc3Vic2NyaXB0aW9uIGxvY2FsbHkgd2l0aG91dCB0ZWxsaW5nIHRoZSBzZXJ2ZXIpLlxuICAgICAgICpcbiAgICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAqL1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb248U2lnbmF0dXJlU3Vic2NyaXB0aW9uQ2FsbGJhY2s+KFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgcmVzdWx0LnZhbHVlID09PSAncmVjZWl2ZWRTaWduYXR1cmUnXG4gICAgICAgID8gW3t0eXBlOiAncmVjZWl2ZWQnfSwgcmVzdWx0LmNvbnRleHRdXG4gICAgICAgIDogW3t0eXBlOiAnc3RhdHVzJywgcmVzdWx0OiByZXN1bHQudmFsdWV9LCByZXN1bHQuY29udGV4dF0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzaWduYXR1cmUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBzdHJpbmcgaW4gYmFzZSA1OFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIG9uIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSBjb21taXRtZW50IFNwZWNpZnkgdGhlIGNvbW1pdG1lbnQgbGV2ZWwgc2lnbmF0dXJlIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TaWduYXR1cmUoXG4gICAgc2lnbmF0dXJlOiBUcmFuc2FjdGlvblNpZ25hdHVyZSxcbiAgICBjYWxsYmFjazogU2lnbmF0dXJlUmVzdWx0Q2FsbGJhY2ssXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4gICk6IENsaWVudFN1YnNjcmlwdGlvbklkIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFxuICAgICAgW3NpZ25hdHVyZV0sXG4gICAgICBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oXG4gICAgICB7XG4gICAgICAgIGNhbGxiYWNrOiAobm90aWZpY2F0aW9uLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLnJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnLFxuICAgICAgfSxcbiAgICAgIGFyZ3MsXG4gICAgKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYSB0cmFuc2FjdGlvbiBpc1xuICAgKiByZWNlaXZlZCBhbmQvb3IgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBzdHJpbmcgaW4gYmFzZSA1OFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIG9uIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zIEVuYWJsZSByZWNlaXZlZCBub3RpZmljYXRpb25zIGFuZCBzZXQgdGhlIGNvbW1pdG1lbnRcbiAgICogICBsZXZlbCB0aGF0IHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2lnbmF0dXJlV2l0aE9wdGlvbnMoXG4gICAgc2lnbmF0dXJlOiBUcmFuc2FjdGlvblNpZ25hdHVyZSxcbiAgICBjYWxsYmFjazogU2lnbmF0dXJlU3Vic2NyaXB0aW9uQ2FsbGJhY2ssXG4gICAgb3B0aW9ucz86IFNpZ25hdHVyZVN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICk6IENsaWVudFN1YnNjcmlwdGlvbklkIHtcbiAgICBjb25zdCB7Y29tbWl0bWVudCwgLi4uZXh0cmF9ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNvbW1pdG1lbnQ6XG4gICAgICAgIChvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJywgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoXG4gICAgICBbc2lnbmF0dXJlXSxcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sXG4gICAgICBleHRyYSxcbiAgICApO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbihcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhub3RpZmljYXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZScsXG4gICAgICB9LFxuICAgICAgYXJncyxcbiAgICApO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2lnbmF0dXJlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihcbiAgICBjbGllbnRTdWJzY3JpcHRpb25JZDogQ2xpZW50U3Vic2NyaXB0aW9uSWQsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKFxuICAgICAgY2xpZW50U3Vic2NyaXB0aW9uSWQsXG4gICAgICAnc2lnbmF0dXJlIHJlc3VsdCcsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUm9vdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IE9iamVjdCkge1xuICAgIGNvbnN0IHtyZXN1bHQsIHN1YnNjcmlwdGlvbn0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBSb290Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb248Um9vdENoYW5nZUNhbGxiYWNrPihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiByb290IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgcm9vdCBjaGFuZ2VzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblJvb3RDaGFuZ2UoY2FsbGJhY2s6IFJvb3RDaGFuZ2VDYWxsYmFjayk6IENsaWVudFN1YnNjcmlwdGlvbklkIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbihcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG1ldGhvZDogJ3Jvb3RTdWJzY3JpYmUnLFxuICAgICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Jvb3RVbnN1YnNjcmliZScsXG4gICAgICB9LFxuICAgICAgW10gLyogYXJncyAqLyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSByb290IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIoXG4gICAgY2xpZW50U3Vic2NyaXB0aW9uSWQ6IENsaWVudFN1YnNjcmlwdGlvbklkLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihcbiAgICAgIGNsaWVudFN1YnNjcmlwdGlvbklkLFxuICAgICAgJ3Jvb3QgY2hhbmdlJyxcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQge2dlbmVyYXRlS2V5cGFpciwgZ2V0UHVibGljS2V5LCBFZDI1NTE5S2V5cGFpcn0gZnJvbSAnLi91dGlscy9lZDI1NTE5JztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuL3B1YmxpY2tleSc7XG5cbi8qKlxuICogS2V5cGFpciBzaWduZXIgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmVyIHtcbiAgcHVibGljS2V5OiBQdWJsaWNLZXk7XG4gIHNlY3JldEtleTogVWludDhBcnJheTtcbn1cblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleXBhaXIgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlwYWlyIHtcbiAgcHJpdmF0ZSBfa2V5cGFpcjogRWQyNTUxOUtleXBhaXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBrZXlwYWlyIGluc3RhbmNlLlxuICAgKiBHZW5lcmF0ZSByYW5kb20ga2V5cGFpciBpZiBubyB7QGxpbmsgRWQyNTUxOUtleXBhaXJ9IGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0VkMjU1MTlLZXlwYWlyfSBrZXlwYWlyIGVkMjU1MTkga2V5cGFpclxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5cGFpcj86IEVkMjU1MTlLZXlwYWlyKSB7XG4gICAgdGhpcy5fa2V5cGFpciA9IGtleXBhaXIgPz8gZ2VuZXJhdGVLZXlwYWlyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgcmFuZG9tIGtleXBhaXJcbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZSgpOiBLZXlwYWlyIHtcbiAgICByZXR1cm4gbmV3IEtleXBhaXIoZ2VuZXJhdGVLZXlwYWlyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtleXBhaXIgZnJvbSBhIHJhdyBzZWNyZXQga2V5IGJ5dGUgYXJyYXkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gcmVjcmVhdGUgYSBrZXlwYWlyIGZyb20gYSBwcmV2aW91c2x5XG4gICAqIGdlbmVyYXRlZCBzZWNyZXQga2V5LiBHZW5lcmF0aW5nIGtleXBhaXJzIGZyb20gYSByYW5kb20gc2VlZCBzaG91bGQgYmUgZG9uZVxuICAgKiB3aXRoIHRoZSB7QGxpbmsgS2V5cGFpci5mcm9tU2VlZH0gbWV0aG9kLlxuICAgKlxuICAgKiBAdGhyb3dzIGVycm9yIGlmIHRoZSBwcm92aWRlZCBzZWNyZXQga2V5IGlzIGludmFsaWQgYW5kIHZhbGlkYXRpb24gaXMgbm90IHNraXBwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWNyZXRLZXkgc2VjcmV0IGtleSBieXRlIGFycmF5XG4gICAqIEBwYXJhbSBvcHRpb25zIHNraXAgc2VjcmV0IGtleSB2YWxpZGF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY3JldEtleShcbiAgICBzZWNyZXRLZXk6IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IHtza2lwVmFsaWRhdGlvbj86IGJvb2xlYW59LFxuICApOiBLZXlwYWlyIHtcbiAgICBpZiAoc2VjcmV0S2V5LmJ5dGVMZW5ndGggIT09IDY0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gc2VjcmV0S2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICBjb25zdCBwcml2YXRlU2NhbGFyID0gc2VjcmV0S2V5LnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByaXZhdGVTY2FsYXIpO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IDMyOyBpaSsrKSB7XG4gICAgICAgIGlmIChwdWJsaWNLZXlbaWldICE9PSBjb21wdXRlZFB1YmxpY0tleVtpaV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3ZpZGVkIHNlY3JldEtleSBpcyBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKHtwdWJsaWNLZXksIHNlY3JldEtleX0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEga2V5cGFpciBmcm9tIGEgMzIgYnl0ZSBzZWVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VlZCBzZWVkIGJ5dGUgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VlZChzZWVkOiBVaW50OEFycmF5KTogS2V5cGFpciB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlZWQpO1xuICAgIGNvbnN0IHNlY3JldEtleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICBzZWNyZXRLZXkuc2V0KHNlZWQpO1xuICAgIHNlY3JldEtleS5zZXQocHVibGljS2V5LCAzMik7XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKHtwdWJsaWNLZXksIHNlY3JldEtleX0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICpcbiAgICogQHJldHVybnMge1B1YmxpY0tleX0gUHVibGljS2V5XG4gICAqL1xuICBnZXQgcHVibGljS2V5KCk6IFB1YmxpY0tleSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fa2V5cGFpci5wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByYXcgc2VjcmV0IGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBTZWNyZXQga2V5IGluIGFuIGFycmF5IG9mIFVpbnQ4IGJ5dGVzXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLl9rZXlwYWlyLnNlY3JldEtleSk7XG4gIH1cbn1cbiIsImltcG9ydCB7dG9CdWZmZXJMRX0gZnJvbSAnYmlnaW50LWJ1ZmZlcic7XG5pbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcblxuaW1wb3J0ICogYXMgTGF5b3V0IGZyb20gJy4uLy4uL2xheW91dCc7XG5pbXBvcnQge1B1YmxpY0tleX0gZnJvbSAnLi4vLi4vcHVibGlja2V5JztcbmltcG9ydCAqIGFzIGJpZ2ludExheW91dCBmcm9tICcuLi8uLi91dGlscy9iaWdpbnQnO1xuaW1wb3J0IHtTeXN0ZW1Qcm9ncmFtfSBmcm9tICcuLi9zeXN0ZW0nO1xuaW1wb3J0IHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi8uLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge2RlY29kZURhdGEsIGVuY29kZURhdGEsIElJbnN0cnVjdGlvbklucHV0RGF0YX0gZnJvbSAnLi4vLi4vaW5zdHJ1Y3Rpb24nO1xuXG5leHBvcnQgKiBmcm9tICcuL3N0YXRlJztcblxuZXhwb3J0IHR5cGUgQ3JlYXRlTG9va3VwVGFibGVQYXJhbXMgPSB7XG4gIC8qKiBBY2NvdW50IHVzZWQgdG8gZGVyaXZlIGFuZCBjb250cm9sIHRoZSBuZXcgYWRkcmVzcyBsb29rdXAgdGFibGUuICovXG4gIGF1dGhvcml0eTogUHVibGljS2V5O1xuICAvKiogQWNjb3VudCB0aGF0IHdpbGwgZnVuZCB0aGUgbmV3IGFkZHJlc3MgbG9va3VwIHRhYmxlLiAqL1xuICBwYXllcjogUHVibGljS2V5O1xuICAvKiogQSByZWNlbnQgc2xvdCBtdXN0IGJlIHVzZWQgaW4gdGhlIGRlcml2YXRpb24gcGF0aCBmb3IgZWFjaCBpbml0aWFsaXplZCB0YWJsZS4gKi9cbiAgcmVjZW50U2xvdDogYmlnaW50IHwgbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgRnJlZXplTG9va3VwVGFibGVQYXJhbXMgPSB7XG4gIC8qKiBBZGRyZXNzIGxvb2t1cCB0YWJsZSBhY2NvdW50IHRvIGZyZWV6ZS4gKi9cbiAgbG9va3VwVGFibGU6IFB1YmxpY0tleTtcbiAgLyoqIEFjY291bnQgd2hpY2ggaXMgdGhlIGN1cnJlbnQgYXV0aG9yaXR5LiAqL1xuICBhdXRob3JpdHk6IFB1YmxpY0tleTtcbn07XG5cbmV4cG9ydCB0eXBlIEV4dGVuZExvb2t1cFRhYmxlUGFyYW1zID0ge1xuICAvKiogQWRkcmVzcyBsb29rdXAgdGFibGUgYWNjb3VudCB0byBleHRlbmQuICovXG4gIGxvb2t1cFRhYmxlOiBQdWJsaWNLZXk7XG4gIC8qKiBBY2NvdW50IHdoaWNoIGlzIHRoZSBjdXJyZW50IGF1dGhvcml0eS4gKi9cbiAgYXV0aG9yaXR5OiBQdWJsaWNLZXk7XG4gIC8qKiBBY2NvdW50IHRoYXQgd2lsbCBmdW5kIHRoZSB0YWJsZSByZWFsbG9jYXRpb24uXG4gICAqIE5vdCByZXF1aXJlZCBpZiB0aGUgcmVhbGxvY2F0aW9uIGhhcyBhbHJlYWR5IGJlZW4gZnVuZGVkLiAqL1xuICBwYXllcj86IFB1YmxpY0tleTtcbiAgLyoqIExpc3Qgb2YgUHVibGljIEtleXMgdG8gYmUgYWRkZWQgdG8gdGhlIGxvb2t1cCB0YWJsZS4gKi9cbiAgYWRkcmVzc2VzOiBBcnJheTxQdWJsaWNLZXk+O1xufTtcblxuZXhwb3J0IHR5cGUgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlUGFyYW1zID0ge1xuICAvKiogQWRkcmVzcyBsb29rdXAgdGFibGUgYWNjb3VudCB0byBkZWFjdGl2YXRlLiAqL1xuICBsb29rdXBUYWJsZTogUHVibGljS2V5O1xuICAvKiogQWNjb3VudCB3aGljaCBpcyB0aGUgY3VycmVudCBhdXRob3JpdHkuICovXG4gIGF1dGhvcml0eTogUHVibGljS2V5O1xufTtcblxuZXhwb3J0IHR5cGUgQ2xvc2VMb29rdXBUYWJsZVBhcmFtcyA9IHtcbiAgLyoqIEFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgdG8gY2xvc2UuICovXG4gIGxvb2t1cFRhYmxlOiBQdWJsaWNLZXk7XG4gIC8qKiBBY2NvdW50IHdoaWNoIGlzIHRoZSBjdXJyZW50IGF1dGhvcml0eS4gKi9cbiAgYXV0aG9yaXR5OiBQdWJsaWNLZXk7XG4gIC8qKiBSZWNpcGllbnQgb2YgY2xvc2VkIGFjY291bnQgbGFtcG9ydHMuICovXG4gIHJlY2lwaWVudDogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBMb29rdXBUYWJsZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cbmV4cG9ydCB0eXBlIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlID1cbiAgfCAnQ3JlYXRlTG9va3VwVGFibGUnXG4gIHwgJ0V4dGVuZExvb2t1cFRhYmxlJ1xuICB8ICdDbG9zZUxvb2t1cFRhYmxlJ1xuICB8ICdGcmVlemVMb29rdXBUYWJsZSdcbiAgfCAnRGVhY3RpdmF0ZUxvb2t1cFRhYmxlJztcblxudHlwZSBMb29rdXBUYWJsZUluc3RydWN0aW9uSW5wdXREYXRhID0ge1xuICBDcmVhdGVMb29rdXBUYWJsZTogSUluc3RydWN0aW9uSW5wdXREYXRhICZcbiAgICBSZWFkb25seTx7XG4gICAgICByZWNlbnRTbG90OiBiaWdpbnQ7XG4gICAgICBidW1wU2VlZDogbnVtYmVyO1xuICAgIH0+O1xuICBGcmVlemVMb29rdXBUYWJsZTogSUluc3RydWN0aW9uSW5wdXREYXRhO1xuICBFeHRlbmRMb29rdXBUYWJsZTogSUluc3RydWN0aW9uSW5wdXREYXRhICZcbiAgICBSZWFkb25seTx7XG4gICAgICBudW1iZXJPZkFkZHJlc3NlczogYmlnaW50O1xuICAgICAgYWRkcmVzc2VzOiBBcnJheTxVaW50OEFycmF5PjtcbiAgICB9PjtcbiAgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlOiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGE7XG4gIENsb3NlTG9va3VwVGFibGU6IElJbnN0cnVjdGlvbklucHV0RGF0YTtcbn07XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgYWRkcmVzcyBsb29rdXAgdGFibGUgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBMb29rdXBUYWJsZUluc3RydWN0aW9uSW5wdXREYXRhWydDcmVhdGVMb29rdXBUYWJsZSddXG4gICAgPihbXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLFxuICAgICAgYmlnaW50TGF5b3V0LnU2NCgncmVjZW50U2xvdCcpLFxuICAgICAgQnVmZmVyTGF5b3V0LnU4KCdidW1wU2VlZCcpLFxuICAgIF0pLFxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgICAgIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ0ZyZWV6ZUxvb2t1cFRhYmxlJ11cbiAgICA+KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSksXG4gIH0sXG4gIEV4dGVuZExvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFxuICAgICAgTG9va3VwVGFibGVJbnN0cnVjdGlvbklucHV0RGF0YVsnRXh0ZW5kTG9va3VwVGFibGUnXVxuICAgID4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIGJpZ2ludExheW91dC51NjQoKSxcbiAgICAgIEJ1ZmZlckxheW91dC5zZXEoXG4gICAgICAgIExheW91dC5wdWJsaWNLZXkoKSxcbiAgICAgICAgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSxcbiAgICAgICAgJ2FkZHJlc3NlcycsXG4gICAgICApLFxuICAgIF0pLFxuICB9LFxuICBEZWFjdGl2YXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBMb29rdXBUYWJsZUluc3RydWN0aW9uSW5wdXREYXRhWydEZWFjdGl2YXRlTG9va3VwVGFibGUnXVxuICAgID4oW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKSxcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgICAgIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ0Nsb3NlTG9va3VwVGFibGUnXVxuICAgID4oW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogTG9va3VwVGFibGVJbnN0cnVjdGlvblR5cGUge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcblxuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuXG4gICAgbGV0IHR5cGU6IExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgW2xheW91dFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUyxcbiAgICApKSB7XG4gICAgICBpZiAoKGxheW91dCBhcyBhbnkpLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBsYXlvdXRUeXBlIGFzIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEluc3RydWN0aW9uLiBTaG91bGQgYmUgYSBMb29rdXBUYWJsZSBJbnN0cnVjdGlvbicsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVMb29rdXBUYWJsZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogQ3JlYXRlTG9va3VwVGFibGVQYXJhbXMge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcblxuICAgIGNvbnN0IHtyZWNlbnRTbG90fSA9IGRlY29kZURhdGEoXG4gICAgICBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZSxcbiAgICAgIGluc3RydWN0aW9uLmRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcGF5ZXI6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgcmVjZW50U2xvdDogTnVtYmVyKHJlY2VudFNsb3QpLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlRXh0ZW5kTG9va3VwVGFibGUoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IEV4dGVuZExvb2t1cFRhYmxlUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgMmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHthZGRyZXNzZXN9ID0gZGVjb2RlRGF0YShcbiAgICAgIExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcGF5ZXI6XG4gICAgICAgIGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMiA/IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5IDogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGJ1ZmZlciA9PiBuZXcgUHVibGljS2V5KGJ1ZmZlcikpLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlQ2xvc2VMb29rdXBUYWJsZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogQ2xvc2VMb29rdXBUYWJsZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICByZWNpcGllbnQ6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlRnJlZXplTG9va3VwVGFibGUoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IEZyZWV6ZUxvb2t1cFRhYmxlUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGRlY29kZURlYWN0aXZhdGVMb29rdXBUYWJsZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogRGVhY3RpdmF0ZUxvb2t1cFRhYmxlUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZDogUHVibGljS2V5KSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBBZGRyZXNzTG9va3VwVGFibGUgUHJvZ3JhbScsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlzTGVuZ3RoKGtleXM6IEFycmF5PGFueT4sIGV4cGVjdGVkTGVuZ3RoOiBudW1iZXIpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgc3RhdGljIHByb2dyYW1JZDogUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShcbiAgICAnQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMScsXG4gICk7XG5cbiAgc3RhdGljIGNyZWF0ZUxvb2t1cFRhYmxlKHBhcmFtczogQ3JlYXRlTG9va3VwVGFibGVQYXJhbXMpIHtcbiAgICBjb25zdCBbbG9va3VwVGFibGVBZGRyZXNzLCBidW1wU2VlZF0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhcbiAgICAgIFtwYXJhbXMuYXV0aG9yaXR5LnRvQnVmZmVyKCksIHRvQnVmZmVyTEUoQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSwgOCldLFxuICAgICAgdGhpcy5wcm9ncmFtSWQsXG4gICAgKTtcblxuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICByZWNlbnRTbG90OiBCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLFxuICAgICAgYnVtcFNlZWQ6IGJ1bXBTZWVkLFxuICAgIH0pO1xuXG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB9KSxcbiAgICAgIGxvb2t1cFRhYmxlQWRkcmVzcyxcbiAgICBdIGFzIFtUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBQdWJsaWNLZXldO1xuICB9XG5cbiAgc3RhdGljIGZyZWV6ZUxvb2t1cFRhYmxlKHBhcmFtczogRnJlZXplTG9va3VwVGFibGVQYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRnJlZXplTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG5cbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGV4dGVuZExvb2t1cFRhYmxlKHBhcmFtczogRXh0ZW5kTG9va3VwVGFibGVQYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRXh0ZW5kTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYWRkcmVzc2VzOiBwYXJhbXMuYWRkcmVzc2VzLm1hcChhZGRyID0+IGFkZHIudG9CeXRlcygpKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGlmIChwYXJhbXMucGF5ZXIpIHtcbiAgICAgIGtleXMucHVzaChcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWFjdGl2YXRlTG9va3VwVGFibGUocGFyYW1zOiBEZWFjdGl2YXRlTG9va3VwVGFibGVQYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuXG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBjbG9zZUxvb2t1cFRhYmxlKHBhcmFtczogQ2xvc2VMb29rdXBUYWJsZVBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DbG9zZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuXG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWUsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcblxuaW1wb3J0IHtcbiAgZW5jb2RlRGF0YSxcbiAgZGVjb2RlRGF0YSxcbiAgSW5zdHJ1Y3Rpb25UeXBlLFxuICBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEsXG59IGZyb20gJy4uL2luc3RydWN0aW9uJztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0IHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge3U2NH0gZnJvbSAnLi4vdXRpbHMvYmlnaW50JztcblxuLyoqXG4gKiBDb21wdXRlIEJ1ZGdldCBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25UeXBlIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG5cbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcblxuICAgIGxldCB0eXBlOiBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25UeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgIENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMsXG4gICAgKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZSBhcyBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25UeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0VW5pdHMoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IFJlcXVlc3RVbml0c1BhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHt1bml0cywgYWRkaXRpb25hbEZlZX0gPSBkZWNvZGVEYXRhKFxuICAgICAgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHMsXG4gICAgICBpbnN0cnVjdGlvbi5kYXRhLFxuICAgICk7XG4gICAgcmV0dXJuIHt1bml0cywgYWRkaXRpb25hbEZlZX07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgaGVhcCBmcmFtZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBSZXF1ZXN0SGVhcEZyYW1lUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge2J5dGVzfSA9IGRlY29kZURhdGEoXG4gICAgICBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsXG4gICAgICBpbnN0cnVjdGlvbi5kYXRhLFxuICAgICk7XG4gICAgcmV0dXJuIHtieXRlc307XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgbGltaXQgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdChcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogU2V0Q29tcHV0ZVVuaXRMaW1pdFBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHt1bml0c30gPSBkZWNvZGVEYXRhKFxuICAgICAgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuICAgIHJldHVybiB7dW5pdHN9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IHByaWNlIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0UHJpY2UoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IFNldENvbXB1dGVVbml0UHJpY2VQYXJhbXMge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7bWljcm9MYW1wb3J0c30gPSBkZWNvZGVEYXRhKFxuICAgICAgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuICAgIHJldHVybiB7bWljcm9MYW1wb3J0c307XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkOiBQdWJsaWNLZXkpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBDb21wdXRlQnVkZ2V0UHJvZ3JhbScsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGUnc1xuICovXG5leHBvcnQgdHlwZSBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25UeXBlID1cbiAgLy8gRklYTUVcbiAgLy8gSXQgd291bGQgYmUgcHJlZmVyYWJsZSBmb3IgdGhpcyB0eXBlIHRvIGJlIGBrZXlvZiBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25JbnB1dERhdGFgXG4gIC8vIGJ1dCBUeXBlZG9jIGRvZXMgbm90IHRyYW5zcGlsZSBga2V5b2ZgIGV4cHJlc3Npb25zLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvdHlwZWRvYy9pc3N1ZXMvMTg5NFxuICB8ICdSZXF1ZXN0VW5pdHMnXG4gIHwgJ1JlcXVlc3RIZWFwRnJhbWUnXG4gIHwgJ1NldENvbXB1dGVVbml0TGltaXQnXG4gIHwgJ1NldENvbXB1dGVVbml0UHJpY2UnO1xuXG50eXBlIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbklucHV0RGF0YSA9IHtcbiAgUmVxdWVzdFVuaXRzOiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJiBSZWFkb25seTxSZXF1ZXN0VW5pdHNQYXJhbXM+O1xuICBSZXF1ZXN0SGVhcEZyYW1lOiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJiBSZWFkb25seTxSZXF1ZXN0SGVhcEZyYW1lUGFyYW1zPjtcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDogSUluc3RydWN0aW9uSW5wdXREYXRhICZcbiAgICBSZWFkb25seTxTZXRDb21wdXRlVW5pdExpbWl0UGFyYW1zPjtcbiAgU2V0Q29tcHV0ZVVuaXRQcmljZTogSUluc3RydWN0aW9uSW5wdXREYXRhICZcbiAgICBSZWFkb25seTxTZXRDb21wdXRlVW5pdFByaWNlUGFyYW1zPjtcbn07XG5cbi8qKlxuICogUmVxdWVzdCB1bml0cyBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0VW5pdHNQYXJhbXMge1xuICAvKiogVW5pdHMgdG8gcmVxdWVzdCBmb3IgdHJhbnNhY3Rpb24td2lkZSBjb21wdXRlICovXG4gIHVuaXRzOiBudW1iZXI7XG4gIC8qKiBQcmlvcml0aXphdGlvbiBmZWUgbGFtcG9ydHMgKi9cbiAgYWRkaXRpb25hbEZlZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIFJlcXVlc3QgaGVhcCBmcmFtZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgUmVxdWVzdEhlYXBGcmFtZVBhcmFtcyA9IHtcbiAgLyoqIFJlcXVlc3RlZCB0cmFuc2FjdGlvbi13aWRlIHByb2dyYW0gaGVhcCBzaXplIGluIGJ5dGVzLiBNdXN0IGJlIG11bHRpcGxlIG9mIDEwMjQuIEFwcGxpZXMgdG8gZWFjaCBwcm9ncmFtLCBpbmNsdWRpbmcgQ1BJcy4gKi9cbiAgYnl0ZXM6IG51bWJlcjtcbn07XG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXRDb21wdXRlVW5pdExpbWl0UGFyYW1zIHtcbiAgLyoqIFRyYW5zYWN0aW9uLXdpZGUgY29tcHV0ZSB1bml0IGxpbWl0ICovXG4gIHVuaXRzOiBudW1iZXI7XG59XG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBwcmljZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXRDb21wdXRlVW5pdFByaWNlUGFyYW1zIHtcbiAgLyoqIFRyYW5zYWN0aW9uIGNvbXB1dGUgdW5pdCBwcmljZSB1c2VkIGZvciBwcmlvcml0aXphdGlvbiBmZWVzICovXG4gIG1pY3JvTGFtcG9ydHM6IG51bWJlciB8IGJpZ2ludDtcbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBDb21wdXRlQnVkZ2V0IEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplPHtcbiAgW0luc3RydWN0aW9uIGluIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGVdOiBJbnN0cnVjdGlvblR5cGU8XG4gICAgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uSW5wdXREYXRhW0luc3RydWN0aW9uXVxuICA+O1xufT4oe1xuICBSZXF1ZXN0VW5pdHM6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ1JlcXVlc3RVbml0cyddXG4gICAgPihbXG4gICAgICBCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCd1bml0cycpLFxuICAgICAgQnVmZmVyTGF5b3V0LnUzMignYWRkaXRpb25hbEZlZScpLFxuICAgIF0pLFxuICB9LFxuICBSZXF1ZXN0SGVhcEZyYW1lOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFxuICAgICAgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uSW5wdXREYXRhWydSZXF1ZXN0SGVhcEZyYW1lJ11cbiAgICA+KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ2J5dGVzJyldKSxcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxcbiAgICAgIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbklucHV0RGF0YVsnU2V0Q29tcHV0ZVVuaXRMaW1pdCddXG4gICAgPihbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCd1bml0cycpXSksXG4gIH0sXG4gIFNldENvbXB1dGVVbml0UHJpY2U6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ1NldENvbXB1dGVVbml0UHJpY2UnXVxuICAgID4oW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgdTY0KCdtaWNyb0xhbXBvcnRzJyldKSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBDb21wdXRlIEJ1ZGdldCBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wdXRlQnVkZ2V0UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG4gIHN0YXRpYyBwcm9ncmFtSWQ6IFB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoXG4gICAgJ0NvbXB1dGVCdWRnZXQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnLFxuICApO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzZXRDb21wdXRlVW5pdExpbWl0fSBhbmQvb3Ige0BsaW5rIHNldENvbXB1dGVVbml0UHJpY2V9XG4gICAqL1xuICBzdGF0aWMgcmVxdWVzdFVuaXRzKHBhcmFtczogUmVxdWVzdFVuaXRzUGFyYW1zKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgcmVxdWVzdEhlYXBGcmFtZShcbiAgICBwYXJhbXM6IFJlcXVlc3RIZWFwRnJhbWVQYXJhbXMsXG4gICk6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdExpbWl0KFxuICAgIHBhcmFtczogU2V0Q29tcHV0ZVVuaXRMaW1pdFBhcmFtcyxcbiAgKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuU2V0Q29tcHV0ZVVuaXRMaW1pdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCBwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIHNldENvbXB1dGVVbml0UHJpY2UoXG4gICAgcGFyYW1zOiBTZXRDb21wdXRlVW5pdFByaWNlUGFyYW1zLFxuICApOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG1pY3JvTGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubWljcm9MYW1wb3J0cyksXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5cbmltcG9ydCB7S2V5cGFpcn0gZnJvbSAnLi4va2V5cGFpcic7XG5pbXBvcnQge1B1YmxpY0tleX0gZnJvbSAnLi4vcHVibGlja2V5JztcbmltcG9ydCB7VHJhbnNhY3Rpb25JbnN0cnVjdGlvbn0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IHtzaWdufSBmcm9tICcuLi91dGlscy9lZDI1NTE5JztcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMgPSA2NDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMgPSAzMjtcbmNvbnN0IFNJR05BVFVSRV9CWVRFUyA9IDY0O1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuZXhwb3J0IHR5cGUgQ3JlYXRlRWQyNTUxOUluc3RydWN0aW9uV2l0aFB1YmxpY0tleVBhcmFtcyA9IHtcbiAgcHVibGljS2V5OiBVaW50OEFycmF5O1xuICBtZXNzYWdlOiBVaW50OEFycmF5O1xuICBzaWduYXR1cmU6IFVpbnQ4QXJyYXk7XG4gIGluc3RydWN0aW9uSW5kZXg/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB1c2luZyBhIHByaXZhdGUga2V5XG4gKi9cbmV4cG9ydCB0eXBlIENyZWF0ZUVkMjU1MTlJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5UGFyYW1zID0ge1xuICBwcml2YXRlS2V5OiBVaW50OEFycmF5O1xuICBtZXNzYWdlOiBVaW50OEFycmF5O1xuICBpbnN0cnVjdGlvbkluZGV4PzogbnVtYmVyO1xufTtcblxuY29uc3QgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQgPSBCdWZmZXJMYXlvdXQuc3RydWN0PFxuICBSZWFkb25seTx7XG4gICAgbWVzc2FnZURhdGFPZmZzZXQ6IG51bWJlcjtcbiAgICBtZXNzYWdlRGF0YVNpemU6IG51bWJlcjtcbiAgICBtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyO1xuICAgIG51bVNpZ25hdHVyZXM6IG51bWJlcjtcbiAgICBwYWRkaW5nOiBudW1iZXI7XG4gICAgcHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleDogbnVtYmVyO1xuICAgIHB1YmxpY0tleU9mZnNldDogbnVtYmVyO1xuICAgIHNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXg6IG51bWJlcjtcbiAgICBzaWduYXR1cmVPZmZzZXQ6IG51bWJlcjtcbiAgfT5cbj4oW1xuICBCdWZmZXJMYXlvdXQudTgoJ251bVNpZ25hdHVyZXMnKSxcbiAgQnVmZmVyTGF5b3V0LnU4KCdwYWRkaW5nJyksXG4gIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLFxuICBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4JyksXG4gIEJ1ZmZlckxheW91dC51MTYoJ3B1YmxpY0tleU9mZnNldCcpLFxuICBCdWZmZXJMYXlvdXQudTE2KCdwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4JyksXG4gIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksXG4gIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLFxuICBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleCcpLFxuXSk7XG5cbmV4cG9ydCBjbGFzcyBFZDI1NTE5UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGVkMjU1MTkgcHJvZ3JhbVxuICAgKi9cbiAgc3RhdGljIHByb2dyYW1JZDogUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShcbiAgICAnRWQyNTUxOVNpZ1ZlcmlmeTExMTExMTExMTExMTExMTExMTExMTExMTExMScsXG4gICk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5IGFuZCBzaWduYXR1cmUuIFRoZVxuICAgKiBwdWJsaWMga2V5IG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLCBhbmQgdGhlIHNpZ25hdHVyZVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIG9mIDY0IGJ5dGVzLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShcbiAgICBwYXJhbXM6IENyZWF0ZUVkMjU1MTlJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXlQYXJhbXMsXG4gICk6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0IHtwdWJsaWNLZXksIG1lc3NhZ2UsIHNpZ25hdHVyZSwgaW5zdHJ1Y3Rpb25JbmRleH0gPSBwYXJhbXM7XG5cbiAgICBhc3NlcnQoXG4gICAgICBwdWJsaWNLZXkubGVuZ3RoID09PSBQVUJMSUNfS0VZX0JZVEVTLFxuICAgICAgYFB1YmxpYyBLZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCxcbiAgICApO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgc2lnbmF0dXJlLmxlbmd0aCA9PT0gU0lHTkFUVVJFX0JZVEVTLFxuICAgICAgYFNpZ25hdHVyZSBtdXN0IGJlICR7U0lHTkFUVVJFX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtzaWduYXR1cmUubGVuZ3RofSBieXRlc2AsXG4gICAgKTtcblxuICAgIGNvbnN0IHB1YmxpY0tleU9mZnNldCA9IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW47XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gcHVibGljS2V5T2Zmc2V0ICsgcHVibGljS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG5cbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MobWVzc2FnZURhdGFPZmZzZXQgKyBtZXNzYWdlLmxlbmd0aCk7XG5cbiAgICBjb25zdCBpbmRleCA9XG4gICAgICBpbnN0cnVjdGlvbkluZGV4ID09IG51bGxcbiAgICAgICAgPyAweGZmZmYgLy8gQW4gaW5kZXggb2YgYHUxNjo6TUFYYCBtYWtlcyBpdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IGluc3RydWN0aW9uLlxuICAgICAgICA6IGluc3RydWN0aW9uSW5kZXg7XG5cbiAgICBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoXG4gICAgICB7XG4gICAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIHNpZ25hdHVyZU9mZnNldCxcbiAgICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICAgIHB1YmxpY0tleU9mZnNldCxcbiAgICAgICAgcHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgICBtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICB9LFxuICAgICAgaW5zdHJ1Y3Rpb25EYXRhLFxuICAgICk7XG5cbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChwdWJsaWNLZXksIHB1YmxpY0tleU9mZnNldCk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwoc2lnbmF0dXJlLCBzaWduYXR1cmVPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKG1lc3NhZ2UsIG1lc3NhZ2VEYXRhT2Zmc2V0KTtcblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogRWQyNTUxOVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkoXG4gICAgcGFyYW1zOiBDcmVhdGVFZDI1NTE5SW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleVBhcmFtcyxcbiAgKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3Qge3ByaXZhdGVLZXksIG1lc3NhZ2UsIGluc3RydWN0aW9uSW5kZXh9ID0gcGFyYW1zO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgcHJpdmF0ZUtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTLFxuICAgICAgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHJpdmF0ZUtleS5sZW5ndGh9IGJ5dGVzYCxcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXBhaXIgPSBLZXlwYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXlwYWlyLnB1YmxpY0tleS50b0J5dGVzKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKG1lc3NhZ2UsIGtleXBhaXIuc2VjcmV0S2V5KTtcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHtcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXgsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7c2VjcDI1NmsxfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5cbmV4cG9ydCBjb25zdCBlY2RzYVNpZ24gPSAoXG4gIG1zZ0hhc2g6IFBhcmFtZXRlcnM8dHlwZW9mIHNlY3AyNTZrMS5zaWduPlswXSxcbiAgcHJpdktleTogUGFyYW1ldGVyczx0eXBlb2Ygc2VjcDI1NmsxLnNpZ24+WzFdLFxuKSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZLZXkpO1xuICByZXR1cm4gW3NpZ25hdHVyZS50b0NvbXBhY3RSYXdCeXRlcygpLCBzaWduYXR1cmUucmVjb3ZlcnkhXSBhcyBjb25zdDtcbn07XG5leHBvcnQgY29uc3QgaXNWYWxpZFByaXZhdGVLZXkgPSBzZWNwMjU2azEudXRpbHMuaXNWYWxpZFByaXZhdGVLZXk7XG5leHBvcnQgY29uc3QgcHVibGljS2V5Q3JlYXRlID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleTtcbiIsImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQge2tlY2Nha18yNTZ9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5cbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0IHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQge3B1YmxpY0tleUNyZWF0ZSwgZWNkc2FTaWdufSBmcm9tICcuLi91dGlscy9zZWNwMjU2azEnO1xuaW1wb3J0IHt0b0J1ZmZlcn0gZnJvbSAnLi4vdXRpbHMvdG8tYnVmZmVyJztcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMgPSAzMjtcbmNvbnN0IEVUSEVSRVVNX0FERFJFU1NfQllURVMgPSAyMDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMgPSA2NDtcbmNvbnN0IFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSA9IDExO1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5leHBvcnQgdHlwZSBDcmVhdGVTZWNwMjU2azFJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXlQYXJhbXMgPSB7XG4gIHB1YmxpY0tleTogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj47XG4gIG1lc3NhZ2U6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+O1xuICBzaWduYXR1cmU6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+O1xuICByZWNvdmVyeUlkOiBudW1iZXI7XG4gIGluc3RydWN0aW9uSW5kZXg/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuZXhwb3J0IHR5cGUgQ3JlYXRlU2VjcDI1NmsxSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzc1BhcmFtcyA9IHtcbiAgZXRoQWRkcmVzczogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4gfCBzdHJpbmc7XG4gIG1lc3NhZ2U6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+O1xuICBzaWduYXR1cmU6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+O1xuICByZWNvdmVyeUlkOiBudW1iZXI7XG4gIGluc3RydWN0aW9uSW5kZXg/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuZXhwb3J0IHR5cGUgQ3JlYXRlU2VjcDI1NmsxSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleVBhcmFtcyA9IHtcbiAgcHJpdmF0ZUtleTogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj47XG4gIG1lc3NhZ2U6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+O1xuICBpbnN0cnVjdGlvbkluZGV4PzogbnVtYmVyO1xufTtcblxuY29uc3QgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gIFJlYWRvbmx5PHtcbiAgICBldGhBZGRyZXNzOiBVaW50OEFycmF5O1xuICAgIGV0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4OiBudW1iZXI7XG4gICAgZXRoQWRkcmVzc09mZnNldDogbnVtYmVyO1xuICAgIG1lc3NhZ2VEYXRhT2Zmc2V0OiBudW1iZXI7XG4gICAgbWVzc2FnZURhdGFTaXplOiBudW1iZXI7XG4gICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IG51bWJlcjtcbiAgICBudW1TaWduYXR1cmVzOiBudW1iZXI7XG4gICAgcmVjb3ZlcnlJZDogbnVtYmVyO1xuICAgIHNpZ25hdHVyZTogVWludDhBcnJheTtcbiAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBudW1iZXI7XG4gICAgc2lnbmF0dXJlT2Zmc2V0OiBudW1iZXI7XG4gIH0+XG4+KFtcbiAgQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksXG4gIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLFxuICBCdWZmZXJMYXlvdXQudTgoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSxcbiAgQnVmZmVyTGF5b3V0LnUxNignZXRoQWRkcmVzc09mZnNldCcpLFxuICBCdWZmZXJMYXlvdXQudTgoJ2V0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4JyksXG4gIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksXG4gIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLFxuICBCdWZmZXJMYXlvdXQudTgoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyksXG4gIEJ1ZmZlckxheW91dC5ibG9iKDIwLCAnZXRoQWRkcmVzcycpLFxuICBCdWZmZXJMYXlvdXQuYmxvYig2NCwgJ3NpZ25hdHVyZScpLFxuICBCdWZmZXJMYXlvdXQudTgoJ3JlY292ZXJ5SWQnKSxcbl0pO1xuXG5leHBvcnQgY2xhc3MgU2VjcDI1NmsxUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuICBzdGF0aWMgcHJvZ3JhbUlkOiBQdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KFxuICAgICdLZWNjYWtTZWNwMjU2azExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyxcbiAgKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIEV0aGVyZXVtIGFkZHJlc3MgZnJvbSBhIHNlY3AyNTZrMSBwdWJsaWMga2V5IGJ1ZmZlci5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBhIDY0IGJ5dGUgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyXG4gICAqL1xuICBzdGF0aWMgcHVibGljS2V5VG9FdGhBZGRyZXNzKFxuICAgIHB1YmxpY0tleTogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICk6IEJ1ZmZlciB7XG4gICAgYXNzZXJ0KFxuICAgICAgcHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUyxcbiAgICAgIGBQdWJsaWMga2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2AsXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrXzI1Nih0b0J1ZmZlcihwdWJsaWNLZXkpKSkuc2xpY2UoXG4gICAgICAgIC1FVEhFUkVVTV9BRERSRVNTX0JZVEVTLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjb25zdHJ1Y3RpbmcgRXRoZXJldW0gYWRkcmVzczogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleS4gVGhlIHB1YmxpYyBrZXlcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDY0IGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KFxuICAgIHBhcmFtczogQ3JlYXRlU2VjcDI1NmsxSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5UGFyYW1zLFxuICApOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgICBjb25zdCB7cHVibGljS2V5LCBtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5SWQsIGluc3RydWN0aW9uSW5kZXh9ID1cbiAgICAgIHBhcmFtcztcbiAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgIGV0aEFkZHJlc3M6IFNlY3AyNTZrMVByb2dyYW0ucHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGFuIEV0aGVyZXVtIGFkZHJlc3MuIFRoZSBhZGRyZXNzXG4gICAqIG11c3QgYmUgYSBoZXggc3RyaW5nIG9yIGEgYnVmZmVyIHRoYXQgaXMgMjAgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKFxuICAgIHBhcmFtczogQ3JlYXRlU2VjcDI1NmsxSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzc1BhcmFtcyxcbiAgKTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3Qge1xuICAgICAgZXRoQWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleCA9IDAsXG4gICAgfSA9IHBhcmFtcztcblxuICAgIGxldCBldGhBZGRyZXNzO1xuICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyYXdBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IEJ1ZmZlci5mcm9tKHJhd0FkZHJlc3Muc3Vic3RyKDIpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcywgJ2hleCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldGhBZGRyZXNzID0gcmF3QWRkcmVzcztcbiAgICB9XG5cbiAgICBhc3NlcnQoXG4gICAgICBldGhBZGRyZXNzLmxlbmd0aCA9PT0gRVRIRVJFVU1fQUREUkVTU19CWVRFUyxcbiAgICAgIGBBZGRyZXNzIG11c3QgYmUgJHtFVEhFUkVVTV9BRERSRVNTX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtldGhBZGRyZXNzLmxlbmd0aH0gYnl0ZXNgLFxuICAgICk7XG5cbiAgICBjb25zdCBkYXRhU3RhcnQgPSAxICsgU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFO1xuICAgIGNvbnN0IGV0aEFkZHJlc3NPZmZzZXQgPSBkYXRhU3RhcnQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gZGF0YVN0YXJ0ICsgZXRoQWRkcmVzcy5sZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoICsgMTtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcblxuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5hbGxvYyhcbiAgICAgIFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbiArIG1lc3NhZ2UubGVuZ3RoLFxuICAgICk7XG5cbiAgICBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZShcbiAgICAgIHtcbiAgICAgICAgbnVtU2lnbmF0dXJlcyxcbiAgICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgICBldGhBZGRyZXNzT2Zmc2V0LFxuICAgICAgICBldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICAgIG1lc3NhZ2VEYXRhU2l6ZTogbWVzc2FnZS5sZW5ndGgsXG4gICAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgICBzaWduYXR1cmU6IHRvQnVmZmVyKHNpZ25hdHVyZSksXG4gICAgICAgIGV0aEFkZHJlc3M6IHRvQnVmZmVyKGV0aEFkZHJlc3MpLFxuICAgICAgICByZWNvdmVyeUlkLFxuICAgICAgfSxcbiAgICAgIGluc3RydWN0aW9uRGF0YSxcbiAgICApO1xuXG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwodG9CdWZmZXIobWVzc2FnZSksIFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3Bhbik7XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhIHByaXZhdGUga2V5LiBUaGUgcHJpdmF0ZSBrZXlcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDMyIGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleShcbiAgICBwYXJhbXM6IENyZWF0ZVNlY3AyNTZrMUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXlQYXJhbXMsXG4gICk6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0IHtwcml2YXRlS2V5OiBwa2V5LCBtZXNzYWdlLCBpbnN0cnVjdGlvbkluZGV4fSA9IHBhcmFtcztcblxuICAgIGFzc2VydChcbiAgICAgIHBrZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUyxcbiAgICAgIGBQcml2YXRlIGtleSBtdXN0IGJlICR7UFJJVkFURV9LRVlfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3BrZXkubGVuZ3RofSBieXRlc2AsXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcml2YXRlS2V5ID0gdG9CdWZmZXIocGtleSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBwdWJsaWNLZXlDcmVhdGUoXG4gICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgIGZhbHNlIC8qIGlzQ29tcHJlc3NlZCAqLyxcbiAgICAgICkuc2xpY2UoMSk7IC8vIHRocm93IGF3YXkgbGVhZGluZyBieXRlXG4gICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IEJ1ZmZlci5mcm9tKGtlY2Nha18yNTYodG9CdWZmZXIobWVzc2FnZSkpKTtcbiAgICAgIGNvbnN0IFtzaWduYXR1cmUsIHJlY292ZXJ5SWRdID0gZWNkc2FTaWduKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHtcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIHJlY292ZXJ5SWQsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXgsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuXG5pbXBvcnQge1xuICBlbmNvZGVEYXRhLFxuICBkZWNvZGVEYXRhLFxuICBJbnN0cnVjdGlvblR5cGUsXG4gIElJbnN0cnVjdGlvbklucHV0RGF0YSxcbn0gZnJvbSAnLi4vaW5zdHJ1Y3Rpb24nO1xuaW1wb3J0ICogYXMgTGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQge1B1YmxpY0tleX0gZnJvbSAnLi4vcHVibGlja2V5JztcbmltcG9ydCB7U3lzdGVtUHJvZ3JhbX0gZnJvbSAnLi9zeXN0ZW0nO1xuaW1wb3J0IHtcbiAgU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgU1lTVkFSX1JFTlRfUFVCS0VZLFxuICBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksXG59IGZyb20gJy4uL3N5c3Zhcic7XG5pbXBvcnQge1RyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge3RvQnVmZmVyfSBmcm9tICcuLi91dGlscy90by1idWZmZXInO1xuXG4vKipcbiAqIEFkZHJlc3Mgb2YgdGhlIHN0YWtlIGNvbmZpZyBhY2NvdW50IHdoaWNoIGNvbmZpZ3VyZXMgdGhlIHJhdGVcbiAqIG9mIHN0YWtlIHdhcm11cCBhbmQgY29vbGRvd24gYXMgd2VsbCBhcyB0aGUgc2xhc2hpbmcgcGVuYWx0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IFNUQUtFX0NPTkZJR19JRCA9IG5ldyBQdWJsaWNLZXkoXG4gICdTdGFrZUNvbmZpZzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyxcbik7XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBhdXRob3JpdHkgaW5mb1xuICovXG5leHBvcnQgY2xhc3MgQXV0aG9yaXplZCB7XG4gIC8qKiBzdGFrZSBhdXRob3JpdHkgKi9cbiAgc3Rha2VyOiBQdWJsaWNLZXk7XG4gIC8qKiB3aXRoZHJhdyBhdXRob3JpdHkgKi9cbiAgd2l0aGRyYXdlcjogUHVibGljS2V5O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQXV0aG9yaXplZCBvYmplY3RcbiAgICogQHBhcmFtIHN0YWtlciB0aGUgc3Rha2UgYXV0aG9yaXR5XG4gICAqIEBwYXJhbSB3aXRoZHJhd2VyIHRoZSB3aXRoZHJhdyBhdXRob3JpdHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0YWtlcjogUHVibGljS2V5LCB3aXRoZHJhd2VyOiBQdWJsaWNLZXkpIHtcbiAgICB0aGlzLnN0YWtlciA9IHN0YWtlcjtcbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB3aXRoZHJhd2VyO1xuICB9XG59XG5cbnR5cGUgQXV0aG9yaXplZFJhdyA9IFJlYWRvbmx5PHtcbiAgc3Rha2VyOiBVaW50OEFycmF5O1xuICB3aXRoZHJhd2VyOiBVaW50OEFycmF5O1xufT47XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBsb2NrdXAgaW5mb1xuICovXG5leHBvcnQgY2xhc3MgTG9ja3VwIHtcbiAgLyoqIFVuaXggdGltZXN0YW1wIG9mIGxvY2t1cCBleHBpcmF0aW9uICovXG4gIHVuaXhUaW1lc3RhbXA6IG51bWJlcjtcbiAgLyoqIEVwb2NoIG9mIGxvY2t1cCBleHBpcmF0aW9uICovXG4gIGVwb2NoOiBudW1iZXI7XG4gIC8qKiBMb2NrdXAgY3VzdG9kaWFuIGF1dGhvcml0eSAqL1xuICBjdXN0b2RpYW46IFB1YmxpY0tleTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IExvY2t1cCBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVuaXhUaW1lc3RhbXA6IG51bWJlciwgZXBvY2g6IG51bWJlciwgY3VzdG9kaWFuOiBQdWJsaWNLZXkpIHtcbiAgICB0aGlzLnVuaXhUaW1lc3RhbXAgPSB1bml4VGltZXN0YW1wO1xuICAgIHRoaXMuZXBvY2ggPSBlcG9jaDtcbiAgICB0aGlzLmN1c3RvZGlhbiA9IGN1c3RvZGlhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0LCBpbmFjdGl2ZSBMb2NrdXAgdmFsdWVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0OiBMb2NrdXAgPSBuZXcgTG9ja3VwKDAsIDAsIFB1YmxpY0tleS5kZWZhdWx0KTtcbn1cblxudHlwZSBMb2NrdXBSYXcgPSBSZWFkb25seTx7XG4gIGN1c3RvZGlhbjogVWludDhBcnJheTtcbiAgZXBvY2g6IG51bWJlcjtcbiAgdW5peFRpbWVzdGFtcDogbnVtYmVyO1xufT47XG5cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIENyZWF0ZVN0YWtlQWNjb3VudFBhcmFtcyA9IHtcbiAgLyoqIEFkZHJlc3Mgb2YgdGhlIGFjY291bnQgd2hpY2ggd2lsbCBmdW5kIGNyZWF0aW9uICovXG4gIGZyb21QdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEFkZHJlc3Mgb2YgdGhlIG5ldyBzdGFrZSBhY2NvdW50ICovXG4gIHN0YWtlUHVia2V5OiBQdWJsaWNLZXk7XG4gIC8qKiBBdXRob3JpdGllcyBvZiB0aGUgbmV3IHN0YWtlIGFjY291bnQgKi9cbiAgYXV0aG9yaXplZDogQXV0aG9yaXplZDtcbiAgLyoqIExvY2t1cCBvZiB0aGUgbmV3IHN0YWtlIGFjY291bnQgKi9cbiAgbG9ja3VwPzogTG9ja3VwO1xuICAvKiogRnVuZGluZyBhbW91bnQgKi9cbiAgbGFtcG9ydHM6IG51bWJlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBDcmVhdGVTdGFrZUFjY291bnRXaXRoU2VlZFBhcmFtcyA9IHtcbiAgZnJvbVB1YmtleTogUHVibGljS2V5O1xuICBzdGFrZVB1YmtleTogUHVibGljS2V5O1xuICBiYXNlUHVia2V5OiBQdWJsaWNLZXk7XG4gIHNlZWQ6IHN0cmluZztcbiAgYXV0aG9yaXplZDogQXV0aG9yaXplZDtcbiAgbG9ja3VwPzogTG9ja3VwO1xuICBsYW1wb3J0czogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBJbml0aWFsaXplU3Rha2VQYXJhbXMgPSB7XG4gIHN0YWtlUHVia2V5OiBQdWJsaWNLZXk7XG4gIGF1dGhvcml6ZWQ6IEF1dGhvcml6ZWQ7XG4gIGxvY2t1cD86IExvY2t1cDtcbn07XG5cbi8qKlxuICogRGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIERlbGVnYXRlU3Rha2VQYXJhbXMgPSB7XG4gIHN0YWtlUHVia2V5OiBQdWJsaWNLZXk7XG4gIGF1dGhvcml6ZWRQdWJrZXk6IFB1YmxpY0tleTtcbiAgdm90ZVB1YmtleTogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhvcml6ZVN0YWtlUGFyYW1zID0ge1xuICBzdGFrZVB1YmtleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG4gIG5ld0F1dGhvcml6ZWRQdWJrZXk6IFB1YmxpY0tleTtcbiAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogU3Rha2VBdXRob3JpemF0aW9uVHlwZTtcbiAgY3VzdG9kaWFuUHVia2V5PzogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zIHVzaW5nIGEgZGVyaXZlZCBrZXlcbiAqL1xuZXhwb3J0IHR5cGUgQXV0aG9yaXplV2l0aFNlZWRTdGFrZVBhcmFtcyA9IHtcbiAgc3Rha2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgYXV0aG9yaXR5QmFzZTogUHVibGljS2V5O1xuICBhdXRob3JpdHlTZWVkOiBzdHJpbmc7XG4gIGF1dGhvcml0eU93bmVyOiBQdWJsaWNLZXk7XG4gIG5ld0F1dGhvcml6ZWRQdWJrZXk6IFB1YmxpY0tleTtcbiAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogU3Rha2VBdXRob3JpemF0aW9uVHlwZTtcbiAgY3VzdG9kaWFuUHVia2V5PzogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBTcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgU3BsaXRTdGFrZVBhcmFtcyA9IHtcbiAgc3Rha2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgYXV0aG9yaXplZFB1YmtleTogUHVibGljS2V5O1xuICBzcGxpdFN0YWtlUHVia2V5OiBQdWJsaWNLZXk7XG4gIGxhbXBvcnRzOiBudW1iZXI7XG59O1xuXG4vKipcbiAqIFNwbGl0IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgU3BsaXRTdGFrZVdpdGhTZWVkUGFyYW1zID0ge1xuICBzdGFrZVB1YmtleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG4gIHNwbGl0U3Rha2VQdWJrZXk6IFB1YmxpY0tleTtcbiAgYmFzZVB1YmtleTogUHVibGljS2V5O1xuICBzZWVkOiBzdHJpbmc7XG4gIGxhbXBvcnRzOiBudW1iZXI7XG59O1xuXG4vKipcbiAqIFdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBXaXRoZHJhd1N0YWtlUGFyYW1zID0ge1xuICBzdGFrZVB1YmtleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG4gIHRvUHVia2V5OiBQdWJsaWNLZXk7XG4gIGxhbXBvcnRzOiBudW1iZXI7XG4gIGN1c3RvZGlhblB1YmtleT86IFB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogRGVhY3RpdmF0ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuZXhwb3J0IHR5cGUgRGVhY3RpdmF0ZVN0YWtlUGFyYW1zID0ge1xuICBzdGFrZVB1YmtleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBNZXJnZVN0YWtlUGFyYW1zID0ge1xuICBzdGFrZVB1YmtleTogUHVibGljS2V5O1xuICBzb3VyY2VTdGFrZVB1YktleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIFN0YWtlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFrZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBTdGFrZUluc3RydWN0aW9uVHlwZSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuXG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuXG4gICAgbGV0IHR5cGU6IFN0YWtlSW5zdHJ1Y3Rpb25UeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZSBhcyBTdGFrZUluc3RydWN0aW9uVHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTdGFrZUluc3RydWN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgaW5pdGlhbGl6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbml0aWFsaXplKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBJbml0aWFsaXplU3Rha2VQYXJhbXMge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuXG4gICAgY29uc3Qge2F1dGhvcml6ZWQsIGxvY2t1cH0gPSBkZWNvZGVEYXRhKFxuICAgICAgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQ6IG5ldyBBdXRob3JpemVkKFxuICAgICAgICBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQuc3Rha2VyKSxcbiAgICAgICAgbmV3IFB1YmxpY0tleShhdXRob3JpemVkLndpdGhkcmF3ZXIpLFxuICAgICAgKSxcbiAgICAgIGxvY2t1cDogbmV3IExvY2t1cChcbiAgICAgICAgbG9ja3VwLnVuaXhUaW1lc3RhbXAsXG4gICAgICAgIGxvY2t1cC5lcG9jaCxcbiAgICAgICAgbmV3IFB1YmxpY0tleShsb2NrdXAuY3VzdG9kaWFuKSxcbiAgICAgICksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVEZWxlZ2F0ZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogRGVsZWdhdGVTdGFrZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNik7XG4gICAgZGVjb2RlRGF0YShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlbGVnYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IEF1dGhvcml6ZVN0YWtlUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7bmV3QXV0aG9yaXplZCwgc3Rha2VBdXRob3JpemF0aW9uVHlwZX0gPSBkZWNvZGVEYXRhKFxuICAgICAgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsXG4gICAgICBpbnN0cnVjdGlvbi5kYXRhLFxuICAgICk7XG5cbiAgICBjb25zdCBvOiBBdXRob3JpemVTdGFrZVBhcmFtcyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICB9LFxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZS13aXRoLXNlZWQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IEF1dGhvcml6ZVdpdGhTZWVkU3Rha2VQYXJhbXMge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuXG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgfSA9IGRlY29kZURhdGEoXG4gICAgICBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgY29uc3QgbzogQXV0aG9yaXplV2l0aFNlZWRTdGFrZVBhcmFtcyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2U6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5U2VlZDogYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml0eU93bmVyKSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNwbGl0IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNwbGl0KGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uKTogU3BsaXRTdGFrZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge2xhbXBvcnRzfSA9IGRlY29kZURhdGEoXG4gICAgICBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0LFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG1lcmdlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU1lcmdlKGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uKTogTWVyZ2VTdGFrZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlLCBpbnN0cnVjdGlvbi5kYXRhKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzb3VyY2VTdGFrZVB1YktleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBXaXRoZHJhd1N0YWtlUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7bGFtcG9ydHN9ID0gZGVjb2RlRGF0YShcbiAgICAgIFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsXG4gICAgICBpbnN0cnVjdGlvbi5kYXRhLFxuICAgICk7XG5cbiAgICBjb25zdCBvOiBXaXRoZHJhd1N0YWtlUGFyYW1zID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDUpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGRlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogRGVhY3RpdmF0ZVN0YWtlUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQ6IFB1YmxpY0tleSkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTdGFrZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN0YWtlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzOiBBcnJheTxhbnk+LCBleHBlY3RlZExlbmd0aDogbnVtYmVyKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VJbnN0cnVjdGlvblR5cGUnc1xuICovXG5leHBvcnQgdHlwZSBTdGFrZUluc3RydWN0aW9uVHlwZSA9XG4gIC8vIEZJWE1FXG4gIC8vIEl0IHdvdWxkIGJlIHByZWZlcmFibGUgZm9yIHRoaXMgdHlwZSB0byBiZSBga2V5b2YgU3Rha2VJbnN0cnVjdGlvbklucHV0RGF0YWBcbiAgLy8gYnV0IFR5cGVkb2MgZG9lcyBub3QgdHJhbnNwaWxlIGBrZXlvZmAgZXhwcmVzc2lvbnMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vVHlwZVN0cm9uZy90eXBlZG9jL2lzc3Vlcy8xODk0XG4gIHwgJ0F1dGhvcml6ZSdcbiAgfCAnQXV0aG9yaXplV2l0aFNlZWQnXG4gIHwgJ0RlYWN0aXZhdGUnXG4gIHwgJ0RlbGVnYXRlJ1xuICB8ICdJbml0aWFsaXplJ1xuICB8ICdNZXJnZSdcbiAgfCAnU3BsaXQnXG4gIHwgJ1dpdGhkcmF3JztcblxudHlwZSBTdGFrZUluc3RydWN0aW9uSW5wdXREYXRhID0ge1xuICBBdXRob3JpemU6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmXG4gICAgUmVhZG9ubHk8e1xuICAgICAgbmV3QXV0aG9yaXplZDogVWludDhBcnJheTtcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IG51bWJlcjtcbiAgICB9PjtcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmXG4gICAgUmVhZG9ubHk8e1xuICAgICAgYXV0aG9yaXR5T3duZXI6IFVpbnQ4QXJyYXk7XG4gICAgICBhdXRob3JpdHlTZWVkOiBzdHJpbmc7XG4gICAgICBpbnN0cnVjdGlvbjogbnVtYmVyO1xuICAgICAgbmV3QXV0aG9yaXplZDogVWludDhBcnJheTtcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IG51bWJlcjtcbiAgICB9PjtcbiAgRGVhY3RpdmF0ZTogSUluc3RydWN0aW9uSW5wdXREYXRhO1xuICBEZWxlZ2F0ZTogSUluc3RydWN0aW9uSW5wdXREYXRhO1xuICBJbml0aWFsaXplOiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJlxuICAgIFJlYWRvbmx5PHtcbiAgICAgIGF1dGhvcml6ZWQ6IEF1dGhvcml6ZWRSYXc7XG4gICAgICBsb2NrdXA6IExvY2t1cFJhdztcbiAgICB9PjtcbiAgTWVyZ2U6IElJbnN0cnVjdGlvbklucHV0RGF0YTtcbiAgU3BsaXQ6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmXG4gICAgUmVhZG9ubHk8e1xuICAgICAgbGFtcG9ydHM6IG51bWJlcjtcbiAgICB9PjtcbiAgV2l0aGRyYXc6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmXG4gICAgUmVhZG9ubHk8e1xuICAgICAgbGFtcG9ydHM6IG51bWJlcjtcbiAgICB9Pjtcbn07XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3Rha2UgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemU8e1xuICBbSW5zdHJ1Y3Rpb24gaW4gU3Rha2VJbnN0cnVjdGlvblR5cGVdOiBJbnN0cnVjdGlvblR5cGU8XG4gICAgU3Rha2VJbnN0cnVjdGlvbklucHV0RGF0YVtJbnN0cnVjdGlvbl1cbiAgPjtcbn0+KHtcbiAgSW5pdGlhbGl6ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxTdGFrZUluc3RydWN0aW9uSW5wdXREYXRhWydJbml0aWFsaXplJ10+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICBMYXlvdXQuYXV0aG9yaXplZCgpLFxuICAgICAgTGF5b3V0LmxvY2t1cCgpLFxuICAgIF0pLFxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8U3Rha2VJbnN0cnVjdGlvbklucHV0RGF0YVsnQXV0aG9yaXplJ10+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICBMYXlvdXQucHVibGljS2V5KCduZXdBdXRob3JpemVkJyksXG4gICAgICBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyksXG4gICAgXSksXG4gIH0sXG4gIERlbGVnYXRlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFN0YWtlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ0RlbGVnYXRlJ10+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgXSksXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFN0YWtlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ1NwbGl0J10+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSxcbiAgICBdKSxcbiAgfSxcbiAgV2l0aGRyYXc6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8U3Rha2VJbnN0cnVjdGlvbklucHV0RGF0YVsnV2l0aGRyYXcnXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLFxuICAgIF0pLFxuICB9LFxuICBEZWFjdGl2YXRlOiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFN0YWtlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ0RlYWN0aXZhdGUnXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICBdKSxcbiAgfSxcbiAgTWVyZ2U6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8U3Rha2VJbnN0cnVjdGlvbklucHV0RGF0YVsnTWVyZ2UnXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICBdKSxcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8U3Rha2VJbnN0cnVjdGlvbklucHV0RGF0YVsnQXV0aG9yaXplV2l0aFNlZWQnXT4oXG4gICAgICBbXG4gICAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICAgIExheW91dC5wdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSxcbiAgICAgICAgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpLFxuICAgICAgICBMYXlvdXQucnVzdFN0cmluZygnYXV0aG9yaXR5U2VlZCcpLFxuICAgICAgICBMYXlvdXQucHVibGljS2V5KCdhdXRob3JpdHlPd25lcicpLFxuICAgICAgXSxcbiAgICApLFxuICB9LFxufSk7XG5cbi8qKlxuICogU3Rha2UgYXV0aG9yaXphdGlvbiB0eXBlXG4gKi9cbmV4cG9ydCB0eXBlIFN0YWtlQXV0aG9yaXphdGlvblR5cGUgPSB7XG4gIC8qKiBUaGUgU3Rha2UgQXV0aG9yaXphdGlvbiBpbmRleCAoZnJvbSBzb2xhbmEtc3Rha2UtcHJvZ3JhbSkgKi9cbiAgaW5kZXg6IG51bWJlcjtcbn07XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0J3NcbiAqL1xuZXhwb3J0IGNvbnN0IFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBTdGFrZXI6IHtcbiAgICBpbmRleDogMCxcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxLFxuICB9LFxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFN0YWtlIHByb2dyYW1cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YWtlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN0YWtlIHByb2dyYW1cbiAgICovXG4gIHN0YXRpYyBwcm9ncmFtSWQ6IFB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoXG4gICAgJ1N0YWtlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnLFxuICApO1xuXG4gIC8qKlxuICAgKiBNYXggc3BhY2Ugb2YgYSBTdGFrZSBhY2NvdW50XG4gICAqXG4gICAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS1zdGFrZS1wcm9ncmFtIFN0YWtlU3RhdGUgc3RydWN0IGFzXG4gICAqIGBTdGFrZVN0YXRlVjI6OnNpemVfb2YoKWA6XG4gICAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtc3Rha2UtcHJvZ3JhbS9sYXRlc3Qvc29sYW5hX3N0YWtlX3Byb2dyYW0vc3Rha2Vfc3RhdGUvZW51bS5TdGFrZVN0YXRlVjIuaHRtbFxuICAgKi9cbiAgc3RhdGljIHNwYWNlOiBudW1iZXIgPSAyMDA7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24gdG8gYWRkIHRvIGEgU3Rha2UgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZShwYXJhbXM6IEluaXRpYWxpemVTdGFrZVBhcmFtcyk6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0IHtzdGFrZVB1YmtleSwgYXV0aG9yaXplZCwgbG9ja3VwOiBtYXliZUxvY2t1cH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbG9ja3VwOiBMb2NrdXAgPSBtYXliZUxvY2t1cCB8fCBMb2NrdXAuZGVmYXVsdDtcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHtcbiAgICAgICAgc3Rha2VyOiB0b0J1ZmZlcihhdXRob3JpemVkLnN0YWtlci50b0J1ZmZlcigpKSxcbiAgICAgICAgd2l0aGRyYXdlcjogdG9CdWZmZXIoYXV0aG9yaXplZC53aXRoZHJhd2VyLnRvQnVmZmVyKCkpLFxuICAgICAgfSxcbiAgICAgIGxvY2t1cDoge1xuICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgZXBvY2g6IGxvY2t1cC5lcG9jaCxcbiAgICAgICAgY3VzdG9kaWFuOiB0b0J1ZmZlcihsb2NrdXAuY3VzdG9kaWFuLnRvQnVmZmVyKCkpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHN0YWtlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgICB7cHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgU3Rha2UgYWNjb3VudCBhdFxuICAgKiAgIGFuIGFkZHJlc3MgZ2VuZXJhdGVkIHdpdGggYGZyb21gLCBhIHNlZWQsIGFuZCB0aGUgU3Rha2UgcHJvZ3JhbUlkXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudFdpdGhTZWVkKFxuICAgIHBhcmFtczogQ3JlYXRlU3Rha2VBY2NvdW50V2l0aFNlZWRQYXJhbXMsXG4gICk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChcbiAgICAgIFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudFdpdGhTZWVkKHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgICAgYmFzZVB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCB7c3Rha2VQdWJrZXksIGF1dGhvcml6ZWQsIGxvY2t1cH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe3N0YWtlUHVia2V5LCBhdXRob3JpemVkLCBsb2NrdXB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgU3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zOiBDcmVhdGVTdGFrZUFjY291bnRQYXJhbXMpOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoXG4gICAgICBTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCB7c3Rha2VQdWJrZXksIGF1dGhvcml6ZWQsIGxvY2t1cH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe3N0YWtlUHVia2V5LCBhdXRob3JpemVkLCBsb2NrdXB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlbGVnYXRlcyBTdGFrZSB0b2tlbnMgdG8gYSB2YWxpZGF0b3JcbiAgICogVm90ZSBQdWJsaWNLZXkuIFRoaXMgdHJhbnNhY3Rpb24gY2FuIGFsc28gYmUgdXNlZCB0byByZWRlbGVnYXRlIFN0YWtlXG4gICAqIHRvIGEgbmV3IHZhbGlkYXRvciBWb3RlIFB1YmxpY0tleS5cbiAgICovXG4gIHN0YXRpYyBkZWxlZ2F0ZShwYXJhbXM6IERlbGVnYXRlU3Rha2VQYXJhbXMpOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3Qge3N0YWtlUHVia2V5LCBhdXRob3JpemVkUHVia2V5LCB2b3RlUHVia2V5fSA9IHBhcmFtcztcblxuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlbGVnYXRlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHN0YWtlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgICB7cHVia2V5OiB2b3RlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICAgICAge3B1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHtwdWJrZXk6IFNUQUtFX0NPTkZJR19JRCwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICAgIHtwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICBdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZShwYXJhbXM6IEF1dGhvcml6ZVN0YWtlUGFyYW1zKTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgY3VzdG9kaWFuUHVia2V5LFxuICAgIH0gPSBwYXJhbXM7XG5cbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgfSk7XG5cbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAge3B1YmtleTogc3Rha2VQdWJrZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICB7cHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAge3B1YmtleTogYXV0aG9yaXplZFB1YmtleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICBdO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtczogQXV0aG9yaXplV2l0aFNlZWRTdGFrZVBhcmFtcyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2UsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IHRvQnVmZmVyKGF1dGhvcml0eU93bmVyLnRvQnVmZmVyKCkpLFxuICAgIH0pO1xuXG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHtwdWJrZXk6IHN0YWtlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAge3B1YmtleTogYXV0aG9yaXR5QmFzZSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICAgIHtwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgIF07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBzcGxpdEluc3RydWN0aW9uKHBhcmFtczogU3BsaXRTdGFrZVBhcmFtcyk6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0IHtzdGFrZVB1YmtleSwgYXV0aG9yaXplZFB1YmtleSwgc3BsaXRTdGFrZVB1YmtleSwgbGFtcG9ydHN9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtsYW1wb3J0c30pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHN0YWtlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgICB7cHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgICB7cHVia2V5OiBhdXRob3JpemVkUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBzdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgc3BsaXQoXG4gICAgcGFyYW1zOiBTcGxpdFN0YWtlUGFyYW1zLFxuICAgIC8vIENvbXB1dGUgdGhlIGNvc3Qgb2YgYWxsb2NhdGluZyB0aGUgbmV3IHN0YWtlIGFjY291bnQgaW4gbGFtcG9ydHNcbiAgICByZW50RXhlbXB0UmVzZXJ2ZTogbnVtYmVyLFxuICApOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoXG4gICAgICBTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZSxcbiAgICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICB9KSxcbiAgICApO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAqIGRlcml2ZWQgZnJvbSBhIGJhc2UgcHVibGljIGtleSBhbmQgc2VlZFxuICAgKi9cbiAgc3RhdGljIHNwbGl0V2l0aFNlZWQoXG4gICAgcGFyYW1zOiBTcGxpdFN0YWtlV2l0aFNlZWRQYXJhbXMsXG4gICAgLy8gSWYgdGhpcyBzdGFrZSBhY2NvdW50IGlzIG5ldywgY29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIGl0IGluIGxhbXBvcnRzXG4gICAgcmVudEV4ZW1wdFJlc2VydmU/OiBudW1iZXIsXG4gICk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFxuICAgICAgU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgIGFjY291bnRQdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGJhc2VQdWJrZXksXG4gICAgICAgIHNlZWQsXG4gICAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgfSksXG4gICAgKTtcbiAgICBpZiAocmVudEV4ZW1wdFJlc2VydmUgJiYgcmVudEV4ZW1wdFJlc2VydmUgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoXG4gICAgICAgIFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICAgIHRvUHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKFxuICAgICAgdGhpcy5zcGxpdEluc3RydWN0aW9uKHtcbiAgICAgICAgc3Rha2VQdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgbWVyZ2VzIFN0YWtlIGFjY291bnRzLlxuICAgKi9cbiAgc3RhdGljIG1lcmdlKHBhcmFtczogTWVyZ2VTdGFrZVBhcmFtcyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB7c3Rha2VQdWJrZXksIHNvdXJjZVN0YWtlUHViS2V5LCBhdXRob3JpemVkUHVia2V5fSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5czogW1xuICAgICAgICB7cHVia2V5OiBzdGFrZVB1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAge3B1YmtleTogc291cmNlU3Rha2VQdWJLZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIHtwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7cHVia2V5OiBhdXRob3JpemVkUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCB3aXRoZHJhd3MgZGVhY3RpdmF0ZWQgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtczogV2l0aGRyYXdTdGFrZVBhcmFtcyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB7c3Rha2VQdWJrZXksIGF1dGhvcml6ZWRQdWJrZXksIHRvUHVia2V5LCBsYW1wb3J0cywgY3VzdG9kaWFuUHVia2V5fSA9XG4gICAgICBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge2xhbXBvcnRzfSk7XG5cbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAge3B1YmtleTogc3Rha2VQdWJrZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICB7cHVia2V5OiB0b1B1YmtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlfSxcbiAgICAgIHtwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB7cHVia2V5OiBhdXRob3JpemVkUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgIF07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgZGVhY3RpdmF0ZXMgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIGRlYWN0aXZhdGUocGFyYW1zOiBEZWFjdGl2YXRlU3Rha2VQYXJhbXMpOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3Qge3N0YWtlUHVia2V5LCBhdXRob3JpemVkUHVia2V5fSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHN0YWtlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAgICB7cHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICAgICAge3B1YmtleTogYXV0aG9yaXplZFB1YmtleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICAgIF0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5cbmltcG9ydCB7XG4gIGVuY29kZURhdGEsXG4gIGRlY29kZURhdGEsXG4gIEluc3RydWN0aW9uVHlwZSxcbiAgSUluc3RydWN0aW9uSW5wdXREYXRhLFxufSBmcm9tICcuLi9pbnN0cnVjdGlvbic7XG5pbXBvcnQgKiBhcyBMYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCB7UHVibGljS2V5fSBmcm9tICcuLi9wdWJsaWNrZXknO1xuaW1wb3J0IHtTeXN0ZW1Qcm9ncmFtfSBmcm9tICcuL3N5c3RlbSc7XG5pbXBvcnQge1NZU1ZBUl9DTE9DS19QVUJLRVksIFNZU1ZBUl9SRU5UX1BVQktFWX0gZnJvbSAnLi4vc3lzdmFyJztcbmltcG9ydCB7VHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb259IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7dG9CdWZmZXJ9IGZyb20gJy4uL3V0aWxzL3RvLWJ1ZmZlcic7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xuZXhwb3J0IGNsYXNzIFZvdGVJbml0IHtcbiAgbm9kZVB1YmtleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkVm90ZXI6IFB1YmxpY0tleTtcbiAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IFB1YmxpY0tleTtcbiAgY29tbWlzc2lvbjogbnVtYmVyOyAvKiogWzAsIDEwMF0gKi9cblxuICBjb25zdHJ1Y3RvcihcbiAgICBub2RlUHVia2V5OiBQdWJsaWNLZXksXG4gICAgYXV0aG9yaXplZFZvdGVyOiBQdWJsaWNLZXksXG4gICAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IFB1YmxpY0tleSxcbiAgICBjb21taXNzaW9uOiBudW1iZXIsXG4gICkge1xuICAgIHRoaXMubm9kZVB1YmtleSA9IG5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSBhdXRob3JpemVkVm90ZXI7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGNvbW1pc3Npb247XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBDcmVhdGVWb3RlQWNjb3VudFBhcmFtcyA9IHtcbiAgZnJvbVB1YmtleTogUHVibGljS2V5O1xuICB2b3RlUHVia2V5OiBQdWJsaWNLZXk7XG4gIHZvdGVJbml0OiBWb3RlSW5pdDtcbiAgbGFtcG9ydHM6IG51bWJlcjtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZUFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIEluaXRpYWxpemVBY2NvdW50UGFyYW1zID0ge1xuICB2b3RlUHVia2V5OiBQdWJsaWNLZXk7XG4gIG5vZGVQdWJrZXk6IFB1YmxpY0tleTtcbiAgdm90ZUluaXQ6IFZvdGVJbml0O1xufTtcblxuLyoqXG4gKiBBdXRob3JpemUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhvcml6ZVZvdGVQYXJhbXMgPSB7XG4gIHZvdGVQdWJrZXk6IFB1YmxpY0tleTtcbiAgLyoqIEN1cnJlbnQgdm90ZSBvciB3aXRoZHJhdyBhdXRob3JpdHksIGRlcGVuZGluZyBvbiBgdm90ZUF1dGhvcml6YXRpb25UeXBlYCAqL1xuICBhdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG4gIG5ld0F1dGhvcml6ZWRQdWJrZXk6IFB1YmxpY0tleTtcbiAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiBWb3RlQXV0aG9yaXphdGlvblR5cGU7XG59O1xuXG4vKipcbiAqIEF1dGhvcml6ZVdpdGhTZWVkIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBBdXRob3JpemVWb3RlV2l0aFNlZWRQYXJhbXMgPSB7XG4gIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleTogUHVibGljS2V5O1xuICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiBQdWJsaWNLZXk7XG4gIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogc3RyaW5nO1xuICBuZXdBdXRob3JpemVkUHVia2V5OiBQdWJsaWNLZXk7XG4gIHZvdGVBdXRob3JpemF0aW9uVHlwZTogVm90ZUF1dGhvcml6YXRpb25UeXBlO1xuICB2b3RlUHVia2V5OiBQdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIFdpdGhkcmF3IGZyb20gdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5leHBvcnQgdHlwZSBXaXRoZHJhd0Zyb21Wb3RlQWNjb3VudFBhcmFtcyA9IHtcbiAgdm90ZVB1YmtleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleTogUHVibGljS2V5O1xuICBsYW1wb3J0czogbnVtYmVyO1xuICB0b1B1YmtleTogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgdm90ZSBhY2NvdW50IGluc3RydWN0aW9uIHBhcmFtcy5cbiAqL1xuZXhwb3J0IHR5cGUgVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHlQYXJhbXMgPSB7XG4gIHZvdGVQdWJrZXk6IFB1YmxpY0tleTtcbiAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IFB1YmxpY0tleTtcbiAgbm9kZVB1YmtleTogUHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBWb3RlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBWb3RlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogVm90ZUluc3RydWN0aW9uVHlwZSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuXG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuXG4gICAgbGV0IHR5cGU6IFZvdGVJbnN0cnVjdGlvblR5cGUgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGUgYXMgVm90ZUluc3RydWN0aW9uVHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBWb3RlSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gaW5pdGlhbGl6ZSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemVBY2NvdW50KFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICApOiBJbml0aWFsaXplQWNjb3VudFBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNCk7XG5cbiAgICBjb25zdCB7dm90ZUluaXR9ID0gZGVjb2RlRGF0YShcbiAgICAgIFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplQWNjb3VudCxcbiAgICAgIGluc3RydWN0aW9uLmRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5LFxuICAgICAgdm90ZUluaXQ6IG5ldyBWb3RlSW5pdChcbiAgICAgICAgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5ub2RlUHVia2V5KSxcbiAgICAgICAgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIpLFxuICAgICAgICBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgICAgdm90ZUluaXQuY29tbWlzc2lvbixcbiAgICAgICksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZShcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogQXV0aG9yaXplVm90ZVBhcmFtcyB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG5cbiAgICBjb25zdCB7bmV3QXV0aG9yaXplZCwgdm90ZUF1dGhvcml6YXRpb25UeXBlfSA9IGRlY29kZURhdGEoXG4gICAgICBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChcbiAgICBpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbiAgKTogQXV0aG9yaXplVm90ZVdpdGhTZWVkUGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M6IHtcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICB9LFxuICAgIH0gPSBkZWNvZGVEYXRhKFxuICAgICAgVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiBuZXcgUHVibGljS2V5KFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgKSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgfSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoXG4gICAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gICk6IFdpdGhkcmF3RnJvbVZvdGVBY2NvdW50UGFyYW1zIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcblxuICAgIGNvbnN0IHtsYW1wb3J0c30gPSBkZWNvZGVEYXRhKFxuICAgICAgVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LFxuICAgICAgaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQ6IFB1YmxpY0tleSkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhWb3RlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgVm90ZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5czogQXJyYXk8YW55PiwgZXhwZWN0ZWRMZW5ndGg6IG51bWJlcikge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5leHBvcnQgdHlwZSBWb3RlSW5zdHJ1Y3Rpb25UeXBlID1cbiAgLy8gRklYTUVcbiAgLy8gSXQgd291bGQgYmUgcHJlZmVyYWJsZSBmb3IgdGhpcyB0eXBlIHRvIGJlIGBrZXlvZiBWb3RlSW5zdHJ1Y3Rpb25JbnB1dERhdGFgXG4gIC8vIGJ1dCBUeXBlZG9jIGRvZXMgbm90IHRyYW5zcGlsZSBga2V5b2ZgIGV4cHJlc3Npb25zLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvdHlwZWRvYy9pc3N1ZXMvMTg5NFxuICB8ICdBdXRob3JpemUnXG4gIHwgJ0F1dGhvcml6ZVdpdGhTZWVkJ1xuICB8ICdJbml0aWFsaXplQWNjb3VudCdcbiAgfCAnV2l0aGRyYXcnXG4gIHwgJ1VwZGF0ZVZhbGlkYXRvcklkZW50aXR5JztcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHR5cGUgVm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IFJlYWRvbmx5PHtcbiAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogVWludDhBcnJheTtcbiAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBzdHJpbmc7XG4gIG5ld0F1dGhvcml6ZWQ6IFVpbnQ4QXJyYXk7XG4gIHZvdGVBdXRob3JpemF0aW9uVHlwZTogbnVtYmVyO1xufT47XG50eXBlIFZvdGVJbnN0cnVjdGlvbklucHV0RGF0YSA9IHtcbiAgQXV0aG9yaXplOiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJiB7XG4gICAgbmV3QXV0aG9yaXplZDogVWludDhBcnJheTtcbiAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IG51bWJlcjtcbiAgfTtcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IElJbnN0cnVjdGlvbklucHV0RGF0YSAmIHtcbiAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiBWb3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzO1xuICB9O1xuICBJbml0aWFsaXplQWNjb3VudDogSUluc3RydWN0aW9uSW5wdXREYXRhICYge1xuICAgIHZvdGVJbml0OiBSZWFkb25seTx7XG4gICAgICBhdXRob3JpemVkVm90ZXI6IFVpbnQ4QXJyYXk7XG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlcjogVWludDhBcnJheTtcbiAgICAgIGNvbW1pc3Npb246IG51bWJlcjtcbiAgICAgIG5vZGVQdWJrZXk6IFVpbnQ4QXJyYXk7XG4gICAgfT47XG4gIH07XG4gIFdpdGhkcmF3OiBJSW5zdHJ1Y3Rpb25JbnB1dERhdGEgJiB7XG4gICAgbGFtcG9ydHM6IG51bWJlcjtcbiAgfTtcbiAgVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk6IElJbnN0cnVjdGlvbklucHV0RGF0YTtcbn07XG5cbmNvbnN0IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemU8e1xuICBbSW5zdHJ1Y3Rpb24gaW4gVm90ZUluc3RydWN0aW9uVHlwZV06IEluc3RydWN0aW9uVHlwZTxcbiAgICBWb3RlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbSW5zdHJ1Y3Rpb25dXG4gID47XG59Pih7XG4gIEluaXRpYWxpemVBY2NvdW50OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0PFZvdGVJbnN0cnVjdGlvbklucHV0RGF0YVsnSW5pdGlhbGl6ZUFjY291bnQnXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIExheW91dC52b3RlSW5pdCgpLFxuICAgIF0pLFxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8Vm90ZUluc3RydWN0aW9uSW5wdXREYXRhWydBdXRob3JpemUnXT4oW1xuICAgICAgQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSxcbiAgICAgIExheW91dC5wdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSxcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ3ZvdGVBdXRob3JpemF0aW9uVHlwZScpLFxuICAgIF0pLFxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxWb3RlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ1dpdGhkcmF3J10+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSxcbiAgICBdKSxcbiAgfSxcbiAgVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3Q8XG4gICAgICBWb3RlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ1VwZGF0ZVZhbGlkYXRvcklkZW50aXR5J11cbiAgICA+KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSksXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdDxWb3RlSW5zdHJ1Y3Rpb25JbnB1dERhdGFbJ0F1dGhvcml6ZVdpdGhTZWVkJ10+KFtcbiAgICAgIEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksXG4gICAgICBMYXlvdXQudm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncygpLFxuICAgIF0pLFxuICB9LFxufSk7XG5cbi8qKlxuICogVm90ZUF1dGhvcml6ZSB0eXBlXG4gKi9cbmV4cG9ydCB0eXBlIFZvdGVBdXRob3JpemF0aW9uVHlwZSA9IHtcbiAgLyoqIFRoZSBWb3RlQXV0aG9yaXplIGluZGV4IChmcm9tIHNvbGFuYS12b3RlLXByb2dyYW0pICovXG4gIGluZGV4OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVBdXRob3JpemF0aW9uIGxheW91dHMuXG4gKi9cbmV4cG9ydCBjb25zdCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBWb3Rlcjoge1xuICAgIGluZGV4OiAwLFxuICB9LFxuICBXaXRoZHJhd2VyOiB7XG4gICAgaW5kZXg6IDEsXG4gIH0sXG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVm90ZSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBWb3RlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFZvdGUgcHJvZ3JhbVxuICAgKi9cbiAgc3RhdGljIHByb2dyYW1JZDogUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShcbiAgICAnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScsXG4gICk7XG5cbiAgLyoqXG4gICAqIE1heCBzcGFjZSBvZiBhIFZvdGUgYWNjb3VudFxuICAgKlxuICAgKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtdm90ZS1wcm9ncmFtIFZvdGVTdGF0ZSBzdHJ1Y3QgYXNcbiAgICogYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYDpcbiAgICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS12b3RlLXByb2dyYW0vMS45LjUvc29sYW5hX3ZvdGVfcHJvZ3JhbS92b3RlX3N0YXRlL3N0cnVjdC5Wb3RlU3RhdGUuaHRtbCNtZXRob2Quc2l6ZV9vZlxuICAgKlxuICAgKiBLRUVQIElOIFNZTkMgV0lUSCBgVm90ZVN0YXRlOjpzaXplX29mKClgIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9hNDc0Y2IyNGI5MjM4ZjVlZGNjOTgyZjY1YzBiMzdkNGExMDQ2ZjdlL3Nkay9wcm9ncmFtL3NyYy92b3RlL3N0YXRlL21vZC5ycyNMMzQwLUwzNDJcbiAgICovXG4gIHN0YXRpYyBzcGFjZTogbnVtYmVyID0gMzc2MjtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gSW5pdGlhbGl6ZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBpbml0aWFsaXplQWNjb3VudChcbiAgICBwYXJhbXM6IEluaXRpYWxpemVBY2NvdW50UGFyYW1zLFxuICApOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgICBjb25zdCB7dm90ZVB1YmtleSwgbm9kZVB1YmtleSwgdm90ZUluaXR9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUluaXQ6IHtcbiAgICAgICAgbm9kZVB1YmtleTogdG9CdWZmZXIodm90ZUluaXQubm9kZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFZvdGVyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiB0b0J1ZmZlcihcbiAgICAgICAgICB2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlci50b0J1ZmZlcigpLFxuICAgICAgICApLFxuICAgICAgICBjb21taXNzaW9uOiB2b3RlSW5pdC5jb21taXNzaW9uLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbXG4gICAgICAgIHtwdWJrZXk6IHZvdGVQdWJrZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIHtwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICAgIHtwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgICB7cHVia2V5OiBub2RlUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zOiBDcmVhdGVWb3RlQWNjb3VudFBhcmFtcyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChcbiAgICAgIFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZChcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFjY291bnQoe1xuICAgICAgICB2b3RlUHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgICAgbm9kZVB1YmtleTogcGFyYW1zLnZvdGVJbml0Lm5vZGVQdWJrZXksXG4gICAgICAgIHZvdGVJbml0OiBwYXJhbXMudm90ZUluaXQsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zOiBBdXRob3JpemVWb3RlUGFyYW1zKTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4LFxuICAgIH0pO1xuXG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHtwdWJrZXk6IHZvdGVQdWJrZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICB7cHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICAgIHtwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgXTtcblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudFxuICAgKiB3aGVyZSB0aGUgY3VycmVudCBWb3RlciBvciBXaXRoZHJhd2VyIGF1dGhvcml0eSBpcyBhIGRlcml2ZWQga2V5LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtczogQXV0aG9yaXplVm90ZVdpdGhTZWVkUGFyYW1zKTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgdm90ZVB1YmtleSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXk6IHRvQnVmZmVyKFxuICAgICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkudG9CdWZmZXIoKSxcbiAgICAgICAgKSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICB7cHVia2V5OiB2b3RlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAge3B1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZX0sXG4gICAgICB7XG4gICAgICAgIHB1YmtleTogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zOiBXaXRoZHJhd0Zyb21Wb3RlQWNjb3VudFBhcmFtcyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB7dm90ZVB1YmtleSwgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksIGxhbXBvcnRzLCB0b1B1YmtleX0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdztcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7bGFtcG9ydHN9KTtcblxuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICB7cHVia2V5OiB2b3RlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAge3B1YmtleTogdG9QdWJrZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZX0sXG4gICAgICB7cHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBzYWZlbHkgZnJvbSBhIFZvdGUgYWNjb3VudC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3YXMgY3JlYXRlZCBhcyBhIHNhZmVndWFyZCBmb3Igdm90ZSBhY2NvdW50cyBydW5uaW5nIHZhbGlkYXRvcnMsIGBzYWZlV2l0aGRyYXdgXG4gICAqIGNoZWNrcyB0aGF0IHRoZSB3aXRoZHJhdyBhbW91bnQgd2lsbCBub3QgZXhjZWVkIHRoZSBzcGVjaWZpZWQgYmFsYW5jZSB3aGlsZSBsZWF2aW5nIGVub3VnaCBsZWZ0XG4gICAqIHRvIGNvdmVyIHJlbnQuIElmIHlvdSB3aXNoIHRvIGNsb3NlIHRoZSB2b3RlIGFjY291bnQgYnkgd2l0aGRyYXdpbmcgdGhlIGZ1bGwgYW1vdW50LCBjYWxsIHRoZVxuICAgKiBgd2l0aGRyYXdgIG1ldGhvZCBkaXJlY3RseS5cbiAgICovXG4gIHN0YXRpYyBzYWZlV2l0aGRyYXcoXG4gICAgcGFyYW1zOiBXaXRoZHJhd0Zyb21Wb3RlQWNjb3VudFBhcmFtcyxcbiAgICBjdXJyZW50Vm90ZUFjY291bnRCYWxhbmNlOiBudW1iZXIsXG4gICAgcmVudEV4ZW1wdE1pbmltdW06IG51bWJlcixcbiAgKTogVHJhbnNhY3Rpb24ge1xuICAgIGlmIChwYXJhbXMubGFtcG9ydHMgPiBjdXJyZW50Vm90ZUFjY291bnRCYWxhbmNlIC0gcmVudEV4ZW1wdE1pbmltdW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1dpdGhkcmF3IHdpbGwgbGVhdmUgdm90ZSBhY2NvdW50IHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzLicsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gVm90ZVByb2dyYW0ud2l0aGRyYXcocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgb2YgYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkoXG4gICAgcGFyYW1zOiBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eVBhcmFtcyxcbiAgKTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHt2b3RlUHVia2V5LCBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSwgbm9kZVB1YmtleX0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5VcGRhdGVWYWxpZGF0b3JJZGVudGl0eTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcblxuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICB7cHVia2V5OiB2b3RlUHVia2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWV9LFxuICAgICAge3B1YmtleTogbm9kZVB1YmtleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlfSxcbiAgICAgIHtwdWJrZXk6IGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2V9LFxuICAgIF07XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQge1xuICBhc3NlcnQgYXMgYXNzZXJ0VHlwZSxcbiAgb3B0aW9uYWwsXG4gIHN0cmluZyxcbiAgdHlwZSBhcyBwaWNrLFxufSBmcm9tICdzdXBlcnN0cnVjdCc7XG5cbmltcG9ydCAqIGFzIExheW91dCBmcm9tICcuL2xheW91dCc7XG5pbXBvcnQgKiBhcyBzaG9ydHZlYyBmcm9tICcuL3V0aWxzL3Nob3J0dmVjLWVuY29kaW5nJztcbmltcG9ydCB7UHVibGljS2V5LCBQVUJMSUNfS0VZX0xFTkdUSH0gZnJvbSAnLi9wdWJsaWNrZXknO1xuaW1wb3J0IHtndWFyZGVkU2hpZnQsIGd1YXJkZWRTcGxpY2V9IGZyb20gJy4vdXRpbHMvZ3VhcmRlZC1hcnJheS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBWQUxJREFUT1JfSU5GT19LRVkgPSBuZXcgUHVibGljS2V5KFxuICAnVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScsXG4pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG50eXBlIENvbmZpZ0tleSA9IHtcbiAgcHVibGljS2V5OiBQdWJsaWNLZXk7XG4gIGlzU2lnbmVyOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBJbmZvIHVzZWQgdG8gaWRlbnRpdHkgdmFsaWRhdG9ycy5cbiAqL1xuZXhwb3J0IHR5cGUgSW5mbyA9IHtcbiAgLyoqIHZhbGlkYXRvciBuYW1lICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqIG9wdGlvbmFsLCB2YWxpZGF0b3Igd2Vic2l0ZSAqL1xuICB3ZWJzaXRlPzogc3RyaW5nO1xuICAvKiogb3B0aW9uYWwsIGV4dHJhIGluZm9ybWF0aW9uIHRoZSB2YWxpZGF0b3IgY2hvc2UgdG8gc2hhcmUgKi9cbiAgZGV0YWlscz86IHN0cmluZztcbiAgLyoqIG9wdGlvbmFsLCB2YWxpZGF0b3IgbG9nbyBVUkwgKi9cbiAgaWNvblVybD86IHN0cmluZztcbiAgLyoqIG9wdGlvbmFsLCB1c2VkIHRvIGlkZW50aWZ5IHZhbGlkYXRvcnMgb24ga2V5YmFzZS5pbyAqL1xuICBrZXliYXNlVXNlcm5hbWU/OiBzdHJpbmc7XG59O1xuXG5jb25zdCBJbmZvU3RyaW5nID0gcGljayh7XG4gIG5hbWU6IHN0cmluZygpLFxuICB3ZWJzaXRlOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGRldGFpbHM6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgaWNvblVybDogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBrZXliYXNlVXNlcm5hbWU6IG9wdGlvbmFsKHN0cmluZygpKSxcbn0pO1xuXG4vKipcbiAqIFZhbGlkYXRvckluZm8gY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRvckluZm8ge1xuICAvKipcbiAgICogdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICovXG4gIGtleTogUHVibGljS2V5O1xuICAvKipcbiAgICogdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBpbmZvOiBJbmZvO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSB2YWxpZCBWYWxpZGF0b3JJbmZvXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIGluZm8gdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXk6IFB1YmxpY0tleSwgaW5mbzogSW5mbykge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVmFsaWRhdG9ySW5mbyBmcm9tIHRoZSBjb25maWcgYWNjb3VudCBkYXRhLiBFeGFjdGx5IHR3byBjb25maWdcbiAgICoga2V5cyBhcmUgcmVxdWlyZWQgaW4gdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgY29uZmlnIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIG51bGwgaWYgaW5mbyB3YXMgbm90IGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZ0RhdGEoXG4gICAgYnVmZmVyOiBCdWZmZXIgfCBVaW50OEFycmF5IHwgQXJyYXk8bnVtYmVyPixcbiAgKTogVmFsaWRhdG9ySW5mbyB8IG51bGwge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IHNob3J0dmVjLmRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBjb25maWdLZXlzOiBBcnJheTxDb25maWdLZXk+ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoXG4gICAgICAgIGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCksXG4gICAgICApO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7cHVibGljS2V5LCBpc1NpZ25lcn0pO1xuICAgIH1cblxuICAgIGlmIChjb25maWdLZXlzWzBdLnB1YmxpY0tleS5lcXVhbHMoVkFMSURBVE9SX0lORk9fS0VZKSkge1xuICAgICAgaWYgKGNvbmZpZ0tleXNbMV0uaXNTaWduZXIpIHtcbiAgICAgICAgY29uc3QgcmF3SW5mbzogYW55ID0gTGF5b3V0LnJ1c3RTdHJpbmcoKS5kZWNvZGUoQnVmZmVyLmZyb20oYnl0ZUFycmF5KSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKHJhd0luZm8gYXMgc3RyaW5nKTtcbiAgICAgICAgYXNzZXJ0VHlwZShpbmZvLCBJbmZvU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0b3JJbmZvKGNvbmZpZ0tleXNbMV0ucHVibGljS2V5LCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgdHlwZSB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuXG5pbXBvcnQgKiBhcyBMYXlvdXQgZnJvbSAnLi9sYXlvdXQnO1xuaW1wb3J0IHtQdWJsaWNLZXl9IGZyb20gJy4vcHVibGlja2V5JztcbmltcG9ydCB7dG9CdWZmZXJ9IGZyb20gJy4vdXRpbHMvdG8tYnVmZmVyJztcblxuZXhwb3J0IGNvbnN0IFZPVEVfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoXG4gICdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyxcbik7XG5cbmV4cG9ydCB0eXBlIExvY2tvdXQgPSB7XG4gIHNsb3Q6IG51bWJlcjtcbiAgY29uZmlybWF0aW9uQ291bnQ6IG51bWJlcjtcbn07XG5cbi8qKlxuICogSGlzdG9yeSBvZiBob3cgbWFueSBjcmVkaXRzIGVhcm5lZCBieSB0aGUgZW5kIG9mIGVhY2ggZXBvY2hcbiAqL1xuZXhwb3J0IHR5cGUgRXBvY2hDcmVkaXRzID0gUmVhZG9ubHk8e1xuICBlcG9jaDogbnVtYmVyO1xuICBjcmVkaXRzOiBudW1iZXI7XG4gIHByZXZDcmVkaXRzOiBudW1iZXI7XG59PjtcblxuZXhwb3J0IHR5cGUgQXV0aG9yaXplZFZvdGVyID0gUmVhZG9ubHk8e1xuICBlcG9jaDogbnVtYmVyO1xuICBhdXRob3JpemVkVm90ZXI6IFB1YmxpY0tleTtcbn0+O1xuXG50eXBlIEF1dGhvcml6ZWRWb3RlclJhdyA9IFJlYWRvbmx5PHtcbiAgYXV0aG9yaXplZFZvdGVyOiBVaW50OEFycmF5O1xuICBlcG9jaDogbnVtYmVyO1xufT47XG5cbnR5cGUgUHJpb3JWb3RlcnMgPSBSZWFkb25seTx7XG4gIGJ1ZjogUHJpb3JWb3RlclJhd1tdO1xuICBpZHg6IG51bWJlcjtcbiAgaXNFbXB0eTogbnVtYmVyO1xufT47XG5cbmV4cG9ydCB0eXBlIFByaW9yVm90ZXIgPSBSZWFkb25seTx7XG4gIGF1dGhvcml6ZWRQdWJrZXk6IFB1YmxpY0tleTtcbiAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoOiBudW1iZXI7XG4gIHRhcmdldEVwb2NoOiBudW1iZXI7XG59PjtcblxudHlwZSBQcmlvclZvdGVyUmF3ID0gUmVhZG9ubHk8e1xuICBhdXRob3JpemVkUHVia2V5OiBVaW50OEFycmF5O1xuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2g6IG51bWJlcjtcbiAgdGFyZ2V0RXBvY2g6IG51bWJlcjtcbn0+O1xuXG5leHBvcnQgdHlwZSBCbG9ja1RpbWVzdGFtcCA9IFJlYWRvbmx5PHtcbiAgc2xvdDogbnVtYmVyO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn0+O1xuXG50eXBlIFZvdGVBY2NvdW50RGF0YSA9IFJlYWRvbmx5PHtcbiAgYXV0aG9yaXplZFZvdGVyczogQXV0aG9yaXplZFZvdGVyUmF3W107XG4gIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBVaW50OEFycmF5O1xuICBjb21taXNzaW9uOiBudW1iZXI7XG4gIGVwb2NoQ3JlZGl0czogRXBvY2hDcmVkaXRzW107XG4gIGxhc3RUaW1lc3RhbXA6IEJsb2NrVGltZXN0YW1wO1xuICBub2RlUHVia2V5OiBVaW50OEFycmF5O1xuICBwcmlvclZvdGVyczogUHJpb3JWb3RlcnM7XG4gIHJvb3RTbG90OiBudW1iZXI7XG4gIHJvb3RTbG90VmFsaWQ6IG51bWJlcjtcbiAgdm90ZXM6IExvY2tvdXRbXTtcbn0+O1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOGExMmVkMDI5Y2ZhMzhkNGE0NTQwMDkxNmMyNDYzZmI4MmJiZWM4Yy9wcm9ncmFtcy92b3RlX2FwaS9zcmMvdm90ZV9zdGF0ZS5ycyNMNjgtTDg4XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFZvdGVBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdDxWb3RlQWNjb3VudERhdGE+KFtcbiAgTGF5b3V0LnB1YmxpY0tleSgnbm9kZVB1YmtleScpLFxuICBMYXlvdXQucHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLFxuICBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKSxcbiAgQnVmZmVyTGF5b3V0Lm51NjQoKSwgLy8gdm90ZXMubGVuZ3RoXG4gIEJ1ZmZlckxheW91dC5zZXE8TG9ja291dD4oXG4gICAgQnVmZmVyTGF5b3V0LnN0cnVjdChbXG4gICAgICBCdWZmZXJMYXlvdXQubnU2NCgnc2xvdCcpLFxuICAgICAgQnVmZmVyTGF5b3V0LnUzMignY29uZmlybWF0aW9uQ291bnQnKSxcbiAgICBdKSxcbiAgICBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLFxuICAgICd2b3RlcycsXG4gICksXG4gIEJ1ZmZlckxheW91dC51OCgncm9vdFNsb3RWYWxpZCcpLFxuICBCdWZmZXJMYXlvdXQubnU2NCgncm9vdFNsb3QnKSxcbiAgQnVmZmVyTGF5b3V0Lm51NjQoKSwgLy8gYXV0aG9yaXplZFZvdGVycy5sZW5ndGhcbiAgQnVmZmVyTGF5b3V0LnNlcTxBdXRob3JpemVkVm90ZXJSYXc+KFxuICAgIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW1xuICAgICAgQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksXG4gICAgICBMYXlvdXQucHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKSxcbiAgICBdKSxcbiAgICBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLFxuICAgICdhdXRob3JpemVkVm90ZXJzJyxcbiAgKSxcbiAgQnVmZmVyTGF5b3V0LnN0cnVjdDxQcmlvclZvdGVycz4oXG4gICAgW1xuICAgICAgQnVmZmVyTGF5b3V0LnNlcShcbiAgICAgICAgQnVmZmVyTGF5b3V0LnN0cnVjdChbXG4gICAgICAgICAgTGF5b3V0LnB1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLFxuICAgICAgICAgIEJ1ZmZlckxheW91dC5udTY0KCdlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gnKSxcbiAgICAgICAgICBCdWZmZXJMYXlvdXQubnU2NCgndGFyZ2V0RXBvY2gnKSxcbiAgICAgICAgXSksXG4gICAgICAgIDMyLFxuICAgICAgICAnYnVmJyxcbiAgICAgICksXG4gICAgICBCdWZmZXJMYXlvdXQubnU2NCgnaWR4JyksXG4gICAgICBCdWZmZXJMYXlvdXQudTgoJ2lzRW1wdHknKSxcbiAgICBdLFxuICAgICdwcmlvclZvdGVycycsXG4gICksXG4gIEJ1ZmZlckxheW91dC5udTY0KCksIC8vIGVwb2NoQ3JlZGl0cy5sZW5ndGhcbiAgQnVmZmVyTGF5b3V0LnNlcTxFcG9jaENyZWRpdHM+KFxuICAgIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW1xuICAgICAgQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksXG4gICAgICBCdWZmZXJMYXlvdXQubnU2NCgnY3JlZGl0cycpLFxuICAgICAgQnVmZmVyTGF5b3V0Lm51NjQoJ3ByZXZDcmVkaXRzJyksXG4gICAgXSksXG4gICAgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSxcbiAgICAnZXBvY2hDcmVkaXRzJyxcbiAgKSxcbiAgQnVmZmVyTGF5b3V0LnN0cnVjdDxCbG9ja1RpbWVzdGFtcD4oXG4gICAgW0J1ZmZlckxheW91dC5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCd0aW1lc3RhbXAnKV0sXG4gICAgJ2xhc3RUaW1lc3RhbXAnLFxuICApLFxuXSk7XG5cbnR5cGUgVm90ZUFjY291bnRBcmdzID0ge1xuICBub2RlUHVia2V5OiBQdWJsaWNLZXk7XG4gIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBQdWJsaWNLZXk7XG4gIGNvbW1pc3Npb246IG51bWJlcjtcbiAgcm9vdFNsb3Q6IG51bWJlciB8IG51bGw7XG4gIHZvdGVzOiBMb2Nrb3V0W107XG4gIGF1dGhvcml6ZWRWb3RlcnM6IEF1dGhvcml6ZWRWb3RlcltdO1xuICBwcmlvclZvdGVyczogUHJpb3JWb3RlcltdO1xuICBlcG9jaENyZWRpdHM6IEVwb2NoQ3JlZGl0c1tdO1xuICBsYXN0VGltZXN0YW1wOiBCbG9ja1RpbWVzdGFtcDtcbn07XG5cbi8qKlxuICogVm90ZUFjY291bnQgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFZvdGVBY2NvdW50IHtcbiAgbm9kZVB1YmtleTogUHVibGljS2V5O1xuICBhdXRob3JpemVkV2l0aGRyYXdlcjogUHVibGljS2V5O1xuICBjb21taXNzaW9uOiBudW1iZXI7XG4gIHJvb3RTbG90OiBudW1iZXIgfCBudWxsO1xuICB2b3RlczogTG9ja291dFtdO1xuICBhdXRob3JpemVkVm90ZXJzOiBBdXRob3JpemVkVm90ZXJbXTtcbiAgcHJpb3JWb3RlcnM6IFByaW9yVm90ZXJbXTtcbiAgZXBvY2hDcmVkaXRzOiBFcG9jaENyZWRpdHNbXTtcbiAgbGFzdFRpbWVzdGFtcDogQmxvY2tUaW1lc3RhbXA7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJnczogVm90ZUFjY291bnRBcmdzKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gYXJncy5ub2RlUHVia2V5O1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSBhcmdzLmF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGFyZ3MuY29tbWlzc2lvbjtcbiAgICB0aGlzLnJvb3RTbG90ID0gYXJncy5yb290U2xvdDtcbiAgICB0aGlzLnZvdGVzID0gYXJncy52b3RlcztcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSBhcmdzLmF1dGhvcml6ZWRWb3RlcnM7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IGFyZ3MucHJpb3JWb3RlcnM7XG4gICAgdGhpcy5lcG9jaENyZWRpdHMgPSBhcmdzLmVwb2NoQ3JlZGl0cztcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSBhcmdzLmxhc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVm90ZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIFZvdGVBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKFxuICAgIGJ1ZmZlcjogQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICk6IFZvdGVBY2NvdW50IHtcbiAgICBjb25zdCB2ZXJzaW9uT2Zmc2V0ID0gNDtcbiAgICBjb25zdCB2YSA9IFZvdGVBY2NvdW50TGF5b3V0LmRlY29kZSh0b0J1ZmZlcihidWZmZXIpLCB2ZXJzaW9uT2Zmc2V0KTtcblxuICAgIGxldCByb290U2xvdDogbnVtYmVyIHwgbnVsbCA9IHZhLnJvb3RTbG90O1xuICAgIGlmICghdmEucm9vdFNsb3RWYWxpZCkge1xuICAgICAgcm9vdFNsb3QgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXAsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoLFxufTogQXV0aG9yaXplZFZvdGVyUmF3KTogQXV0aG9yaXplZFZvdGVyIHtcbiAgcmV0dXJuIHtcbiAgICBlcG9jaCxcbiAgICBhdXRob3JpemVkVm90ZXI6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZFZvdGVyKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQcmlvclZvdGVycyh7XG4gIGF1dGhvcml6ZWRQdWJrZXksXG4gIGVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCxcbiAgdGFyZ2V0RXBvY2gsXG59OiBQcmlvclZvdGVyUmF3KTogUHJpb3JWb3RlciB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2gsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtidWYsIGlkeCwgaXNFbXB0eX06IFByaW9yVm90ZXJzKTogUHJpb3JWb3RlcltdIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gW1xuICAgIC4uLmJ1Zi5zbGljZShpZHggKyAxKS5tYXAocGFyc2VQcmlvclZvdGVycyksXG4gICAgLi4uYnVmLnNsaWNlKDAsIGlkeCkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLFxuICBdO1xufVxuIiwiY29uc3QgZW5kcG9pbnQgPSB7XG4gIGh0dHA6IHtcbiAgICBkZXZuZXQ6ICdodHRwOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJyxcbiAgICB0ZXN0bmV0OiAnaHR0cDovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb20nLFxuICAgICdtYWlubmV0LWJldGEnOiAnaHR0cDovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nLFxuICB9LFxuICBodHRwczoge1xuICAgIGRldm5ldDogJ2h0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJyxcbiAgICB0ZXN0bmV0OiAnaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tJyxcbiAgICAnbWFpbm5ldC1iZXRhJzogJ2h0dHBzOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLycsXG4gIH0sXG59O1xuXG5leHBvcnQgdHlwZSBDbHVzdGVyID0gJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJztcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIFJQQyBBUEkgVVJMIGZvciB0aGUgc3BlY2lmaWVkIGNsdXN0ZXJcbiAqIEBwYXJhbSB7Q2x1c3Rlcn0gW2NsdXN0ZXI9XCJkZXZuZXRcIl0gLSBUaGUgY2x1c3RlciBuYW1lIG9mIHRoZSBSUEMgQVBJIFVSTCB0byB1c2UuIFBvc3NpYmxlIG9wdGlvbnM6ICdkZXZuZXQnIHwgJ3Rlc3RuZXQnIHwgJ21haW5uZXQtYmV0YSdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rscz1cImh0dHBcIl0gLSBVc2UgVExTIHdoZW4gY29ubmVjdGluZyB0byBjbHVzdGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBzdHJpbmcgb2YgdGhlIFJQQyBlbmRwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2x1c3RlckFwaVVybChjbHVzdGVyPzogQ2x1c3RlciwgdGxzPzogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuXG4gIGlmICghY2x1c3Rlcikge1xuICAgIHJldHVybiBlbmRwb2ludFtrZXldWydkZXZuZXQnXTtcbiAgfVxuXG4gIGNvbnN0IHVybCA9IGVuZHBvaW50W2tleV1bY2x1c3Rlcl07XG4gIGlmICghdXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duICR7a2V5fSBjbHVzdGVyOiAke2NsdXN0ZXJ9YCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbiIsImltcG9ydCB0eXBlIHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5cbmltcG9ydCB7XG4gIEJsb2NraGVpZ2h0QmFzZWRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5LFxuICBDb25uZWN0aW9uLFxuICBEdXJhYmxlTm9uY2VUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5LFxuICBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5LFxufSBmcm9tICcuLi9jb25uZWN0aW9uJztcbmltcG9ydCB0eXBlIHtUcmFuc2FjdGlvblNpZ25hdHVyZX0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHR5cGUge0NvbmZpcm1PcHRpb25zfSBmcm9tICcuLi9jb25uZWN0aW9uJztcbmltcG9ydCB7U2VuZFRyYW5zYWN0aW9uRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8qKlxuICogU2VuZCBhbmQgY29uZmlybSBhIHJhdyB0cmFuc2FjdGlvblxuICpcbiAqIElmIGBjb21taXRtZW50YCBvcHRpb24gaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gJ21heCcgY29tbWl0bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSByYXdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5fSBjb25maXJtYXRpb25TdHJhdGVneVxuICogQHBhcmFtIHtDb25maXJtT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uKFxuICBjb25uZWN0aW9uOiBDb25uZWN0aW9uLFxuICByYXdUcmFuc2FjdGlvbjogQnVmZmVyLFxuICBjb25maXJtYXRpb25TdHJhdGVneTogVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneSxcbiAgb3B0aW9ucz86IENvbmZpcm1PcHRpb25zLFxuKTogUHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT47XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uKFxuICBjb25uZWN0aW9uOiBDb25uZWN0aW9uLFxuICByYXdUcmFuc2FjdGlvbjogQnVmZmVyLFxuICBvcHRpb25zPzogQ29uZmlybU9wdGlvbnMsXG4pOiBQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24oXG4gIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gIHJhd1RyYW5zYWN0aW9uOiBCdWZmZXIsXG4gIGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9uczpcbiAgICB8IFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3lcbiAgICB8IENvbmZpcm1PcHRpb25zXG4gICAgfCB1bmRlZmluZWQsXG4gIG1heWJlQ29uZmlybU9wdGlvbnM/OiBDb25maXJtT3B0aW9ucyxcbik6IFByb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+IHtcbiAgbGV0IGNvbmZpcm1hdGlvblN0cmF0ZWd5OiBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5IHwgdW5kZWZpbmVkO1xuICBsZXQgb3B0aW9uczogQ29uZmlybU9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gIGlmIChcbiAgICBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsXG4gICAgICAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnLFxuICAgIClcbiAgKSB7XG4gICAgY29uZmlybWF0aW9uU3RyYXRlZ3kgPVxuICAgICAgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zIGFzIEJsb2NraGVpZ2h0QmFzZWRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5O1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2UgaWYgKFxuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyxcbiAgICAgICdub25jZVZhbHVlJyxcbiAgICApXG4gICkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID1cbiAgICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyBhcyBEdXJhYmxlTm9uY2VUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5O1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgYXNcbiAgICAgIHwgQ29uZmlybU9wdGlvbnNcbiAgICAgIHwgdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3QsXG4gIH07XG5cbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oXG4gICAgcmF3VHJhbnNhY3Rpb24sXG4gICAgc2VuZE9wdGlvbnMsXG4gICk7XG5cbiAgY29uc3QgY29tbWl0bWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50O1xuICBjb25zdCBjb25maXJtYXRpb25Qcm9taXNlID0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAgICA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KVxuICAgIDogY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KTtcbiAgY29uc3Qgc3RhdHVzID0gKGF3YWl0IGNvbmZpcm1hdGlvblByb21pc2UpLnZhbHVlO1xuXG4gIGlmIChzdGF0dXMuZXJyKSB7XG4gICAgaWYgKHNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246IHNlbmRPcHRpb25zPy5za2lwUHJlZmxpZ2h0ID8gJ3NlbmQnIDogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogYFN0YXR1czogKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmF3IHRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vYWNjb3VudCc7XG5leHBvcnQgKiBmcm9tICcuL2Jsb2NraGFzaCc7XG5leHBvcnQgKiBmcm9tICcuL2JwZi1sb2FkZXItZGVwcmVjYXRlZCc7XG5leHBvcnQgKiBmcm9tICcuL2JwZi1sb2FkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9jb25uZWN0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vZXBvY2gtc2NoZWR1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9mZWUtY2FsY3VsYXRvcic7XG5leHBvcnQgKiBmcm9tICcuL2tleXBhaXInO1xuZXhwb3J0ICogZnJvbSAnLi9sb2FkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9tZXNzYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vbm9uY2UtYWNjb3VudCc7XG5leHBvcnQgKiBmcm9tICcuL3Byb2dyYW1zJztcbmV4cG9ydCAqIGZyb20gJy4vcHVibGlja2V5JztcbmV4cG9ydCAqIGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuZXhwb3J0ICogZnJvbSAnLi92YWxpZGF0b3ItaW5mbyc7XG5leHBvcnQgKiBmcm9tICcuL3ZvdGUtYWNjb3VudCc7XG5leHBvcnQgKiBmcm9tICcuL3N5c3Zhcic7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBUaGVyZSBhcmUgMS1iaWxsaW9uIGxhbXBvcnRzIGluIG9uZSBTT0xcbiAqL1xuZXhwb3J0IGNvbnN0IExBTVBPUlRTX1BFUl9TT0wgPSAxMDAwMDAwMDAwO1xuIl0sIm5hbWVzIjpbImdlbmVyYXRlUHJpdmF0ZUtleSIsImVkMjU1MTkiLCJ1dGlscyIsInJhbmRvbVByaXZhdGVLZXkiLCJnZW5lcmF0ZUtleXBhaXIiLCJwcml2YXRlU2NhbGFyIiwicHVibGljS2V5IiwiZ2V0UHVibGljS2V5Iiwic2VjcmV0S2V5IiwiVWludDhBcnJheSIsInNldCIsImlzT25DdXJ2ZSIsIkV4dGVuZGVkUG9pbnQiLCJmcm9tSGV4Iiwic2lnbiIsIm1lc3NhZ2UiLCJzbGljZSIsInZlcmlmeSIsInRvQnVmZmVyIiwiYXJyIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJmcm9tIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJTdHJ1Y3QiLCJjb25zdHJ1Y3RvciIsInByb3BlcnRpZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmNvZGUiLCJzZXJpYWxpemUiLCJTT0xBTkFfU0NIRU1BIiwiZGVjb2RlIiwiZGF0YSIsImRlc2VyaWFsaXplIiwiZGVjb2RlVW5jaGVja2VkIiwiZGVzZXJpYWxpemVVbmNoZWNrZWQiLCJFbnVtIiwiZW51bSIsImtleXMiLCJsZW5ndGgiLCJFcnJvciIsIm1hcCIsImtleSIsIk1hcCIsIk1BWF9TRUVEX0xFTkdUSCIsIlBVQkxJQ19LRVlfTEVOR1RIIiwiaXNQdWJsaWNLZXlEYXRhIiwidmFsdWUiLCJfYm4iLCJ1bmRlZmluZWQiLCJ1bmlxdWVQdWJsaWNLZXlDb3VudGVyIiwiUHVibGljS2V5IiwiZGVjb2RlZCIsImJzNTgiLCJCTiIsInVuaXF1ZSIsImVxdWFscyIsImVxIiwidG9CYXNlNTgiLCJ0b0J5dGVzIiwidG9KU09OIiwiYnVmIiwiYiIsInRvQXJyYXlMaWtlIiwiemVyb1BhZCIsImFsbG9jIiwiY29weSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidG9TdHJpbmciLCJjcmVhdGVXaXRoU2VlZCIsImZyb21QdWJsaWNLZXkiLCJzZWVkIiwicHJvZ3JhbUlkIiwiY29uY2F0IiwicHVibGljS2V5Qnl0ZXMiLCJzaGEyNTYiLCJjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMiLCJzZWVkcyIsImZvckVhY2giLCJUeXBlRXJyb3IiLCJjcmVhdGVQcm9ncmFtQWRkcmVzcyIsImZpbmRQcm9ncmFtQWRkcmVzc1N5bmMiLCJub25jZSIsImFkZHJlc3MiLCJzZWVkc1dpdGhOb25jZSIsImVyciIsImZpbmRQcm9ncmFtQWRkcmVzcyIsInB1YmtleURhdGEiLCJwdWJrZXkiLCJfUHVibGljS2V5IiwiZGVmYXVsdCIsImtpbmQiLCJmaWVsZHMiLCJBY2NvdW50IiwiX3B1YmxpY0tleSIsIl9zZWNyZXRLZXkiLCJzZWNyZXRLZXlCdWZmZXIiLCJCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCIsIlBBQ0tFVF9EQVRBX1NJWkUiLCJWRVJTSU9OX1BSRUZJWF9NQVNLIiwiU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyIsIlRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciIsInNpZ25hdHVyZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwidGltZW91dFNlY29uZHMiLCJ0b0ZpeGVkIiwiVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IiLCJNZXNzYWdlQWNjb3VudEtleXMiLCJzdGF0aWNBY2NvdW50S2V5cyIsImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJrZXlTZWdtZW50cyIsInB1c2giLCJ3cml0YWJsZSIsInJlYWRvbmx5IiwiZ2V0IiwiaW5kZXgiLCJrZXlTZWdtZW50IiwiZmxhdCIsImNvbXBpbGVJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbnMiLCJVOF9NQVgiLCJrZXlJbmRleE1hcCIsImZpbmRLZXlJbmRleCIsImtleUluZGV4IiwiaW5zdHJ1Y3Rpb24iLCJwcm9ncmFtSWRJbmRleCIsImFjY291bnRLZXlJbmRleGVzIiwibWV0YSIsInByb3BlcnR5IiwiQnVmZmVyTGF5b3V0IiwiYmxvYiIsInJ1c3RTdHJpbmciLCJyc2wiLCJzdHJ1Y3QiLCJ1MzIiLCJvZmZzZXQiLCJfZGVjb2RlIiwiYmluZCIsIl9lbmNvZGUiLCJyc2xTaGltIiwic3RyIiwiY2hhcnMiLCJzcGFuIiwiYXV0aG9yaXplZCIsImxvY2t1cCIsIm5zNjQiLCJ2b3RlSW5pdCIsInU4Iiwidm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyIsImdldEFsbG9jIiwidHlwZSIsImdldEl0ZW1BbGxvYyIsIml0ZW0iLCJmaWVsZCIsIkFycmF5IiwiaXNBcnJheSIsImVsZW1lbnRMYXlvdXQiLCJsYXlvdXQiLCJkZWNvZGVMZW5ndGgiLCJieXRlcyIsImxlbiIsInNpemUiLCJlbGVtIiwic2hpZnQiLCJlbmNvZGVMZW5ndGgiLCJyZW1fbGVuIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiQ29tcGlsZWRLZXlzIiwicGF5ZXIiLCJrZXlNZXRhTWFwIiwiY29tcGlsZSIsImdldE9ySW5zZXJ0RGVmYXVsdCIsImtleU1ldGEiLCJpc1NpZ25lciIsImlzV3JpdGFibGUiLCJpc0ludm9rZWQiLCJwYXllcktleU1ldGEiLCJpeCIsImFjY291bnRNZXRhIiwiZ2V0TWVzc2FnZUNvbXBvbmVudHMiLCJtYXBFbnRyaWVzIiwiZW50cmllcyIsIndyaXRhYmxlU2lnbmVycyIsImZpbHRlciIsInJlYWRvbmx5U2lnbmVycyIsIndyaXRhYmxlTm9uU2lnbmVycyIsInJlYWRvbmx5Tm9uU2lnbmVycyIsImhlYWRlciIsIm51bVJlcXVpcmVkU2lnbmF0dXJlcyIsIm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMiLCJudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMiLCJwYXllckFkZHJlc3MiLCJleHRyYWN0VGFibGVMb29rdXAiLCJsb29rdXBUYWJsZSIsIndyaXRhYmxlSW5kZXhlcyIsImRyYWluZWRXcml0YWJsZUtleXMiLCJkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUiLCJzdGF0ZSIsImFkZHJlc3NlcyIsInJlYWRvbmx5SW5kZXhlcyIsImRyYWluZWRSZWFkb25seUtleXMiLCJhY2NvdW50S2V5IiwibG9va3VwVGFibGVFbnRyaWVzIiwia2V5TWV0YUZpbHRlciIsImxvb2t1cFRhYmxlSW5kZXhlcyIsImRyYWluZWRLZXlzIiwibG9va3VwVGFibGVJbmRleCIsImZpbmRJbmRleCIsImVudHJ5IiwiZGVsZXRlIiwiRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFIiwiZ3VhcmRlZFNoaWZ0IiwiYnl0ZUFycmF5IiwiZ3VhcmRlZFNwbGljZSIsImFyZ3MiLCJzdGFydCIsInNwbGljZSIsIk1lc3NhZ2UiLCJhY2NvdW50S2V5cyIsInJlY2VudEJsb2NraGFzaCIsImluZGV4VG9Qcm9ncmFtSWRzIiwiYWNjb3VudCIsInZlcnNpb24iLCJjb21waWxlZEluc3RydWN0aW9ucyIsImFjY291bnRzIiwiYWRkcmVzc1RhYmxlTG9va3VwcyIsImdldEFjY291bnRLZXlzIiwiY29tcGlsZWRLZXlzIiwicGF5ZXJLZXkiLCJpc0FjY291bnRTaWduZXIiLCJpc0FjY291bnRXcml0YWJsZSIsIm51bVNpZ25lZEFjY291bnRzIiwidW5zaWduZWRBY2NvdW50SW5kZXgiLCJudW1VbnNpZ25lZEFjY291bnRzIiwibnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzIiwibnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyIsImlzUHJvZ3JhbUlkIiwiaGFzIiwicHJvZ3JhbUlkcyIsInZhbHVlcyIsIm5vblByb2dyYW1JZHMiLCJfIiwibnVtS2V5cyIsImtleUNvdW50Iiwic2hvcnR2ZWMiLCJrZXlJbmRpY2VzQ291bnQiLCJkYXRhQ291bnQiLCJrZXlJbmRpY2VzIiwiZGF0YUxlbmd0aCIsImluc3RydWN0aW9uQ291bnQiLCJpbnN0cnVjdGlvbkJ1ZmZlciIsImluc3RydWN0aW9uQnVmZmVyTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25MYXlvdXQiLCJzZXEiLCJzaWduRGF0YUxheW91dCIsIkxheW91dCIsInRyYW5zYWN0aW9uIiwic2lnbkRhdGEiLCJhY2NvdW50Q291bnQiLCJpIiwiZGF0YVNsaWNlIiwibWVzc2FnZUFyZ3MiLCJNZXNzYWdlVjAiLCJudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzIiwiY291bnQiLCJsb29rdXAiLCJhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyIsInJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzIiwibnVtU3RhdGljQWNjb3VudEtleXMiLCJsb29rdXBBY2NvdW50S2V5c0luZGV4IiwibnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyIsInJlZHVjZSIsInRhYmxlTG9va3VwIiwidGFibGVBY2NvdW50IiwiZmluZCIsImxvb2t1cFRhYmxlQWNjb3VudHMiLCJleHRyYWN0UmVzdWx0IiwiYWRkcmVzc1RhYmxlTG9va3VwIiwiZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoIiwic2VyaWFsaXplZEluc3RydWN0aW9ucyIsInNlcmlhbGl6ZUluc3RydWN0aW9ucyIsImVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgiLCJzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyIsInNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCIsIm1lc3NhZ2VMYXlvdXQiLCJzZXJpYWxpemVkTWVzc2FnZSIsIk1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCIsInNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoIiwicHJlZml4Iiwic3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJpbnN0cnVjdGlvbnNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwic2VyaWFsaXplZExlbmd0aCIsImVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImVuY29kZWREYXRhTGVuZ3RoIiwiZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCIsImVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQiLCJtYXNrZWRQcmVmaXgiLCJhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCIsIndyaXRhYmxlSW5kZXhlc0xlbmd0aCIsInJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsIlZlcnNpb25lZE1lc3NhZ2UiLCJkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uIiwiVHJhbnNhY3Rpb25TdGF0dXMiLCJERUZBVUxUX1NJR05BVFVSRSIsImZpbGwiLCJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwib3B0cyIsIlRyYW5zYWN0aW9uIiwic2lnbmF0dXJlcyIsImZlZVBheWVyIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJub25jZUluZm8iLCJtaW5Ob25jZUNvbnRleHRTbG90IiwiX21lc3NhZ2UiLCJfanNvbiIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1pbkNvbnRleHRTbG90IiwiYmxvY2toYXNoIiwibm9uY2VJbnN0cnVjdGlvbiIsInNpZ25lcnMiLCJhZGQiLCJpdGVtcyIsImNvbXBpbGVNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnNvbGUiLCJ3YXJuIiwiYWNjb3VudE1ldGFzIiwiaW5jbHVkZXMiLCJ1bmlxdWVNZXRhcyIsInB1YmtleVN0cmluZyIsInVuaXF1ZUluZGV4IiwieCIsInNvcnQiLCJ5Iiwib3B0aW9ucyIsImxvY2FsZU1hdGNoZXIiLCJ1c2FnZSIsInNlbnNpdGl2aXR5IiwiaWdub3JlUHVuY3R1YXRpb24iLCJudW1lcmljIiwiY2FzZUZpcnN0IiwibG9jYWxlQ29tcGFyZSIsImZlZVBheWVySW5kZXgiLCJwYXllck1ldGEiLCJ1bnNoaWZ0Iiwic2lnbmVkS2V5cyIsInVuc2lnbmVkS2V5cyIsImluZGV4T2YiLCJpbnZhcmlhbnQiLCJfY29tcGlsZSIsInZhbGlkIiwiZXZlcnkiLCJwYWlyIiwic2VyaWFsaXplTWVzc2FnZSIsImdldEVzdGltYXRlZEZlZSIsImNvbm5lY3Rpb24iLCJnZXRGZWVGb3JNZXNzYWdlIiwic2V0U2lnbmVycyIsInNlZW4iLCJTZXQiLCJ1bmlxdWVTaWduZXJzIiwic2lnbmVyIiwiX3BhcnRpYWxTaWduIiwicGFydGlhbFNpZ24iLCJfYWRkU2lnbmF0dXJlIiwiYWRkU2lnbmF0dXJlIiwic2lncGFpciIsInZlcmlmeVNpZ25hdHVyZXMiLCJyZXF1aXJlQWxsU2lnbmF0dXJlcyIsInNpZ25hdHVyZUVycm9ycyIsIl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyIsImVycm9ycyIsIm1pc3NpbmciLCJpbnZhbGlkIiwiY29uZmlnIiwic2lnRXJyb3JzIiwiZXJyb3JNZXNzYWdlIiwicCIsImpvaW4iLCJfc2VyaWFsaXplIiwic2lnbmF0dXJlQ291bnQiLCJ0cmFuc2FjdGlvbkxlbmd0aCIsIndpcmVUcmFuc2FjdGlvbiIsImtleU9iaiIsInBvcHVsYXRlIiwic2lnUHVia2V5UGFpciIsInNvbWUiLCJUcmFuc2FjdGlvbk1lc3NhZ2UiLCJkZWNvbXBpbGUiLCJjb21waWxlZEl4IiwiY29tcGlsZVRvTGVnYWN5TWVzc2FnZSIsImNvbXBpbGVUb1YwTWVzc2FnZSIsIlZlcnNpb25lZFRyYW5zYWN0aW9uIiwiZGVmYXVsdFNpZ25hdHVyZXMiLCJlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCIsInRyYW5zYWN0aW9uTGF5b3V0Iiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoIiwic2lnbmF0dXJlc0xlbmd0aCIsIm1lc3NhZ2VEYXRhIiwic2lnbmVyUHVia2V5cyIsInNpZ25lckluZGV4IiwiTlVNX1RJQ0tTX1BFUl9TRUNPTkQiLCJERUZBVUxUX1RJQ0tTX1BFUl9TTE9UIiwiTlVNX1NMT1RTX1BFUl9TRUNPTkQiLCJNU19QRVJfU0xPVCIsIlNZU1ZBUl9DTE9DS19QVUJLRVkiLCJTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZIiwiU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkiLCJTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9SRU5UX1BVQktFWSIsIlNZU1ZBUl9SRVdBUkRTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkiLCJTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSIsIlNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSIsIlNlbmRUcmFuc2FjdGlvbkVycm9yIiwiYWN0aW9uIiwidHJhbnNhY3Rpb25NZXNzYWdlIiwibG9ncyIsIm1heWJlTG9nc091dHB1dCIsImd1aWRlVGV4dCIsImEiLCJ0cmFuc2FjdGlvbkxvZ3MiLCJ0cmFuc2FjdGlvbkVycm9yIiwiY2FjaGVkTG9ncyIsImdldExvZ3MiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdldFRyYW5zYWN0aW9uIiwidGhlbiIsInR4IiwibG9nTWVzc2FnZXMiLCJjYXRjaCIsIlNvbGFuYUpTT05SUENFcnJvckNvZGUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVgiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFIiwiSlNPTl9SUENfU0NBTl9FUlJPUiIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQiLCJTb2xhbmFKU09OUlBDRXJyb3IiLCJjb2RlIiwiY3VzdG9tTWVzc2FnZSIsIm5hbWUiLCJzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uIiwic2VuZE9wdGlvbnMiLCJza2lwUHJlZmxpZ2h0IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJtYXhSZXRyaWVzIiwic2VuZFRyYW5zYWN0aW9uIiwic3RhdHVzIiwiY29uZmlybVRyYW5zYWN0aW9uIiwiYWJvcnRTaWduYWwiLCJub25jZUFjY291bnRQdWJrZXkiLCJub25jZVZhbHVlIiwic2xlZXAiLCJtcyIsInNldFRpbWVvdXQiLCJlbmNvZGVEYXRhIiwiYWxsb2NMZW5ndGgiLCJsYXlvdXRGaWVsZHMiLCJkZWNvZGVEYXRhIiwiRmVlQ2FsY3VsYXRvckxheW91dCIsIm51NjQiLCJOb25jZUFjY291bnRMYXlvdXQiLCJOT05DRV9BQ0NPVU5UX0xFTkdUSCIsIk5vbmNlQWNjb3VudCIsImF1dGhvcml6ZWRQdWJrZXkiLCJmZWVDYWxjdWxhdG9yIiwiZnJvbUFjY291bnREYXRhIiwibm9uY2VBY2NvdW50IiwiZW5jb2RlRGVjb2RlIiwiYmlnSW50IiwiYmlnSW50TGF5b3V0Iiwic3JjIiwidG9CaWdJbnRMRSIsInRvQnVmZmVyTEUiLCJ1NjQiLCJTeXN0ZW1JbnN0cnVjdGlvbiIsImRlY29kZUluc3RydWN0aW9uVHlwZSIsImNoZWNrUHJvZ3JhbUlkIiwiaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0IiwidHlwZUluZGV4IiwiaXhUeXBlIiwiU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVDcmVhdGVBY2NvdW50IiwiY2hlY2tLZXlMZW5ndGgiLCJsYW1wb3J0cyIsInNwYWNlIiwiQ3JlYXRlIiwiZnJvbVB1YmtleSIsIm5ld0FjY291bnRQdWJrZXkiLCJkZWNvZGVUcmFuc2ZlciIsIlRyYW5zZmVyIiwidG9QdWJrZXkiLCJkZWNvZGVUcmFuc2ZlcldpdGhTZWVkIiwiVHJhbnNmZXJXaXRoU2VlZCIsImJhc2VQdWJrZXkiLCJkZWNvZGVBbGxvY2F0ZSIsIkFsbG9jYXRlIiwiYWNjb3VudFB1YmtleSIsImRlY29kZUFsbG9jYXRlV2l0aFNlZWQiLCJiYXNlIiwiQWxsb2NhdGVXaXRoU2VlZCIsImRlY29kZUFzc2lnbiIsIkFzc2lnbiIsImRlY29kZUFzc2lnbldpdGhTZWVkIiwiQXNzaWduV2l0aFNlZWQiLCJkZWNvZGVDcmVhdGVXaXRoU2VlZCIsIkNyZWF0ZVdpdGhTZWVkIiwiZGVjb2RlTm9uY2VJbml0aWFsaXplIiwiSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCIsIm5vbmNlUHVia2V5IiwiZGVjb2RlTm9uY2VBZHZhbmNlIiwiQWR2YW5jZU5vbmNlQWNjb3VudCIsImRlY29kZU5vbmNlV2l0aGRyYXciLCJXaXRoZHJhd05vbmNlQWNjb3VudCIsImRlY29kZU5vbmNlQXV0aG9yaXplIiwiQXV0aG9yaXplTm9uY2VBY2NvdW50IiwibmV3QXV0aG9yaXplZFB1YmtleSIsIlN5c3RlbVByb2dyYW0iLCJleHBlY3RlZExlbmd0aCIsImZyZWV6ZSIsIlVwZ3JhZGVOb25jZUFjY291bnQiLCJjcmVhdGVBY2NvdW50IiwicGFyYW1zIiwidHJhbnNmZXIiLCJCaWdJbnQiLCJjcmVhdGVBY2NvdW50V2l0aFNlZWQiLCJjcmVhdGVOb25jZUFjY291bnQiLCJpbml0UGFyYW1zIiwibm9uY2VJbml0aWFsaXplIiwiaW5zdHJ1Y3Rpb25EYXRhIiwibm9uY2VBZHZhbmNlIiwibm9uY2VXaXRoZHJhdyIsIm5vbmNlQXV0aG9yaXplIiwiYWxsb2NhdGUiLCJDSFVOS19TSVpFIiwiTG9hZGVyIiwiZ2V0TWluTnVtU2lnbmF0dXJlcyIsIk1hdGgiLCJjZWlsIiwiY2h1bmtTaXplIiwibG9hZCIsInByb2dyYW0iLCJiYWxhbmNlTmVlZGVkIiwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uIiwicHJvZ3JhbUluZm8iLCJnZXRBY2NvdW50SW5mbyIsImV4ZWN1dGFibGUiLCJlcnJvciIsIm93bmVyIiwiZGF0YUxheW91dCIsImFycmF5IiwidHJhbnNhY3Rpb25zIiwiYnl0ZXNMZW5ndGgiLCJieXRlc0xlbmd0aFBhZGRpbmciLCJfcnBjRW5kcG9pbnQiLCJSRVFVRVNUU19QRVJfU0VDT05EIiwiYWxsIiwiZGVwbG95Q29tbWl0bWVudCIsImZpbmFsaXplU2lnbmF0dXJlIiwiY29udGV4dCIsImN1cnJlbnRTbG90IiwiZ2V0U2xvdCIsInNsb3QiLCJyb3VuZCIsIkJQRl9MT0FERVJfUFJPR1JBTV9JRCIsIkJwZkxvYWRlciIsImVsZiIsImxvYWRlclByb2dyYW1JZCIsInMiLCJtIiwiaCIsImQiLCJ3IiwidmFsIiwicGFyc2UiLCJpc0Zpbml0ZSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJTdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJuIiwicGFyc2VGbG9hdCIsInRvTG93ZXJDYXNlIiwibXNBYnMiLCJhYnMiLCJwbHVyYWwiLCJpc1BsdXJhbCIsInV0aWwiLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsImh1bWFuaXplTXMiLCJ0IiwiciIsImZvcm1hdCIsInN0YWNrIiwiY29uc3RhbnRzIiwiQ1VSUkVOVF9JRCIsIkNSRUFURV9JRCIsIklOSVRfU09DS0VUIiwiQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04iLCJTT0NLRVRfQ1JFQVRFRF9USU1FIiwiU09DS0VUX05BTUUiLCJTT0NLRVRfUkVRVUVTVF9DT1VOVCIsIlNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UIiwiT3JpZ2luYWxBZ2VudCIsIkFnZW50IiwiZGVidWciLCJyZXF1aXJlJCQyIiwiZGVidWdsb2ciLCJyZXF1aXJlJCQzIiwiZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50IiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJwcm9jZXNzIiwic3BsaXQiLCJzdWJzdHJpbmciLCJkZXByZWNhdGUiLCJsb2ciLCJrZWVwQWxpdmUiLCJmcmVlU29ja2V0VGltZW91dCIsImtlZXBBbGl2ZVRpbWVvdXQiLCJmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCIsInRpbWVvdXQiLCJtYXgiLCJzb2NrZXRBY3RpdmVUVEwiLCJjcmVhdGVTb2NrZXRDb3VudCIsImNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrIiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudCIsImNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2siLCJjbG9zZVNvY2tldENvdW50IiwiY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayIsImVycm9yU29ja2V0Q291bnQiLCJlcnJvclNvY2tldENvdW50TGFzdENoZWNrIiwicmVxdWVzdENvdW50IiwicmVxdWVzdENvdW50TGFzdENoZWNrIiwidGltZW91dFNvY2tldENvdW50IiwidGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIiwib24iLCJzb2NrZXQiLCJjYWxjU29ja2V0VGltZW91dCIsImFsaXZlVGltZSIsIkRhdGUiLCJub3ciLCJkaWZmIiwiY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQiLCJrZWVwU29ja2V0QWxpdmUiLCJyZXN1bHQiLCJjdXN0b21UaW1lb3V0IiwicmV1c2VTb2NrZXQiLCJyZXEiLCJyZXVzZWRTb2NrZXQiLCJhZ2VudFRpbWVvdXQiLCJnZXRTb2NrZXRUaW1lb3V0IiwiaWQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic2V0Tm9EZWxheSIsIl9hZ2VudEtleSIsImluc3RhbGxMaXN0ZW5lcnMiLCJjcmVhdGVDb25uZWN0aW9uIiwib25jcmVhdGUiLCJjYWxsZWQiLCJvbk5ld0NyZWF0ZSIsIm5ld1NvY2tldCIsInN0YXR1c0NoYW5nZWQiLCJjaGFuZ2VkIiwiZ2V0Q3VycmVudFN0YXR1cyIsImZyZWVTb2NrZXRzIiwiaW5zcGVjdCIsInNvY2tldHMiLCJyZXF1ZXN0cyIsIl9pZGxlVGltZW91dCIsImFnZW50Iiwib25GcmVlIiwiX2h0dHBNZXNzYWdlIiwiZ2V0TmFtZSIsIm9uQ2xvc2UiLCJpc0Vycm9yIiwib25UaW1lb3V0IiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsInJlcVRpbWVvdXRMaXN0ZW5lckNvdW50IiwiZW5hYmxlZCIsImYiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0Iiwib25FcnJvciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsIm9uUmVtb3ZlIiwib2JqIiwicmVzIiwiT3JpZ2luYWxIdHRwc0FnZW50IiwiSHR0cEFnZW50IiwiSHR0cHNBZ2VudCIsImRlZmF1bHRQb3J0IiwicHJvdG9jb2wiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIl9zZXNzaW9uQ2FjaGUiLCJsaXN0IiwibWV0aG9kIiwiaHR0cHNfYWdlbnQiLCJhZ2VudGtlZXBhbGl2ZU1vZHVsZSIsImV4cG9ydHMiLCJvYmpUb1N0cmluZyIsIm9iaktleXMiLCJpc0FycmF5UHJvcCIsInByb3BWYWwiLCJ0b1N0ciIsImZhc3RTdGFibGVTdHJpbmdpZnkiLCJyZXR1cm5WYWwiLCJNSU5JTVVNX1NMT1RfUEVSX0VQT0NIIiwidHJhaWxpbmdaZXJvcyIsIm5leHRQb3dlck9mVHdvIiwiRXBvY2hTY2hlZHVsZSIsInNsb3RzUGVyRXBvY2giLCJsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQiLCJ3YXJtdXAiLCJmaXJzdE5vcm1hbEVwb2NoIiwiZmlyc3ROb3JtYWxTbG90IiwiZ2V0RXBvY2giLCJnZXRFcG9jaEFuZFNsb3RJbmRleCIsImVwb2NoIiwiZXBvY2hMZW4iLCJnZXRTbG90c0luRXBvY2giLCJzbG90SW5kZXgiLCJub3JtYWxTbG90SW5kZXgiLCJub3JtYWxFcG9jaEluZGV4IiwiZmxvb3IiLCJnZXRGaXJzdFNsb3RJbkVwb2NoIiwicG93IiwiZ2V0TGFzdFNsb3RJbkVwb2NoIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiaW5wdXQiLCJpbml0IiwicHJvY2Vzc2VkSW5wdXQiLCJub2RlRmV0Y2giLCJScGNXZWJTb2NrZXRDbGllbnQiLCJDb21tb25DbGllbnQiLCJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwid2ViU29ja2V0RmFjdG9yeSIsInVybCIsInJwYyIsImNyZWF0ZVJwYyIsImF1dG9jb25uZWN0IiwibWF4X3JlY29ubmVjdHMiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJ1bmRlcmx5aW5nU29ja2V0IiwicmVhZHlTdGF0ZSIsIm5vdGlmeSIsIkxPT0tVUF9UQUJMRV9NRVRBX1NJWkUiLCJBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IiwiaXNBY3RpdmUiLCJVNjRfTUFYIiwiZGVhY3RpdmF0aW9uU2xvdCIsImFjY291bnREYXRhIiwiTG9va3VwVGFibGVNZXRhTGF5b3V0Iiwic2VyaWFsaXplZEFkZHJlc3Nlc0xlbiIsIm51bVNlcmlhbGl6ZWRBZGRyZXNzZXMiLCJsYXN0RXh0ZW5kZWRTbG90IiwibGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXgiLCJsYXN0RXh0ZW5kZWRTdGFydEluZGV4IiwiYXV0aG9yaXR5IiwiVVJMX1JFIiwibWFrZVdlYnNvY2tldFVybCIsImVuZHBvaW50IiwibWF0Y2hlcyIsImhvc3Rpc2giLCJwb3J0V2l0aENvbG9uIiwicmVzdCIsInN0YXJ0c1dpdGgiLCJzdGFydFBvcnQiLCJ3ZWJzb2NrZXRQb3J0IiwiUHVibGljS2V5RnJvbVN0cmluZyIsImNvZXJjZSIsImluc3RhbmNlIiwic3RyaW5nIiwiUmF3QWNjb3VudERhdGFSZXN1bHQiLCJ0dXBsZSIsImxpdGVyYWwiLCJCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEiLCJCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyIsImFzc2VydEVuZHBvaW50VXJsIiwicHV0YXRpdmVVcmwiLCJ0ZXN0IiwiZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnIiwiY29tbWl0bWVudE9yQ29uZmlnIiwic3BlY2lmaWVkQ29tbWl0bWVudCIsInNwZWNpZmllZENvbmZpZyIsImFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzIiwiZmlsdGVycyIsIm1lbWNtcCIsImVuY29kaW5nIiwiY3JlYXRlUnBjUmVzdWx0IiwidW5pb24iLCJwaWNrIiwianNvbnJwYyIsInVua25vd24iLCJvcHRpb25hbCIsImFueSIsIlVua25vd25ScGNSZXN1bHQiLCJqc29uUnBjUmVzdWx0Iiwic2NoZW1hIiwiY3JlYXRlIiwianNvblJwY1Jlc3VsdEFuZENvbnRleHQiLCJudW1iZXIiLCJub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0IiwidmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSIsInJlc3BvbnNlIiwiR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQiLCJmb3VuZGF0aW9uIiwiZm91bmRhdGlvblRlcm0iLCJpbml0aWFsIiwidGFwZXIiLCJ0ZXJtaW5hbCIsIkdldEluZmxhdGlvblJld2FyZFJlc3VsdCIsIm51bGxhYmxlIiwiZWZmZWN0aXZlU2xvdCIsImFtb3VudCIsInBvc3RCYWxhbmNlIiwiY29tbWlzc2lvbiIsIkdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCIsInByaW9yaXRpemF0aW9uRmVlIiwiR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCIsInRvdGFsIiwidmFsaWRhdG9yIiwiR2V0RXBvY2hJbmZvUmVzdWx0Iiwic2xvdHNJbkVwb2NoIiwiYWJzb2x1dGVTbG90IiwiYmxvY2tIZWlnaHQiLCJ0cmFuc2FjdGlvbkNvdW50IiwiR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCIsImJvb2xlYW4iLCJHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCIsInJlY29yZCIsIlRyYW5zYWN0aW9uRXJyb3JSZXN1bHQiLCJTaWduYXR1cmVTdGF0dXNSZXN1bHQiLCJTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCIsIlZlcnNpb25SZXN1bHQiLCJQYXJzZWRJbnN0cnVjdGlvblN0cnVjdCIsInBhcnNlZCIsIlBhcnRpYWxseURlY29kZWRJbnN0cnVjdGlvblN0cnVjdCIsIlNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QiLCJyZW50RXBvY2giLCJ1bml0c0NvbnN1bWVkIiwicmV0dXJuRGF0YSIsImlubmVySW5zdHJ1Y3Rpb25zIiwiQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QiLCJieUlkZW50aXR5IiwicmFuZ2UiLCJmaXJzdFNsb3QiLCJsYXN0U2xvdCIsImNyZWF0ZVJwY0NsaWVudCIsImh0dHBIZWFkZXJzIiwiY3VzdG9tRmV0Y2giLCJmZXRjaE1pZGRsZXdhcmUiLCJkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCIsImh0dHBBZ2VudCIsImFnZW50T3B0aW9ucyIsIm1heFNvY2tldHMiLCJIdHRwc0tlZXBBbGl2ZUFnZW50IiwiSHR0cEtlZXBBbGl2ZUFnZW50IiwiaXNIdHRwcyIsIk5vZGVIdHRwc0FnZW50IiwiZmV0Y2hXaXRoTWlkZGxld2FyZSIsImluZm8iLCJtb2RpZmllZEZldGNoQXJncyIsIm1vZGlmaWVkSW5mbyIsIm1vZGlmaWVkSW5pdCIsImNsaWVudEJyb3dzZXIiLCJScGNDbGllbnQiLCJyZXF1ZXN0IiwiY2FsbGJhY2siLCJib2R5IiwiaGVhZGVycyIsIkNPTU1PTl9IVFRQX0hFQURFUlMiLCJ0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzIiwid2FpdFRpbWUiLCJzdGF0dXNUZXh0IiwidGV4dCIsIm9rIiwiY3JlYXRlUnBjUmVxdWVzdCIsImNsaWVudCIsImNyZWF0ZVJwY0JhdGNoUmVxdWVzdCIsImJhdGNoIiwibWV0aG9kTmFtZSIsIkdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0IiwiR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCIsIkdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCIsIkdldEVwb2NoSW5mb1JwY1Jlc3VsdCIsIkdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQiLCJHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCIsIlNsb3RScGNSZXN1bHQiLCJHZXRTdXBwbHlScGNSZXN1bHQiLCJjaXJjdWxhdGluZyIsIm5vbkNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmdBY2NvdW50cyIsIlRva2VuQW1vdW50UmVzdWx0IiwidWlBbW91bnQiLCJkZWNpbWFscyIsInVpQW1vdW50U3RyaW5nIiwiR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQiLCJHZXRUb2tlbkFjY291bnRzQnlPd25lciIsIlBhcnNlZEFjY291bnREYXRhUmVzdWx0IiwiR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCJHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQiLCJBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkQWNjb3VudEluZm9SZXN1bHQiLCJQYXJzZWRPclJhd0FjY291bnREYXRhIiwiUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0IiwiU3Rha2VBY3RpdmF0aW9uUmVzdWx0IiwiYWN0aXZlIiwiaW5hY3RpdmUiLCJHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQiLCJtZW1vIiwiYmxvY2tUaW1lIiwiR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQiLCJBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0Iiwic3Vic2NyaXB0aW9uIiwiUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0IiwiUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90SW5mb1Jlc3VsdCIsInBhcmVudCIsInJvb3QiLCJTbG90Tm90aWZpY2F0aW9uUmVzdWx0IiwiU2xvdFVwZGF0ZVJlc3VsdCIsInRpbWVzdGFtcCIsInN0YXRzIiwibnVtVHJhbnNhY3Rpb25FbnRyaWVzIiwibnVtU3VjY2Vzc2Z1bFRyYW5zYWN0aW9ucyIsIm51bUZhaWxlZFRyYW5zYWN0aW9ucyIsIm1heFRyYW5zYWN0aW9uc1BlckVudHJ5IiwiU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCIsIlNpZ25hdHVyZU5vdGlmaWNhdGlvblJlc3VsdCIsIlJvb3ROb3RpZmljYXRpb25SZXN1bHQiLCJDb250YWN0SW5mb1Jlc3VsdCIsImdvc3NpcCIsInRwdSIsIlZvdGVBY2NvdW50SW5mb1Jlc3VsdCIsInZvdGVQdWJrZXkiLCJub2RlUHVia2V5IiwiYWN0aXZhdGVkU3Rha2UiLCJlcG9jaFZvdGVBY2NvdW50IiwiZXBvY2hDcmVkaXRzIiwibGFzdFZvdGUiLCJyb290U2xvdCIsIkdldFZvdGVBY2NvdW50cyIsImN1cnJlbnQiLCJkZWxpbnF1ZW50IiwiQ29uZmlybWF0aW9uU3RhdHVzIiwiU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UiLCJjb25maXJtYXRpb25zIiwiY29uZmlybWF0aW9uU3RhdHVzIiwiR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQiLCJHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQiLCJBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QiLCJDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCIsIkFubm90YXRlZEFjY291bnRLZXkiLCJzb3VyY2UiLCJDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCIsIlBhcnNlZEluc3RydWN0aW9uUmVzdWx0IiwiUmF3SW5zdHJ1Y3Rpb25SZXN1bHQiLCJJbnN0cnVjdGlvblJlc3VsdCIsIlVua25vd25JbnN0cnVjdGlvblJlc3VsdCIsIlBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24iLCJQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCIsIlRva2VuQmFsYW5jZVJlc3VsdCIsImFjY291bnRJbmRleCIsIm1pbnQiLCJ1aVRva2VuQW1vdW50IiwiTG9hZGVkQWRkcmVzc2VzUmVzdWx0IiwiQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwiZmVlIiwicHJlQmFsYW5jZXMiLCJwb3N0QmFsYW5jZXMiLCJwcmVUb2tlbkJhbGFuY2VzIiwicG9zdFRva2VuQmFsYW5jZXMiLCJsb2FkZWRBZGRyZXNzZXMiLCJjb21wdXRlVW5pdHNDb25zdW1lZCIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCIsIlRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCIsIlJld2FyZHNSZXN1bHQiLCJyZXdhcmRUeXBlIiwiR2V0QmxvY2tScGNSZXN1bHQiLCJwcmV2aW91c0Jsb2NraGFzaCIsInBhcmVudFNsb3QiLCJyZXdhcmRzIiwiR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCIsIkdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCIsIkdldFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwiR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0IiwibGFtcG9ydHNQZXJTaWduYXR1cmUiLCJHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQiLCJJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0IiwiUGVyZlNhbXBsZVJlc3VsdCIsIm51bVRyYW5zYWN0aW9ucyIsIm51bVNsb3RzIiwic2FtcGxlUGVyaW9kU2VjcyIsIkdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCIsIkdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQiLCJSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCIsIlNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkxvZ3NSZXN1bHQiLCJMb2dzTm90aWZpY2F0aW9uUmVzdWx0IiwiQ29ubmVjdGlvbiIsIl9jb21taXRtZW50IiwiX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiX3JwY1dzRW5kcG9pbnQiLCJfcnBjQ2xpZW50IiwiX3JwY1JlcXVlc3QiLCJfcnBjQmF0Y2hSZXF1ZXN0IiwiX3JwY1dlYlNvY2tldCIsIl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQiLCJfcnBjV2ViU29ja2V0SGVhcnRiZWF0IiwiX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0IiwiX3JwY1dlYlNvY2tldEdlbmVyYXRpb24iLCJfZGlzYWJsZUJsb2NraGFzaENhY2hpbmciLCJfcG9sbGluZ0Jsb2NraGFzaCIsIl9ibG9ja2hhc2hJbmZvIiwibGF0ZXN0QmxvY2toYXNoIiwibGFzdEZldGNoIiwidHJhbnNhY3Rpb25TaWduYXR1cmVzIiwic2ltdWxhdGVkU2lnbmF0dXJlcyIsIl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2giLCJfc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25zQnlIYXNoIiwiX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyIsImdldEJsb2NrSGVpZ2h0IiwicmVxdWVzdFByb21pc2VzIiwiX2J1aWxkQXJncyIsInJlcXVlc3RIYXNoIiwidW5zYWZlUmVzIiwid3NFbmRwb2ludCIsImNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiSW5maW5pdHkiLCJfd3NPbk9wZW4iLCJfd3NPbkVycm9yIiwiX3dzT25DbG9zZSIsIl93c09uQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24iLCJfd3NPblNsb3ROb3RpZmljYXRpb24iLCJfd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uIiwiX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24iLCJfd3NPblJvb3ROb3RpZmljYXRpb24iLCJfd3NPbkxvZ3NOb3RpZmljYXRpb24iLCJycGNFbmRwb2ludCIsImdldEJhbGFuY2VBbmRDb250ZXh0IiwiZ2V0QmFsYW5jZSIsImUiLCJnZXRCbG9ja1RpbWUiLCJnZXRNaW5pbXVtTGVkZ2VyU2xvdCIsImdldEZpcnN0QXZhaWxhYmxlQmxvY2siLCJnZXRTdXBwbHkiLCJjb25maWdBcmciLCJnZXRUb2tlblN1cHBseSIsInRva2VuTWludEFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRCYWxhbmNlIiwidG9rZW5BZGRyZXNzIiwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIiLCJvd25lckFkZHJlc3MiLCJfYXJncyIsImdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyIiwiZ2V0TGFyZ2VzdEFjY291bnRzIiwiYXJnIiwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMiLCJtaW50QWRkcmVzcyIsImdldEFjY291bnRJbmZvQW5kQ29udGV4dCIsImdldFBhcnNlZEFjY291bnRJbmZvIiwiZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyIsInB1YmxpY0tleXMiLCJyYXdDb25maWciLCJnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQiLCJnZXRNdWx0aXBsZUFjY291bnRzSW5mbyIsImdldFN0YWtlQWN0aXZhdGlvbiIsImdldFByb2dyYW1BY2NvdW50cyIsImNvbmZpZ09yQ29tbWl0bWVudCIsImNvbmZpZ1dpdGhvdXRFbmNvZGluZyIsImJhc2VTY2hlbWEiLCJ3aXRoQ29udGV4dCIsImdldFBhcnNlZFByb2dyYW1BY2NvdW50cyIsInN0cmF0ZWd5IiwicmF3U2lnbmF0dXJlIiwiYWJvcnRlZCIsInJlYXNvbiIsImRlY29kZWRTaWduYXR1cmUiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3kiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5IiwiZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZSIsInNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2UiLCJzaWduYXR1cmVTdWJzY3JpcHRpb25JZCIsImRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyIiwiZG9uZSIsImNvbmZpcm1hdGlvblByb21pc2UiLCJvblNpZ25hdHVyZSIsIl9fdHlwZSIsIlBST0NFU1NFRCIsInN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSIsInJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCIsIl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlIiwibmV4dFN0YXRlIiwiZ2V0U2lnbmF0dXJlU3RhdHVzIiwiYWJvcnRDb25maXJtYXRpb24iLCJyZW1vdmVTaWduYXR1cmVMaXN0ZW5lciIsImV4cGlyeVByb21pc2UiLCJjaGVja0Jsb2NrSGVpZ2h0IiwiX2UiLCJjdXJyZW50QmxvY2tIZWlnaHQiLCJCTE9DS0hFSUdIVF9FWENFRURFRCIsImNhbmNlbGxhdGlvblByb21pc2UiLCJvdXRjb21lIiwicmFjZSIsImN1cnJlbnROb25jZVZhbHVlIiwibGFzdENoZWNrZWRTbG90IiwiZ2V0Q3VycmVudE5vbmNlVmFsdWUiLCJnZXROb25jZUFuZENvbnRleHQiLCJOT05DRV9JTlZBTElEIiwic2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2UiLCJzaWduYXR1cmVTdGF0dXMiLCJjb21taXRtZW50Rm9yU3RhdHVzIiwidGltZW91dElkIiwidGltZW91dE1zIiwiVElNRURfT1VUIiwiY2xlYXJUaW1lb3V0IiwiZ2V0Q2x1c3Rlck5vZGVzIiwiZ2V0Vm90ZUFjY291bnRzIiwiZ2V0U2xvdExlYWRlciIsImdldFNsb3RMZWFkZXJzIiwic3RhcnRTbG90IiwibGltaXQiLCJnZXRTaWduYXR1cmVTdGF0dXNlcyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJnZXRUb3RhbFN1cHBseSIsImV4Y2x1ZGVOb25DaXJjdWxhdGluZ0FjY291bnRzTGlzdCIsImdldEluZmxhdGlvbkdvdmVybm9yIiwiZ2V0SW5mbGF0aW9uUmV3YXJkIiwiZ2V0SW5mbGF0aW9uUmF0ZSIsImdldEVwb2NoSW5mbyIsImdldEVwb2NoU2NoZWR1bGUiLCJlcG9jaFNjaGVkdWxlIiwiZ2V0TGVhZGVyU2NoZWR1bGUiLCJnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0IiwiZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzIiwiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCIsIndpcmVNZXNzYWdlIiwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzIiwibG9ja2VkV3JpdGFibGVBY2NvdW50cyIsImdldFJlY2VudEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQiLCJpc0Jsb2NraGFzaFZhbGlkIiwiZ2V0VmVyc2lvbiIsImdldEdlbmVzaXNIYXNoIiwiZ2V0QmxvY2siLCJfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZCIsInRyYW5zYWN0aW9uRGV0YWlscyIsImdldFBhcnNlZEJsb2NrIiwiZ2V0QmxvY2tQcm9kdWN0aW9uIiwiZXh0cmEiLCJjIiwiZ2V0UGFyc2VkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRUcmFuc2FjdGlvbnMiLCJnZXRUcmFuc2FjdGlvbnMiLCJnZXRDb25maXJtZWRCbG9jayIsImJsb2NrIiwiZ2V0QmxvY2tzIiwiZW5kU2xvdCIsImdldEJsb2NrU2lnbmF0dXJlcyIsImdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyIsImdldENvbmZpcm1lZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbnMiLCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyIsImZpcnN0QXZhaWxhYmxlQmxvY2siLCJ1bnRpbCIsImhpZ2hlc3RDb25maXJtZWRSb290IiwiYmVmb3JlIiwiY29uZmlybWVkU2lnbmF0dXJlSW5mbyIsImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMiIsImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzIiwiZ2V0QWRkcmVzc0xvb2t1cFRhYmxlIiwiYWNjb3VudEluZm8iLCJnZXROb25jZSIsInJlcXVlc3RBaXJkcm9wIiwidG8iLCJfYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0IiwiZGlzYWJsZUNhY2hlIiwidGltZVNpbmNlRmV0Y2giLCJleHBpcmVkIiwiX3BvbGxOZXdCbG9ja2hhc2giLCJzdGFydFRpbWUiLCJjYWNoZWRMYXRlc3RCbG9ja2hhc2giLCJjYWNoZWRCbG9ja2hhc2giLCJnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uT3JNZXNzYWdlIiwiY29uZmlnT3JTaWduZXJzIiwiaW5jbHVkZUFjY291bnRzIiwidmVyc2lvbmVkVHgiLCJlbmNvZGVkVHJhbnNhY3Rpb24iLCJvcmlnaW5hbFR4Iiwic2lnVmVyaWZ5IiwidHJhY2VJbmRlbnQiLCJsb2dUcmFjZSIsInNpZ25lcnNPck9wdGlvbnMiLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJyYXdUcmFuc2FjdGlvbiIsInNlbmRFbmNvZGVkVHJhbnNhY3Rpb24iLCJzZXRJbnRlcnZhbCIsIl91cGRhdGVTdWJzY3JpcHRpb25zIiwiY2xlYXJJbnRlcnZhbCIsImhhc2giLCJfc2V0U3Vic2NyaXB0aW9uIiwibmV4dFN1YnNjcmlwdGlvbiIsInByZXZTdGF0ZSIsInN0YXRlQ2hhbmdlQ2FsbGJhY2tzIiwiY2IiLCJjbGllbnRTdWJzY3JpcHRpb25JZCIsImNsb3NlIiwiY29ubmVjdCIsImFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24iLCJpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUiLCJjYWxsYmFja3MiLCJzZXJ2ZXJTdWJzY3JpcHRpb25JZCIsInVuc3Vic2NyaWJlTWV0aG9kIiwiX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbiIsImNhbGxiYWNrQXJncyIsIm5vdGlmaWNhdGlvbiIsIl9tYWtlU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uQ29uZmlnIiwiZXhpc3RpbmdTdWJzY3JpcHRpb24iLCJvbkFjY291bnRDaGFuZ2UiLCJyZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIiLCJfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24iLCJhY2NvdW50SWQiLCJvblByb2dyYW1BY2NvdW50Q2hhbmdlIiwibWF5YmVGaWx0ZXJzIiwicmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIm9uTG9ncyIsIm1lbnRpb25zIiwicmVtb3ZlT25Mb2dzTGlzdGVuZXIiLCJvblNsb3RDaGFuZ2UiLCJyZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIiLCJvblNsb3RVcGRhdGUiLCJyZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIiLCJzdWJzY3JpcHRpb25OYW1lIiwiZGlzcG9zZSIsIm92ZXJyaWRlIiwiX2VyciIsIm9uU2lnbmF0dXJlV2l0aE9wdGlvbnMiLCJvblJvb3RDaGFuZ2UiLCJyZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIiLCJLZXlwYWlyIiwia2V5cGFpciIsIl9rZXlwYWlyIiwiZ2VuZXJhdGUiLCJmcm9tU2VjcmV0S2V5Iiwic2tpcFZhbGlkYXRpb24iLCJjb21wdXRlZFB1YmxpY0tleSIsImlpIiwiZnJvbVNlZWQiLCJMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsIkNyZWF0ZUxvb2t1cFRhYmxlIiwiYmlnaW50TGF5b3V0IiwiRnJlZXplTG9va3VwVGFibGUiLCJFeHRlbmRMb29rdXBUYWJsZSIsIkRlYWN0aXZhdGVMb29rdXBUYWJsZSIsIkNsb3NlTG9va3VwVGFibGUiLCJBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbiIsImxheW91dFR5cGUiLCJkZWNvZGVDcmVhdGVMb29rdXBUYWJsZSIsImNoZWNrS2V5c0xlbmd0aCIsInJlY2VudFNsb3QiLCJkZWNvZGVFeHRlbmRMb29rdXBUYWJsZSIsImRlY29kZUNsb3NlTG9va3VwVGFibGUiLCJyZWNpcGllbnQiLCJkZWNvZGVGcmVlemVMb29rdXBUYWJsZSIsImRlY29kZURlYWN0aXZhdGVMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0iLCJjcmVhdGVMb29rdXBUYWJsZSIsImxvb2t1cFRhYmxlQWRkcmVzcyIsImJ1bXBTZWVkIiwiZnJlZXplTG9va3VwVGFibGUiLCJleHRlbmRMb29rdXBUYWJsZSIsImFkZHIiLCJkZWFjdGl2YXRlTG9va3VwVGFibGUiLCJjbG9zZUxvb2t1cFRhYmxlIiwiQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIiwiQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZVJlcXVlc3RVbml0cyIsInVuaXRzIiwiYWRkaXRpb25hbEZlZSIsIlJlcXVlc3RVbml0cyIsImRlY29kZVJlcXVlc3RIZWFwRnJhbWUiLCJSZXF1ZXN0SGVhcEZyYW1lIiwiZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdCIsIlNldENvbXB1dGVVbml0TGltaXQiLCJkZWNvZGVTZXRDb21wdXRlVW5pdFByaWNlIiwibWljcm9MYW1wb3J0cyIsIlNldENvbXB1dGVVbml0UHJpY2UiLCJDb21wdXRlQnVkZ2V0UHJvZ3JhbSIsInJlcXVlc3RVbml0cyIsInJlcXVlc3RIZWFwRnJhbWUiLCJzZXRDb21wdXRlVW5pdExpbWl0Iiwic2V0Q29tcHV0ZVVuaXRQcmljZSIsIlBSSVZBVEVfS0VZX0JZVEVTIiwiUFVCTElDX0tFWV9CWVRFUyIsIlNJR05BVFVSRV9CWVRFUyIsIkVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUIiwidTE2IiwiRWQyNTUxOVByb2dyYW0iLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkiLCJpbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5T2Zmc2V0Iiwic2lnbmF0dXJlT2Zmc2V0IiwibWVzc2FnZURhdGFPZmZzZXQiLCJudW1TaWduYXR1cmVzIiwicGFkZGluZyIsInNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgiLCJwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4IiwibWVzc2FnZURhdGFTaXplIiwibWVzc2FnZUluc3RydWN0aW9uSW5kZXgiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImVjZHNhU2lnbiIsIm1zZ0hhc2giLCJwcml2S2V5Iiwic2VjcDI1NmsxIiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJyZWNvdmVyeSIsImlzVmFsaWRQcml2YXRlS2V5IiwicHVibGljS2V5Q3JlYXRlIiwiRVRIRVJFVU1fQUREUkVTU19CWVRFUyIsIlNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSIsIlNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQiLCJTZWNwMjU2azFQcm9ncmFtIiwicHVibGljS2V5VG9FdGhBZGRyZXNzIiwia2VjY2FrXzI1NiIsInJlY292ZXJ5SWQiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzIiwiZXRoQWRkcmVzcyIsInJhd0FkZHJlc3MiLCJzdWJzdHIiLCJkYXRhU3RhcnQiLCJldGhBZGRyZXNzT2Zmc2V0IiwiZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgiLCJwa2V5IiwibWVzc2FnZUhhc2giLCJTVEFLRV9DT05GSUdfSUQiLCJBdXRob3JpemVkIiwic3Rha2VyIiwid2l0aGRyYXdlciIsIkxvY2t1cCIsInVuaXhUaW1lc3RhbXAiLCJjdXN0b2RpYW4iLCJfTG9ja3VwIiwiU3Rha2VJbnN0cnVjdGlvbiIsIlNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVJbml0aWFsaXplIiwiSW5pdGlhbGl6ZSIsInN0YWtlUHVia2V5IiwiZGVjb2RlRGVsZWdhdGUiLCJEZWxlZ2F0ZSIsImRlY29kZUF1dGhvcml6ZSIsIm5ld0F1dGhvcml6ZWQiLCJzdGFrZUF1dGhvcml6YXRpb25UeXBlIiwiQXV0aG9yaXplIiwibyIsImN1c3RvZGlhblB1YmtleSIsImRlY29kZUF1dGhvcml6ZVdpdGhTZWVkIiwiYXV0aG9yaXR5U2VlZCIsImF1dGhvcml0eU93bmVyIiwiQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlCYXNlIiwiZGVjb2RlU3BsaXQiLCJTcGxpdCIsInNwbGl0U3Rha2VQdWJrZXkiLCJkZWNvZGVNZXJnZSIsIk1lcmdlIiwic291cmNlU3Rha2VQdWJLZXkiLCJkZWNvZGVXaXRoZHJhdyIsIldpdGhkcmF3IiwiZGVjb2RlRGVhY3RpdmF0ZSIsIkRlYWN0aXZhdGUiLCJTdGFrZVByb2dyYW0iLCJTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQiLCJTdGFrZXIiLCJXaXRoZHJhd2VyIiwiaW5pdGlhbGl6ZSIsIm1heWJlTG9ja3VwIiwiZGVsZWdhdGUiLCJhdXRob3JpemUiLCJhdXRob3JpemVXaXRoU2VlZCIsInNwbGl0SW5zdHJ1Y3Rpb24iLCJyZW50RXhlbXB0UmVzZXJ2ZSIsInNwbGl0V2l0aFNlZWQiLCJtZXJnZSIsIndpdGhkcmF3IiwiZGVhY3RpdmF0ZSIsIlZvdGVJbml0IiwiYXV0aG9yaXplZFZvdGVyIiwiYXV0aG9yaXplZFdpdGhkcmF3ZXIiLCJWb3RlSW5zdHJ1Y3Rpb24iLCJWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVJbml0aWFsaXplQWNjb3VudCIsIkluaXRpYWxpemVBY2NvdW50Iiwidm90ZUF1dGhvcml6YXRpb25UeXBlIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSIsImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCIsImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSIsImF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5IiwiVm90ZVByb2dyYW0iLCJVcGRhdGVWYWxpZGF0b3JJZGVudGl0eSIsIlZvdGVBdXRob3JpemF0aW9uTGF5b3V0IiwiVm90ZXIiLCJpbml0aWFsaXplQWNjb3VudCIsInNhZmVXaXRoZHJhdyIsImN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UiLCJyZW50RXhlbXB0TWluaW11bSIsInVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVkFMSURBVE9SX0lORk9fS0VZIiwiSW5mb1N0cmluZyIsIndlYnNpdGUiLCJkZXRhaWxzIiwiaWNvblVybCIsImtleWJhc2VVc2VybmFtZSIsIlZhbGlkYXRvckluZm8iLCJmcm9tQ29uZmlnRGF0YSIsImNvbmZpZ0tleUNvdW50IiwiY29uZmlnS2V5cyIsInJhd0luZm8iLCJhc3NlcnRUeXBlIiwiVk9URV9QUk9HUkFNX0lEIiwiVm90ZUFjY291bnRMYXlvdXQiLCJWb3RlQWNjb3VudCIsInZvdGVzIiwiYXV0aG9yaXplZFZvdGVycyIsInByaW9yVm90ZXJzIiwibGFzdFRpbWVzdGFtcCIsInZlcnNpb25PZmZzZXQiLCJ2YSIsInJvb3RTbG90VmFsaWQiLCJwYXJzZUF1dGhvcml6ZWRWb3RlciIsImdldFByaW9yVm90ZXJzIiwicGFyc2VQcmlvclZvdGVycyIsImVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCIsInRhcmdldEVwb2NoIiwiaWR4IiwiaXNFbXB0eSIsImh0dHAiLCJkZXZuZXQiLCJ0ZXN0bmV0IiwiaHR0cHMiLCJjbHVzdGVyQXBpVXJsIiwiY2x1c3RlciIsInRscyIsInNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24iLCJjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMiLCJtYXliZUNvbmZpcm1PcHRpb25zIiwiY29uZmlybWF0aW9uU3RyYXRlZ3kiLCJMQU1QT1JUU19QRVJfU09MIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/web3.js/lib/index.cjs.js\n");

/***/ }),

/***/ "./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function(module1, exports) {\n    \"use strict\";\n    // Utils\n    function assert(val, msg) {\n        if (!val) throw new Error(msg || \"Assertion failed\");\n    }\n    // Could use `inherits` module, but don't want to move from single file\n    // architecture yet.\n    function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        var TempCtor = function() {};\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n    }\n    // BN\n    function BN(number, base, endian) {\n        if (BN.isBN(number)) {\n            return number;\n        }\n        this.negative = 0;\n        this.words = null;\n        this.length = 0;\n        // Reduction context\n        this.red = null;\n        if (number !== null) {\n            if (base === \"le\" || base === \"be\") {\n                endian = base;\n                base = 10;\n            }\n            this._init(number || 0, base || 10, endian || \"be\");\n        }\n    }\n    if (typeof module1 === \"object\") {\n        module1.exports = BN;\n    } else {\n        exports.BN = BN;\n    }\n    BN.BN = BN;\n    BN.wordSize = 26;\n    var Buffer;\n    try {\n        if (false) {} else {\n            Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n        }\n    } catch (e) {}\n    BN.isBN = function isBN(num) {\n        if (num instanceof BN) {\n            return true;\n        }\n        return num !== null && typeof num === \"object\" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n    };\n    BN.max = function max(left, right) {\n        if (left.cmp(right) > 0) return left;\n        return right;\n    };\n    BN.min = function min(left, right) {\n        if (left.cmp(right) < 0) return left;\n        return right;\n    };\n    BN.prototype._init = function init(number, base, endian) {\n        if (typeof number === \"number\") {\n            return this._initNumber(number, base, endian);\n        }\n        if (typeof number === \"object\") {\n            return this._initArray(number, base, endian);\n        }\n        if (base === \"hex\") {\n            base = 16;\n        }\n        assert(base === (base | 0) && base >= 2 && base <= 36);\n        number = number.toString().replace(/\\s+/g, \"\");\n        var start = 0;\n        if (number[0] === \"-\") {\n            start++;\n            this.negative = 1;\n        }\n        if (start < number.length) {\n            if (base === 16) {\n                this._parseHex(number, start, endian);\n            } else {\n                this._parseBase(number, base, start);\n                if (endian === \"le\") {\n                    this._initArray(this.toArray(), base, endian);\n                }\n            }\n        }\n    };\n    BN.prototype._initNumber = function _initNumber(number, base, endian) {\n        if (number < 0) {\n            this.negative = 1;\n            number = -number;\n        }\n        if (number < 0x4000000) {\n            this.words = [\n                number & 0x3ffffff\n            ];\n            this.length = 1;\n        } else if (number < 0x10000000000000) {\n            this.words = [\n                number & 0x3ffffff,\n                number / 0x4000000 & 0x3ffffff\n            ];\n            this.length = 2;\n        } else {\n            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n            this.words = [\n                number & 0x3ffffff,\n                number / 0x4000000 & 0x3ffffff,\n                1\n            ];\n            this.length = 3;\n        }\n        if (endian !== \"le\") return;\n        // Reverse the bytes\n        this._initArray(this.toArray(), base, endian);\n    };\n    BN.prototype._initArray = function _initArray(number, base, endian) {\n        // Perhaps a Uint8Array\n        assert(typeof number.length === \"number\");\n        if (number.length <= 0) {\n            this.words = [\n                0\n            ];\n            this.length = 1;\n            return this;\n        }\n        this.length = Math.ceil(number.length / 3);\n        this.words = new Array(this.length);\n        for(var i = 0; i < this.length; i++){\n            this.words[i] = 0;\n        }\n        var j, w;\n        var off = 0;\n        if (endian === \"be\") {\n            for(i = number.length - 1, j = 0; i >= 0; i -= 3){\n                w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;\n                this.words[j] |= w << off & 0x3ffffff;\n                this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n                off += 24;\n                if (off >= 26) {\n                    off -= 26;\n                    j++;\n                }\n            }\n        } else if (endian === \"le\") {\n            for(i = 0, j = 0; i < number.length; i += 3){\n                w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;\n                this.words[j] |= w << off & 0x3ffffff;\n                this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n                off += 24;\n                if (off >= 26) {\n                    off -= 26;\n                    j++;\n                }\n            }\n        }\n        return this._strip();\n    };\n    function parseHex4Bits(string, index) {\n        var c = string.charCodeAt(index);\n        // '0' - '9'\n        if (c >= 48 && c <= 57) {\n            return c - 48;\n        // 'A' - 'F'\n        } else if (c >= 65 && c <= 70) {\n            return c - 55;\n        // 'a' - 'f'\n        } else if (c >= 97 && c <= 102) {\n            return c - 87;\n        } else {\n            assert(false, \"Invalid character in \" + string);\n        }\n    }\n    function parseHexByte(string, lowerBound, index) {\n        var r = parseHex4Bits(string, index);\n        if (index - 1 >= lowerBound) {\n            r |= parseHex4Bits(string, index - 1) << 4;\n        }\n        return r;\n    }\n    BN.prototype._parseHex = function _parseHex(number, start, endian) {\n        // Create possibly bigger array to ensure that it fits the number\n        this.length = Math.ceil((number.length - start) / 6);\n        this.words = new Array(this.length);\n        for(var i = 0; i < this.length; i++){\n            this.words[i] = 0;\n        }\n        // 24-bits chunks\n        var off = 0;\n        var j = 0;\n        var w;\n        if (endian === \"be\") {\n            for(i = number.length - 1; i >= start; i -= 2){\n                w = parseHexByte(number, start, i) << off;\n                this.words[j] |= w & 0x3ffffff;\n                if (off >= 18) {\n                    off -= 18;\n                    j += 1;\n                    this.words[j] |= w >>> 26;\n                } else {\n                    off += 8;\n                }\n            }\n        } else {\n            var parseLength = number.length - start;\n            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){\n                w = parseHexByte(number, start, i) << off;\n                this.words[j] |= w & 0x3ffffff;\n                if (off >= 18) {\n                    off -= 18;\n                    j += 1;\n                    this.words[j] |= w >>> 26;\n                } else {\n                    off += 8;\n                }\n            }\n        }\n        this._strip();\n    };\n    function parseBase(str, start, end, mul) {\n        var r = 0;\n        var b = 0;\n        var len = Math.min(str.length, end);\n        for(var i = start; i < len; i++){\n            var c = str.charCodeAt(i) - 48;\n            r *= mul;\n            // 'a'\n            if (c >= 49) {\n                b = c - 49 + 0xa;\n            // 'A'\n            } else if (c >= 17) {\n                b = c - 17 + 0xa;\n            // '0' - '9'\n            } else {\n                b = c;\n            }\n            assert(c >= 0 && b < mul, \"Invalid character\");\n            r += b;\n        }\n        return r;\n    }\n    BN.prototype._parseBase = function _parseBase(number, base, start) {\n        // Initialize as zero\n        this.words = [\n            0\n        ];\n        this.length = 1;\n        // Find length of limb in base\n        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base){\n            limbLen++;\n        }\n        limbLen--;\n        limbPow = limbPow / base | 0;\n        var total = number.length - start;\n        var mod = total % limbLen;\n        var end = Math.min(total, total - mod) + start;\n        var word = 0;\n        for(var i = start; i < end; i += limbLen){\n            word = parseBase(number, i, i + limbLen, base);\n            this.imuln(limbPow);\n            if (this.words[0] + word < 0x4000000) {\n                this.words[0] += word;\n            } else {\n                this._iaddn(word);\n            }\n        }\n        if (mod !== 0) {\n            var pow = 1;\n            word = parseBase(number, i, number.length, base);\n            for(i = 0; i < mod; i++){\n                pow *= base;\n            }\n            this.imuln(pow);\n            if (this.words[0] + word < 0x4000000) {\n                this.words[0] += word;\n            } else {\n                this._iaddn(word);\n            }\n        }\n        this._strip();\n    };\n    BN.prototype.copy = function copy(dest) {\n        dest.words = new Array(this.length);\n        for(var i = 0; i < this.length; i++){\n            dest.words[i] = this.words[i];\n        }\n        dest.length = this.length;\n        dest.negative = this.negative;\n        dest.red = this.red;\n    };\n    function move(dest, src) {\n        dest.words = src.words;\n        dest.length = src.length;\n        dest.negative = src.negative;\n        dest.red = src.red;\n    }\n    BN.prototype._move = function _move(dest) {\n        move(dest, this);\n    };\n    BN.prototype.clone = function clone() {\n        var r = new BN(null);\n        this.copy(r);\n        return r;\n    };\n    BN.prototype._expand = function _expand(size) {\n        while(this.length < size){\n            this.words[this.length++] = 0;\n        }\n        return this;\n    };\n    // Remove leading `0` from `this`\n    BN.prototype._strip = function strip() {\n        while(this.length > 1 && this.words[this.length - 1] === 0){\n            this.length--;\n        }\n        return this._normSign();\n    };\n    BN.prototype._normSign = function _normSign() {\n        // -0 = 0\n        if (this.length === 1 && this.words[0] === 0) {\n            this.negative = 0;\n        }\n        return this;\n    };\n    // Check Symbol.for because not everywhere where Symbol defined\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n    if (typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\") {\n        try {\n            BN.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = inspect;\n        } catch (e) {\n            BN.prototype.inspect = inspect;\n        }\n    } else {\n        BN.prototype.inspect = inspect;\n    }\n    function inspect() {\n        return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n    }\n    /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */ var zeros = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n    ];\n    var groupSizes = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n    ];\n    var groupBases = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        10000000,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64000000,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        24300000,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n    ];\n    BN.prototype.toString = function toString(base, padding) {\n        base = base || 10;\n        padding = padding | 0 || 1;\n        var out;\n        if (base === 16 || base === \"hex\") {\n            out = \"\";\n            var off = 0;\n            var carry = 0;\n            for(var i = 0; i < this.length; i++){\n                var w = this.words[i];\n                var word = ((w << off | carry) & 0xffffff).toString(16);\n                carry = w >>> 24 - off & 0xffffff;\n                off += 2;\n                if (off >= 26) {\n                    off -= 26;\n                    i--;\n                }\n                if (carry !== 0 || i !== this.length - 1) {\n                    out = zeros[6 - word.length] + word + out;\n                } else {\n                    out = word + out;\n                }\n            }\n            if (carry !== 0) {\n                out = carry.toString(16) + out;\n            }\n            while(out.length % padding !== 0){\n                out = \"0\" + out;\n            }\n            if (this.negative !== 0) {\n                out = \"-\" + out;\n            }\n            return out;\n        }\n        if (base === (base | 0) && base >= 2 && base <= 36) {\n            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n            var groupSize = groupSizes[base];\n            // var groupBase = Math.pow(base, groupSize);\n            var groupBase = groupBases[base];\n            out = \"\";\n            var c = this.clone();\n            c.negative = 0;\n            while(!c.isZero()){\n                var r = c.modrn(groupBase).toString(base);\n                c = c.idivn(groupBase);\n                if (!c.isZero()) {\n                    out = zeros[groupSize - r.length] + r + out;\n                } else {\n                    out = r + out;\n                }\n            }\n            if (this.isZero()) {\n                out = \"0\" + out;\n            }\n            while(out.length % padding !== 0){\n                out = \"0\" + out;\n            }\n            if (this.negative !== 0) {\n                out = \"-\" + out;\n            }\n            return out;\n        }\n        assert(false, \"Base should be between 2 and 36\");\n    };\n    BN.prototype.toNumber = function toNumber() {\n        var ret = this.words[0];\n        if (this.length === 2) {\n            ret += this.words[1] * 0x4000000;\n        } else if (this.length === 3 && this.words[2] === 0x01) {\n            // NOTE: at this stage it is known that the top bit is set\n            ret += 0x10000000000000 + this.words[1] * 0x4000000;\n        } else if (this.length > 2) {\n            assert(false, \"Number can only safely store up to 53 bits\");\n        }\n        return this.negative !== 0 ? -ret : ret;\n    };\n    BN.prototype.toJSON = function toJSON() {\n        return this.toString(16, 2);\n    };\n    if (Buffer) {\n        BN.prototype.toBuffer = function toBuffer(endian, length) {\n            return this.toArrayLike(Buffer, endian, length);\n        };\n    }\n    BN.prototype.toArray = function toArray(endian, length) {\n        return this.toArrayLike(Array, endian, length);\n    };\n    var allocate = function allocate(ArrayType, size) {\n        if (ArrayType.allocUnsafe) {\n            return ArrayType.allocUnsafe(size);\n        }\n        return new ArrayType(size);\n    };\n    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {\n        this._strip();\n        var byteLength = this.byteLength();\n        var reqLength = length || Math.max(1, byteLength);\n        assert(byteLength <= reqLength, \"byte array longer than desired length\");\n        assert(reqLength > 0, \"Requested array length <= 0\");\n        var res = allocate(ArrayType, reqLength);\n        var postfix = endian === \"le\" ? \"LE\" : \"BE\";\n        this[\"_toArrayLike\" + postfix](res, byteLength);\n        return res;\n    };\n    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {\n        var position = 0;\n        var carry = 0;\n        for(var i = 0, shift = 0; i < this.length; i++){\n            var word = this.words[i] << shift | carry;\n            res[position++] = word & 0xff;\n            if (position < res.length) {\n                res[position++] = word >> 8 & 0xff;\n            }\n            if (position < res.length) {\n                res[position++] = word >> 16 & 0xff;\n            }\n            if (shift === 6) {\n                if (position < res.length) {\n                    res[position++] = word >> 24 & 0xff;\n                }\n                carry = 0;\n                shift = 0;\n            } else {\n                carry = word >>> 24;\n                shift += 2;\n            }\n        }\n        if (position < res.length) {\n            res[position++] = carry;\n            while(position < res.length){\n                res[position++] = 0;\n            }\n        }\n    };\n    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {\n        var position = res.length - 1;\n        var carry = 0;\n        for(var i = 0, shift = 0; i < this.length; i++){\n            var word = this.words[i] << shift | carry;\n            res[position--] = word & 0xff;\n            if (position >= 0) {\n                res[position--] = word >> 8 & 0xff;\n            }\n            if (position >= 0) {\n                res[position--] = word >> 16 & 0xff;\n            }\n            if (shift === 6) {\n                if (position >= 0) {\n                    res[position--] = word >> 24 & 0xff;\n                }\n                carry = 0;\n                shift = 0;\n            } else {\n                carry = word >>> 24;\n                shift += 2;\n            }\n        }\n        if (position >= 0) {\n            res[position--] = carry;\n            while(position >= 0){\n                res[position--] = 0;\n            }\n        }\n    };\n    if (Math.clz32) {\n        BN.prototype._countBits = function _countBits(w) {\n            return 32 - Math.clz32(w);\n        };\n    } else {\n        BN.prototype._countBits = function _countBits(w) {\n            var t = w;\n            var r = 0;\n            if (t >= 0x1000) {\n                r += 13;\n                t >>>= 13;\n            }\n            if (t >= 0x40) {\n                r += 7;\n                t >>>= 7;\n            }\n            if (t >= 0x8) {\n                r += 4;\n                t >>>= 4;\n            }\n            if (t >= 0x02) {\n                r += 2;\n                t >>>= 2;\n            }\n            return r + t;\n        };\n    }\n    BN.prototype._zeroBits = function _zeroBits(w) {\n        // Short-cut\n        if (w === 0) return 26;\n        var t = w;\n        var r = 0;\n        if ((t & 0x1fff) === 0) {\n            r += 13;\n            t >>>= 13;\n        }\n        if ((t & 0x7f) === 0) {\n            r += 7;\n            t >>>= 7;\n        }\n        if ((t & 0xf) === 0) {\n            r += 4;\n            t >>>= 4;\n        }\n        if ((t & 0x3) === 0) {\n            r += 2;\n            t >>>= 2;\n        }\n        if ((t & 0x1) === 0) {\n            r++;\n        }\n        return r;\n    };\n    // Return number of used bits in a BN\n    BN.prototype.bitLength = function bitLength() {\n        var w = this.words[this.length - 1];\n        var hi = this._countBits(w);\n        return (this.length - 1) * 26 + hi;\n    };\n    function toBitArray(num) {\n        var w = new Array(num.bitLength());\n        for(var bit = 0; bit < w.length; bit++){\n            var off = bit / 26 | 0;\n            var wbit = bit % 26;\n            w[bit] = num.words[off] >>> wbit & 0x01;\n        }\n        return w;\n    }\n    // Number of trailing zero bits\n    BN.prototype.zeroBits = function zeroBits() {\n        if (this.isZero()) return 0;\n        var r = 0;\n        for(var i = 0; i < this.length; i++){\n            var b = this._zeroBits(this.words[i]);\n            r += b;\n            if (b !== 26) break;\n        }\n        return r;\n    };\n    BN.prototype.byteLength = function byteLength() {\n        return Math.ceil(this.bitLength() / 8);\n    };\n    BN.prototype.toTwos = function toTwos(width) {\n        if (this.negative !== 0) {\n            return this.abs().inotn(width).iaddn(1);\n        }\n        return this.clone();\n    };\n    BN.prototype.fromTwos = function fromTwos(width) {\n        if (this.testn(width - 1)) {\n            return this.notn(width).iaddn(1).ineg();\n        }\n        return this.clone();\n    };\n    BN.prototype.isNeg = function isNeg() {\n        return this.negative !== 0;\n    };\n    // Return negative clone of `this`\n    BN.prototype.neg = function neg() {\n        return this.clone().ineg();\n    };\n    BN.prototype.ineg = function ineg() {\n        if (!this.isZero()) {\n            this.negative ^= 1;\n        }\n        return this;\n    };\n    // Or `num` with `this` in-place\n    BN.prototype.iuor = function iuor(num) {\n        while(this.length < num.length){\n            this.words[this.length++] = 0;\n        }\n        for(var i = 0; i < num.length; i++){\n            this.words[i] = this.words[i] | num.words[i];\n        }\n        return this._strip();\n    };\n    BN.prototype.ior = function ior(num) {\n        assert((this.negative | num.negative) === 0);\n        return this.iuor(num);\n    };\n    // Or `num` with `this`\n    BN.prototype.or = function or(num) {\n        if (this.length > num.length) return this.clone().ior(num);\n        return num.clone().ior(this);\n    };\n    BN.prototype.uor = function uor(num) {\n        if (this.length > num.length) return this.clone().iuor(num);\n        return num.clone().iuor(this);\n    };\n    // And `num` with `this` in-place\n    BN.prototype.iuand = function iuand(num) {\n        // b = min-length(num, this)\n        var b;\n        if (this.length > num.length) {\n            b = num;\n        } else {\n            b = this;\n        }\n        for(var i = 0; i < b.length; i++){\n            this.words[i] = this.words[i] & num.words[i];\n        }\n        this.length = b.length;\n        return this._strip();\n    };\n    BN.prototype.iand = function iand(num) {\n        assert((this.negative | num.negative) === 0);\n        return this.iuand(num);\n    };\n    // And `num` with `this`\n    BN.prototype.and = function and(num) {\n        if (this.length > num.length) return this.clone().iand(num);\n        return num.clone().iand(this);\n    };\n    BN.prototype.uand = function uand(num) {\n        if (this.length > num.length) return this.clone().iuand(num);\n        return num.clone().iuand(this);\n    };\n    // Xor `num` with `this` in-place\n    BN.prototype.iuxor = function iuxor(num) {\n        // a.length > b.length\n        var a;\n        var b;\n        if (this.length > num.length) {\n            a = this;\n            b = num;\n        } else {\n            a = num;\n            b = this;\n        }\n        for(var i = 0; i < b.length; i++){\n            this.words[i] = a.words[i] ^ b.words[i];\n        }\n        if (this !== a) {\n            for(; i < a.length; i++){\n                this.words[i] = a.words[i];\n            }\n        }\n        this.length = a.length;\n        return this._strip();\n    };\n    BN.prototype.ixor = function ixor(num) {\n        assert((this.negative | num.negative) === 0);\n        return this.iuxor(num);\n    };\n    // Xor `num` with `this`\n    BN.prototype.xor = function xor(num) {\n        if (this.length > num.length) return this.clone().ixor(num);\n        return num.clone().ixor(this);\n    };\n    BN.prototype.uxor = function uxor(num) {\n        if (this.length > num.length) return this.clone().iuxor(num);\n        return num.clone().iuxor(this);\n    };\n    // Not ``this`` with ``width`` bitwidth\n    BN.prototype.inotn = function inotn(width) {\n        assert(typeof width === \"number\" && width >= 0);\n        var bytesNeeded = Math.ceil(width / 26) | 0;\n        var bitsLeft = width % 26;\n        // Extend the buffer with leading zeroes\n        this._expand(bytesNeeded);\n        if (bitsLeft > 0) {\n            bytesNeeded--;\n        }\n        // Handle complete words\n        for(var i = 0; i < bytesNeeded; i++){\n            this.words[i] = ~this.words[i] & 0x3ffffff;\n        }\n        // Handle the residue\n        if (bitsLeft > 0) {\n            this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;\n        }\n        // And remove leading zeroes\n        return this._strip();\n    };\n    BN.prototype.notn = function notn(width) {\n        return this.clone().inotn(width);\n    };\n    // Set `bit` of `this`\n    BN.prototype.setn = function setn(bit, val) {\n        assert(typeof bit === \"number\" && bit >= 0);\n        var off = bit / 26 | 0;\n        var wbit = bit % 26;\n        this._expand(off + 1);\n        if (val) {\n            this.words[off] = this.words[off] | 1 << wbit;\n        } else {\n            this.words[off] = this.words[off] & ~(1 << wbit);\n        }\n        return this._strip();\n    };\n    // Add `num` to `this` in-place\n    BN.prototype.iadd = function iadd(num) {\n        var r;\n        // negative + positive\n        if (this.negative !== 0 && num.negative === 0) {\n            this.negative = 0;\n            r = this.isub(num);\n            this.negative ^= 1;\n            return this._normSign();\n        // positive + negative\n        } else if (this.negative === 0 && num.negative !== 0) {\n            num.negative = 0;\n            r = this.isub(num);\n            num.negative = 1;\n            return r._normSign();\n        }\n        // a.length > b.length\n        var a, b;\n        if (this.length > num.length) {\n            a = this;\n            b = num;\n        } else {\n            a = num;\n            b = this;\n        }\n        var carry = 0;\n        for(var i = 0; i < b.length; i++){\n            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n            this.words[i] = r & 0x3ffffff;\n            carry = r >>> 26;\n        }\n        for(; carry !== 0 && i < a.length; i++){\n            r = (a.words[i] | 0) + carry;\n            this.words[i] = r & 0x3ffffff;\n            carry = r >>> 26;\n        }\n        this.length = a.length;\n        if (carry !== 0) {\n            this.words[this.length] = carry;\n            this.length++;\n        // Copy the rest of the words\n        } else if (a !== this) {\n            for(; i < a.length; i++){\n                this.words[i] = a.words[i];\n            }\n        }\n        return this;\n    };\n    // Add `num` to `this`\n    BN.prototype.add = function add(num) {\n        var res;\n        if (num.negative !== 0 && this.negative === 0) {\n            num.negative = 0;\n            res = this.sub(num);\n            num.negative ^= 1;\n            return res;\n        } else if (num.negative === 0 && this.negative !== 0) {\n            this.negative = 0;\n            res = num.sub(this);\n            this.negative = 1;\n            return res;\n        }\n        if (this.length > num.length) return this.clone().iadd(num);\n        return num.clone().iadd(this);\n    };\n    // Subtract `num` from `this` in-place\n    BN.prototype.isub = function isub(num) {\n        // this - (-num) = this + num\n        if (num.negative !== 0) {\n            num.negative = 0;\n            var r = this.iadd(num);\n            num.negative = 1;\n            return r._normSign();\n        // -this - num = -(this + num)\n        } else if (this.negative !== 0) {\n            this.negative = 0;\n            this.iadd(num);\n            this.negative = 1;\n            return this._normSign();\n        }\n        // At this point both numbers are positive\n        var cmp = this.cmp(num);\n        // Optimization - zeroify\n        if (cmp === 0) {\n            this.negative = 0;\n            this.length = 1;\n            this.words[0] = 0;\n            return this;\n        }\n        // a > b\n        var a, b;\n        if (cmp > 0) {\n            a = this;\n            b = num;\n        } else {\n            a = num;\n            b = this;\n        }\n        var carry = 0;\n        for(var i = 0; i < b.length; i++){\n            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n            carry = r >> 26;\n            this.words[i] = r & 0x3ffffff;\n        }\n        for(; carry !== 0 && i < a.length; i++){\n            r = (a.words[i] | 0) + carry;\n            carry = r >> 26;\n            this.words[i] = r & 0x3ffffff;\n        }\n        // Copy rest of the words\n        if (carry === 0 && i < a.length && a !== this) {\n            for(; i < a.length; i++){\n                this.words[i] = a.words[i];\n            }\n        }\n        this.length = Math.max(this.length, i);\n        if (a !== this) {\n            this.negative = 1;\n        }\n        return this._strip();\n    };\n    // Subtract `num` from `this`\n    BN.prototype.sub = function sub(num) {\n        return this.clone().isub(num);\n    };\n    function smallMulTo(self, num, out) {\n        out.negative = num.negative ^ self.negative;\n        var len = self.length + num.length | 0;\n        out.length = len;\n        len = len - 1 | 0;\n        // Peel one iteration (compiler can't do it, because of code complexity)\n        var a = self.words[0] | 0;\n        var b = num.words[0] | 0;\n        var r = a * b;\n        var lo = r & 0x3ffffff;\n        var carry = r / 0x4000000 | 0;\n        out.words[0] = lo;\n        for(var k = 1; k < len; k++){\n            // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n            // note that ncarry could be >= 0x3ffffff\n            var ncarry = carry >>> 26;\n            var rword = carry & 0x3ffffff;\n            var maxJ = Math.min(k, num.length - 1);\n            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){\n                var i = k - j | 0;\n                a = self.words[i] | 0;\n                b = num.words[j] | 0;\n                r = a * b + rword;\n                ncarry += r / 0x4000000 | 0;\n                rword = r & 0x3ffffff;\n            }\n            out.words[k] = rword | 0;\n            carry = ncarry | 0;\n        }\n        if (carry !== 0) {\n            out.words[k] = carry | 0;\n        } else {\n            out.length--;\n        }\n        return out._strip();\n    }\n    // TODO(indutny): it may be reasonable to omit it for users who don't need\n    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n    // multiplication (like elliptic secp256k1).\n    var comb10MulTo = function comb10MulTo(self, num, out) {\n        var a = self.words;\n        var b = num.words;\n        var o = out.words;\n        var c = 0;\n        var lo;\n        var mid;\n        var hi;\n        var a0 = a[0] | 0;\n        var al0 = a0 & 0x1fff;\n        var ah0 = a0 >>> 13;\n        var a1 = a[1] | 0;\n        var al1 = a1 & 0x1fff;\n        var ah1 = a1 >>> 13;\n        var a2 = a[2] | 0;\n        var al2 = a2 & 0x1fff;\n        var ah2 = a2 >>> 13;\n        var a3 = a[3] | 0;\n        var al3 = a3 & 0x1fff;\n        var ah3 = a3 >>> 13;\n        var a4 = a[4] | 0;\n        var al4 = a4 & 0x1fff;\n        var ah4 = a4 >>> 13;\n        var a5 = a[5] | 0;\n        var al5 = a5 & 0x1fff;\n        var ah5 = a5 >>> 13;\n        var a6 = a[6] | 0;\n        var al6 = a6 & 0x1fff;\n        var ah6 = a6 >>> 13;\n        var a7 = a[7] | 0;\n        var al7 = a7 & 0x1fff;\n        var ah7 = a7 >>> 13;\n        var a8 = a[8] | 0;\n        var al8 = a8 & 0x1fff;\n        var ah8 = a8 >>> 13;\n        var a9 = a[9] | 0;\n        var al9 = a9 & 0x1fff;\n        var ah9 = a9 >>> 13;\n        var b0 = b[0] | 0;\n        var bl0 = b0 & 0x1fff;\n        var bh0 = b0 >>> 13;\n        var b1 = b[1] | 0;\n        var bl1 = b1 & 0x1fff;\n        var bh1 = b1 >>> 13;\n        var b2 = b[2] | 0;\n        var bl2 = b2 & 0x1fff;\n        var bh2 = b2 >>> 13;\n        var b3 = b[3] | 0;\n        var bl3 = b3 & 0x1fff;\n        var bh3 = b3 >>> 13;\n        var b4 = b[4] | 0;\n        var bl4 = b4 & 0x1fff;\n        var bh4 = b4 >>> 13;\n        var b5 = b[5] | 0;\n        var bl5 = b5 & 0x1fff;\n        var bh5 = b5 >>> 13;\n        var b6 = b[6] | 0;\n        var bl6 = b6 & 0x1fff;\n        var bh6 = b6 >>> 13;\n        var b7 = b[7] | 0;\n        var bl7 = b7 & 0x1fff;\n        var bh7 = b7 >>> 13;\n        var b8 = b[8] | 0;\n        var bl8 = b8 & 0x1fff;\n        var bh8 = b8 >>> 13;\n        var b9 = b[9] | 0;\n        var bl9 = b9 & 0x1fff;\n        var bh9 = b9 >>> 13;\n        out.negative = self.negative ^ num.negative;\n        out.length = 19;\n        /* k = 0 */ lo = Math.imul(al0, bl0);\n        mid = Math.imul(al0, bh0);\n        mid = mid + Math.imul(ah0, bl0) | 0;\n        hi = Math.imul(ah0, bh0);\n        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;\n        w0 &= 0x3ffffff;\n        /* k = 1 */ lo = Math.imul(al1, bl0);\n        mid = Math.imul(al1, bh0);\n        mid = mid + Math.imul(ah1, bl0) | 0;\n        hi = Math.imul(ah1, bh0);\n        lo = lo + Math.imul(al0, bl1) | 0;\n        mid = mid + Math.imul(al0, bh1) | 0;\n        mid = mid + Math.imul(ah0, bl1) | 0;\n        hi = hi + Math.imul(ah0, bh1) | 0;\n        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;\n        w1 &= 0x3ffffff;\n        /* k = 2 */ lo = Math.imul(al2, bl0);\n        mid = Math.imul(al2, bh0);\n        mid = mid + Math.imul(ah2, bl0) | 0;\n        hi = Math.imul(ah2, bh0);\n        lo = lo + Math.imul(al1, bl1) | 0;\n        mid = mid + Math.imul(al1, bh1) | 0;\n        mid = mid + Math.imul(ah1, bl1) | 0;\n        hi = hi + Math.imul(ah1, bh1) | 0;\n        lo = lo + Math.imul(al0, bl2) | 0;\n        mid = mid + Math.imul(al0, bh2) | 0;\n        mid = mid + Math.imul(ah0, bl2) | 0;\n        hi = hi + Math.imul(ah0, bh2) | 0;\n        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;\n        w2 &= 0x3ffffff;\n        /* k = 3 */ lo = Math.imul(al3, bl0);\n        mid = Math.imul(al3, bh0);\n        mid = mid + Math.imul(ah3, bl0) | 0;\n        hi = Math.imul(ah3, bh0);\n        lo = lo + Math.imul(al2, bl1) | 0;\n        mid = mid + Math.imul(al2, bh1) | 0;\n        mid = mid + Math.imul(ah2, bl1) | 0;\n        hi = hi + Math.imul(ah2, bh1) | 0;\n        lo = lo + Math.imul(al1, bl2) | 0;\n        mid = mid + Math.imul(al1, bh2) | 0;\n        mid = mid + Math.imul(ah1, bl2) | 0;\n        hi = hi + Math.imul(ah1, bh2) | 0;\n        lo = lo + Math.imul(al0, bl3) | 0;\n        mid = mid + Math.imul(al0, bh3) | 0;\n        mid = mid + Math.imul(ah0, bl3) | 0;\n        hi = hi + Math.imul(ah0, bh3) | 0;\n        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;\n        w3 &= 0x3ffffff;\n        /* k = 4 */ lo = Math.imul(al4, bl0);\n        mid = Math.imul(al4, bh0);\n        mid = mid + Math.imul(ah4, bl0) | 0;\n        hi = Math.imul(ah4, bh0);\n        lo = lo + Math.imul(al3, bl1) | 0;\n        mid = mid + Math.imul(al3, bh1) | 0;\n        mid = mid + Math.imul(ah3, bl1) | 0;\n        hi = hi + Math.imul(ah3, bh1) | 0;\n        lo = lo + Math.imul(al2, bl2) | 0;\n        mid = mid + Math.imul(al2, bh2) | 0;\n        mid = mid + Math.imul(ah2, bl2) | 0;\n        hi = hi + Math.imul(ah2, bh2) | 0;\n        lo = lo + Math.imul(al1, bl3) | 0;\n        mid = mid + Math.imul(al1, bh3) | 0;\n        mid = mid + Math.imul(ah1, bl3) | 0;\n        hi = hi + Math.imul(ah1, bh3) | 0;\n        lo = lo + Math.imul(al0, bl4) | 0;\n        mid = mid + Math.imul(al0, bh4) | 0;\n        mid = mid + Math.imul(ah0, bl4) | 0;\n        hi = hi + Math.imul(ah0, bh4) | 0;\n        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;\n        w4 &= 0x3ffffff;\n        /* k = 5 */ lo = Math.imul(al5, bl0);\n        mid = Math.imul(al5, bh0);\n        mid = mid + Math.imul(ah5, bl0) | 0;\n        hi = Math.imul(ah5, bh0);\n        lo = lo + Math.imul(al4, bl1) | 0;\n        mid = mid + Math.imul(al4, bh1) | 0;\n        mid = mid + Math.imul(ah4, bl1) | 0;\n        hi = hi + Math.imul(ah4, bh1) | 0;\n        lo = lo + Math.imul(al3, bl2) | 0;\n        mid = mid + Math.imul(al3, bh2) | 0;\n        mid = mid + Math.imul(ah3, bl2) | 0;\n        hi = hi + Math.imul(ah3, bh2) | 0;\n        lo = lo + Math.imul(al2, bl3) | 0;\n        mid = mid + Math.imul(al2, bh3) | 0;\n        mid = mid + Math.imul(ah2, bl3) | 0;\n        hi = hi + Math.imul(ah2, bh3) | 0;\n        lo = lo + Math.imul(al1, bl4) | 0;\n        mid = mid + Math.imul(al1, bh4) | 0;\n        mid = mid + Math.imul(ah1, bl4) | 0;\n        hi = hi + Math.imul(ah1, bh4) | 0;\n        lo = lo + Math.imul(al0, bl5) | 0;\n        mid = mid + Math.imul(al0, bh5) | 0;\n        mid = mid + Math.imul(ah0, bl5) | 0;\n        hi = hi + Math.imul(ah0, bh5) | 0;\n        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;\n        w5 &= 0x3ffffff;\n        /* k = 6 */ lo = Math.imul(al6, bl0);\n        mid = Math.imul(al6, bh0);\n        mid = mid + Math.imul(ah6, bl0) | 0;\n        hi = Math.imul(ah6, bh0);\n        lo = lo + Math.imul(al5, bl1) | 0;\n        mid = mid + Math.imul(al5, bh1) | 0;\n        mid = mid + Math.imul(ah5, bl1) | 0;\n        hi = hi + Math.imul(ah5, bh1) | 0;\n        lo = lo + Math.imul(al4, bl2) | 0;\n        mid = mid + Math.imul(al4, bh2) | 0;\n        mid = mid + Math.imul(ah4, bl2) | 0;\n        hi = hi + Math.imul(ah4, bh2) | 0;\n        lo = lo + Math.imul(al3, bl3) | 0;\n        mid = mid + Math.imul(al3, bh3) | 0;\n        mid = mid + Math.imul(ah3, bl3) | 0;\n        hi = hi + Math.imul(ah3, bh3) | 0;\n        lo = lo + Math.imul(al2, bl4) | 0;\n        mid = mid + Math.imul(al2, bh4) | 0;\n        mid = mid + Math.imul(ah2, bl4) | 0;\n        hi = hi + Math.imul(ah2, bh4) | 0;\n        lo = lo + Math.imul(al1, bl5) | 0;\n        mid = mid + Math.imul(al1, bh5) | 0;\n        mid = mid + Math.imul(ah1, bl5) | 0;\n        hi = hi + Math.imul(ah1, bh5) | 0;\n        lo = lo + Math.imul(al0, bl6) | 0;\n        mid = mid + Math.imul(al0, bh6) | 0;\n        mid = mid + Math.imul(ah0, bl6) | 0;\n        hi = hi + Math.imul(ah0, bh6) | 0;\n        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;\n        w6 &= 0x3ffffff;\n        /* k = 7 */ lo = Math.imul(al7, bl0);\n        mid = Math.imul(al7, bh0);\n        mid = mid + Math.imul(ah7, bl0) | 0;\n        hi = Math.imul(ah7, bh0);\n        lo = lo + Math.imul(al6, bl1) | 0;\n        mid = mid + Math.imul(al6, bh1) | 0;\n        mid = mid + Math.imul(ah6, bl1) | 0;\n        hi = hi + Math.imul(ah6, bh1) | 0;\n        lo = lo + Math.imul(al5, bl2) | 0;\n        mid = mid + Math.imul(al5, bh2) | 0;\n        mid = mid + Math.imul(ah5, bl2) | 0;\n        hi = hi + Math.imul(ah5, bh2) | 0;\n        lo = lo + Math.imul(al4, bl3) | 0;\n        mid = mid + Math.imul(al4, bh3) | 0;\n        mid = mid + Math.imul(ah4, bl3) | 0;\n        hi = hi + Math.imul(ah4, bh3) | 0;\n        lo = lo + Math.imul(al3, bl4) | 0;\n        mid = mid + Math.imul(al3, bh4) | 0;\n        mid = mid + Math.imul(ah3, bl4) | 0;\n        hi = hi + Math.imul(ah3, bh4) | 0;\n        lo = lo + Math.imul(al2, bl5) | 0;\n        mid = mid + Math.imul(al2, bh5) | 0;\n        mid = mid + Math.imul(ah2, bl5) | 0;\n        hi = hi + Math.imul(ah2, bh5) | 0;\n        lo = lo + Math.imul(al1, bl6) | 0;\n        mid = mid + Math.imul(al1, bh6) | 0;\n        mid = mid + Math.imul(ah1, bl6) | 0;\n        hi = hi + Math.imul(ah1, bh6) | 0;\n        lo = lo + Math.imul(al0, bl7) | 0;\n        mid = mid + Math.imul(al0, bh7) | 0;\n        mid = mid + Math.imul(ah0, bl7) | 0;\n        hi = hi + Math.imul(ah0, bh7) | 0;\n        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;\n        w7 &= 0x3ffffff;\n        /* k = 8 */ lo = Math.imul(al8, bl0);\n        mid = Math.imul(al8, bh0);\n        mid = mid + Math.imul(ah8, bl0) | 0;\n        hi = Math.imul(ah8, bh0);\n        lo = lo + Math.imul(al7, bl1) | 0;\n        mid = mid + Math.imul(al7, bh1) | 0;\n        mid = mid + Math.imul(ah7, bl1) | 0;\n        hi = hi + Math.imul(ah7, bh1) | 0;\n        lo = lo + Math.imul(al6, bl2) | 0;\n        mid = mid + Math.imul(al6, bh2) | 0;\n        mid = mid + Math.imul(ah6, bl2) | 0;\n        hi = hi + Math.imul(ah6, bh2) | 0;\n        lo = lo + Math.imul(al5, bl3) | 0;\n        mid = mid + Math.imul(al5, bh3) | 0;\n        mid = mid + Math.imul(ah5, bl3) | 0;\n        hi = hi + Math.imul(ah5, bh3) | 0;\n        lo = lo + Math.imul(al4, bl4) | 0;\n        mid = mid + Math.imul(al4, bh4) | 0;\n        mid = mid + Math.imul(ah4, bl4) | 0;\n        hi = hi + Math.imul(ah4, bh4) | 0;\n        lo = lo + Math.imul(al3, bl5) | 0;\n        mid = mid + Math.imul(al3, bh5) | 0;\n        mid = mid + Math.imul(ah3, bl5) | 0;\n        hi = hi + Math.imul(ah3, bh5) | 0;\n        lo = lo + Math.imul(al2, bl6) | 0;\n        mid = mid + Math.imul(al2, bh6) | 0;\n        mid = mid + Math.imul(ah2, bl6) | 0;\n        hi = hi + Math.imul(ah2, bh6) | 0;\n        lo = lo + Math.imul(al1, bl7) | 0;\n        mid = mid + Math.imul(al1, bh7) | 0;\n        mid = mid + Math.imul(ah1, bl7) | 0;\n        hi = hi + Math.imul(ah1, bh7) | 0;\n        lo = lo + Math.imul(al0, bl8) | 0;\n        mid = mid + Math.imul(al0, bh8) | 0;\n        mid = mid + Math.imul(ah0, bl8) | 0;\n        hi = hi + Math.imul(ah0, bh8) | 0;\n        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;\n        w8 &= 0x3ffffff;\n        /* k = 9 */ lo = Math.imul(al9, bl0);\n        mid = Math.imul(al9, bh0);\n        mid = mid + Math.imul(ah9, bl0) | 0;\n        hi = Math.imul(ah9, bh0);\n        lo = lo + Math.imul(al8, bl1) | 0;\n        mid = mid + Math.imul(al8, bh1) | 0;\n        mid = mid + Math.imul(ah8, bl1) | 0;\n        hi = hi + Math.imul(ah8, bh1) | 0;\n        lo = lo + Math.imul(al7, bl2) | 0;\n        mid = mid + Math.imul(al7, bh2) | 0;\n        mid = mid + Math.imul(ah7, bl2) | 0;\n        hi = hi + Math.imul(ah7, bh2) | 0;\n        lo = lo + Math.imul(al6, bl3) | 0;\n        mid = mid + Math.imul(al6, bh3) | 0;\n        mid = mid + Math.imul(ah6, bl3) | 0;\n        hi = hi + Math.imul(ah6, bh3) | 0;\n        lo = lo + Math.imul(al5, bl4) | 0;\n        mid = mid + Math.imul(al5, bh4) | 0;\n        mid = mid + Math.imul(ah5, bl4) | 0;\n        hi = hi + Math.imul(ah5, bh4) | 0;\n        lo = lo + Math.imul(al4, bl5) | 0;\n        mid = mid + Math.imul(al4, bh5) | 0;\n        mid = mid + Math.imul(ah4, bl5) | 0;\n        hi = hi + Math.imul(ah4, bh5) | 0;\n        lo = lo + Math.imul(al3, bl6) | 0;\n        mid = mid + Math.imul(al3, bh6) | 0;\n        mid = mid + Math.imul(ah3, bl6) | 0;\n        hi = hi + Math.imul(ah3, bh6) | 0;\n        lo = lo + Math.imul(al2, bl7) | 0;\n        mid = mid + Math.imul(al2, bh7) | 0;\n        mid = mid + Math.imul(ah2, bl7) | 0;\n        hi = hi + Math.imul(ah2, bh7) | 0;\n        lo = lo + Math.imul(al1, bl8) | 0;\n        mid = mid + Math.imul(al1, bh8) | 0;\n        mid = mid + Math.imul(ah1, bl8) | 0;\n        hi = hi + Math.imul(ah1, bh8) | 0;\n        lo = lo + Math.imul(al0, bl9) | 0;\n        mid = mid + Math.imul(al0, bh9) | 0;\n        mid = mid + Math.imul(ah0, bl9) | 0;\n        hi = hi + Math.imul(ah0, bh9) | 0;\n        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;\n        w9 &= 0x3ffffff;\n        /* k = 10 */ lo = Math.imul(al9, bl1);\n        mid = Math.imul(al9, bh1);\n        mid = mid + Math.imul(ah9, bl1) | 0;\n        hi = Math.imul(ah9, bh1);\n        lo = lo + Math.imul(al8, bl2) | 0;\n        mid = mid + Math.imul(al8, bh2) | 0;\n        mid = mid + Math.imul(ah8, bl2) | 0;\n        hi = hi + Math.imul(ah8, bh2) | 0;\n        lo = lo + Math.imul(al7, bl3) | 0;\n        mid = mid + Math.imul(al7, bh3) | 0;\n        mid = mid + Math.imul(ah7, bl3) | 0;\n        hi = hi + Math.imul(ah7, bh3) | 0;\n        lo = lo + Math.imul(al6, bl4) | 0;\n        mid = mid + Math.imul(al6, bh4) | 0;\n        mid = mid + Math.imul(ah6, bl4) | 0;\n        hi = hi + Math.imul(ah6, bh4) | 0;\n        lo = lo + Math.imul(al5, bl5) | 0;\n        mid = mid + Math.imul(al5, bh5) | 0;\n        mid = mid + Math.imul(ah5, bl5) | 0;\n        hi = hi + Math.imul(ah5, bh5) | 0;\n        lo = lo + Math.imul(al4, bl6) | 0;\n        mid = mid + Math.imul(al4, bh6) | 0;\n        mid = mid + Math.imul(ah4, bl6) | 0;\n        hi = hi + Math.imul(ah4, bh6) | 0;\n        lo = lo + Math.imul(al3, bl7) | 0;\n        mid = mid + Math.imul(al3, bh7) | 0;\n        mid = mid + Math.imul(ah3, bl7) | 0;\n        hi = hi + Math.imul(ah3, bh7) | 0;\n        lo = lo + Math.imul(al2, bl8) | 0;\n        mid = mid + Math.imul(al2, bh8) | 0;\n        mid = mid + Math.imul(ah2, bl8) | 0;\n        hi = hi + Math.imul(ah2, bh8) | 0;\n        lo = lo + Math.imul(al1, bl9) | 0;\n        mid = mid + Math.imul(al1, bh9) | 0;\n        mid = mid + Math.imul(ah1, bl9) | 0;\n        hi = hi + Math.imul(ah1, bh9) | 0;\n        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;\n        w10 &= 0x3ffffff;\n        /* k = 11 */ lo = Math.imul(al9, bl2);\n        mid = Math.imul(al9, bh2);\n        mid = mid + Math.imul(ah9, bl2) | 0;\n        hi = Math.imul(ah9, bh2);\n        lo = lo + Math.imul(al8, bl3) | 0;\n        mid = mid + Math.imul(al8, bh3) | 0;\n        mid = mid + Math.imul(ah8, bl3) | 0;\n        hi = hi + Math.imul(ah8, bh3) | 0;\n        lo = lo + Math.imul(al7, bl4) | 0;\n        mid = mid + Math.imul(al7, bh4) | 0;\n        mid = mid + Math.imul(ah7, bl4) | 0;\n        hi = hi + Math.imul(ah7, bh4) | 0;\n        lo = lo + Math.imul(al6, bl5) | 0;\n        mid = mid + Math.imul(al6, bh5) | 0;\n        mid = mid + Math.imul(ah6, bl5) | 0;\n        hi = hi + Math.imul(ah6, bh5) | 0;\n        lo = lo + Math.imul(al5, bl6) | 0;\n        mid = mid + Math.imul(al5, bh6) | 0;\n        mid = mid + Math.imul(ah5, bl6) | 0;\n        hi = hi + Math.imul(ah5, bh6) | 0;\n        lo = lo + Math.imul(al4, bl7) | 0;\n        mid = mid + Math.imul(al4, bh7) | 0;\n        mid = mid + Math.imul(ah4, bl7) | 0;\n        hi = hi + Math.imul(ah4, bh7) | 0;\n        lo = lo + Math.imul(al3, bl8) | 0;\n        mid = mid + Math.imul(al3, bh8) | 0;\n        mid = mid + Math.imul(ah3, bl8) | 0;\n        hi = hi + Math.imul(ah3, bh8) | 0;\n        lo = lo + Math.imul(al2, bl9) | 0;\n        mid = mid + Math.imul(al2, bh9) | 0;\n        mid = mid + Math.imul(ah2, bl9) | 0;\n        hi = hi + Math.imul(ah2, bh9) | 0;\n        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;\n        w11 &= 0x3ffffff;\n        /* k = 12 */ lo = Math.imul(al9, bl3);\n        mid = Math.imul(al9, bh3);\n        mid = mid + Math.imul(ah9, bl3) | 0;\n        hi = Math.imul(ah9, bh3);\n        lo = lo + Math.imul(al8, bl4) | 0;\n        mid = mid + Math.imul(al8, bh4) | 0;\n        mid = mid + Math.imul(ah8, bl4) | 0;\n        hi = hi + Math.imul(ah8, bh4) | 0;\n        lo = lo + Math.imul(al7, bl5) | 0;\n        mid = mid + Math.imul(al7, bh5) | 0;\n        mid = mid + Math.imul(ah7, bl5) | 0;\n        hi = hi + Math.imul(ah7, bh5) | 0;\n        lo = lo + Math.imul(al6, bl6) | 0;\n        mid = mid + Math.imul(al6, bh6) | 0;\n        mid = mid + Math.imul(ah6, bl6) | 0;\n        hi = hi + Math.imul(ah6, bh6) | 0;\n        lo = lo + Math.imul(al5, bl7) | 0;\n        mid = mid + Math.imul(al5, bh7) | 0;\n        mid = mid + Math.imul(ah5, bl7) | 0;\n        hi = hi + Math.imul(ah5, bh7) | 0;\n        lo = lo + Math.imul(al4, bl8) | 0;\n        mid = mid + Math.imul(al4, bh8) | 0;\n        mid = mid + Math.imul(ah4, bl8) | 0;\n        hi = hi + Math.imul(ah4, bh8) | 0;\n        lo = lo + Math.imul(al3, bl9) | 0;\n        mid = mid + Math.imul(al3, bh9) | 0;\n        mid = mid + Math.imul(ah3, bl9) | 0;\n        hi = hi + Math.imul(ah3, bh9) | 0;\n        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;\n        w12 &= 0x3ffffff;\n        /* k = 13 */ lo = Math.imul(al9, bl4);\n        mid = Math.imul(al9, bh4);\n        mid = mid + Math.imul(ah9, bl4) | 0;\n        hi = Math.imul(ah9, bh4);\n        lo = lo + Math.imul(al8, bl5) | 0;\n        mid = mid + Math.imul(al8, bh5) | 0;\n        mid = mid + Math.imul(ah8, bl5) | 0;\n        hi = hi + Math.imul(ah8, bh5) | 0;\n        lo = lo + Math.imul(al7, bl6) | 0;\n        mid = mid + Math.imul(al7, bh6) | 0;\n        mid = mid + Math.imul(ah7, bl6) | 0;\n        hi = hi + Math.imul(ah7, bh6) | 0;\n        lo = lo + Math.imul(al6, bl7) | 0;\n        mid = mid + Math.imul(al6, bh7) | 0;\n        mid = mid + Math.imul(ah6, bl7) | 0;\n        hi = hi + Math.imul(ah6, bh7) | 0;\n        lo = lo + Math.imul(al5, bl8) | 0;\n        mid = mid + Math.imul(al5, bh8) | 0;\n        mid = mid + Math.imul(ah5, bl8) | 0;\n        hi = hi + Math.imul(ah5, bh8) | 0;\n        lo = lo + Math.imul(al4, bl9) | 0;\n        mid = mid + Math.imul(al4, bh9) | 0;\n        mid = mid + Math.imul(ah4, bl9) | 0;\n        hi = hi + Math.imul(ah4, bh9) | 0;\n        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;\n        w13 &= 0x3ffffff;\n        /* k = 14 */ lo = Math.imul(al9, bl5);\n        mid = Math.imul(al9, bh5);\n        mid = mid + Math.imul(ah9, bl5) | 0;\n        hi = Math.imul(ah9, bh5);\n        lo = lo + Math.imul(al8, bl6) | 0;\n        mid = mid + Math.imul(al8, bh6) | 0;\n        mid = mid + Math.imul(ah8, bl6) | 0;\n        hi = hi + Math.imul(ah8, bh6) | 0;\n        lo = lo + Math.imul(al7, bl7) | 0;\n        mid = mid + Math.imul(al7, bh7) | 0;\n        mid = mid + Math.imul(ah7, bl7) | 0;\n        hi = hi + Math.imul(ah7, bh7) | 0;\n        lo = lo + Math.imul(al6, bl8) | 0;\n        mid = mid + Math.imul(al6, bh8) | 0;\n        mid = mid + Math.imul(ah6, bl8) | 0;\n        hi = hi + Math.imul(ah6, bh8) | 0;\n        lo = lo + Math.imul(al5, bl9) | 0;\n        mid = mid + Math.imul(al5, bh9) | 0;\n        mid = mid + Math.imul(ah5, bl9) | 0;\n        hi = hi + Math.imul(ah5, bh9) | 0;\n        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;\n        w14 &= 0x3ffffff;\n        /* k = 15 */ lo = Math.imul(al9, bl6);\n        mid = Math.imul(al9, bh6);\n        mid = mid + Math.imul(ah9, bl6) | 0;\n        hi = Math.imul(ah9, bh6);\n        lo = lo + Math.imul(al8, bl7) | 0;\n        mid = mid + Math.imul(al8, bh7) | 0;\n        mid = mid + Math.imul(ah8, bl7) | 0;\n        hi = hi + Math.imul(ah8, bh7) | 0;\n        lo = lo + Math.imul(al7, bl8) | 0;\n        mid = mid + Math.imul(al7, bh8) | 0;\n        mid = mid + Math.imul(ah7, bl8) | 0;\n        hi = hi + Math.imul(ah7, bh8) | 0;\n        lo = lo + Math.imul(al6, bl9) | 0;\n        mid = mid + Math.imul(al6, bh9) | 0;\n        mid = mid + Math.imul(ah6, bl9) | 0;\n        hi = hi + Math.imul(ah6, bh9) | 0;\n        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;\n        w15 &= 0x3ffffff;\n        /* k = 16 */ lo = Math.imul(al9, bl7);\n        mid = Math.imul(al9, bh7);\n        mid = mid + Math.imul(ah9, bl7) | 0;\n        hi = Math.imul(ah9, bh7);\n        lo = lo + Math.imul(al8, bl8) | 0;\n        mid = mid + Math.imul(al8, bh8) | 0;\n        mid = mid + Math.imul(ah8, bl8) | 0;\n        hi = hi + Math.imul(ah8, bh8) | 0;\n        lo = lo + Math.imul(al7, bl9) | 0;\n        mid = mid + Math.imul(al7, bh9) | 0;\n        mid = mid + Math.imul(ah7, bl9) | 0;\n        hi = hi + Math.imul(ah7, bh9) | 0;\n        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;\n        w16 &= 0x3ffffff;\n        /* k = 17 */ lo = Math.imul(al9, bl8);\n        mid = Math.imul(al9, bh8);\n        mid = mid + Math.imul(ah9, bl8) | 0;\n        hi = Math.imul(ah9, bh8);\n        lo = lo + Math.imul(al8, bl9) | 0;\n        mid = mid + Math.imul(al8, bh9) | 0;\n        mid = mid + Math.imul(ah8, bl9) | 0;\n        hi = hi + Math.imul(ah8, bh9) | 0;\n        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;\n        w17 &= 0x3ffffff;\n        /* k = 18 */ lo = Math.imul(al9, bl9);\n        mid = Math.imul(al9, bh9);\n        mid = mid + Math.imul(ah9, bl9) | 0;\n        hi = Math.imul(ah9, bh9);\n        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;\n        w18 &= 0x3ffffff;\n        o[0] = w0;\n        o[1] = w1;\n        o[2] = w2;\n        o[3] = w3;\n        o[4] = w4;\n        o[5] = w5;\n        o[6] = w6;\n        o[7] = w7;\n        o[8] = w8;\n        o[9] = w9;\n        o[10] = w10;\n        o[11] = w11;\n        o[12] = w12;\n        o[13] = w13;\n        o[14] = w14;\n        o[15] = w15;\n        o[16] = w16;\n        o[17] = w17;\n        o[18] = w18;\n        if (c !== 0) {\n            o[19] = c;\n            out.length++;\n        }\n        return out;\n    };\n    // Polyfill comb\n    if (!Math.imul) {\n        comb10MulTo = smallMulTo;\n    }\n    function bigMulTo(self, num, out) {\n        out.negative = num.negative ^ self.negative;\n        out.length = self.length + num.length;\n        var carry = 0;\n        var hncarry = 0;\n        for(var k = 0; k < out.length - 1; k++){\n            // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n            // note that ncarry could be >= 0x3ffffff\n            var ncarry = hncarry;\n            hncarry = 0;\n            var rword = carry & 0x3ffffff;\n            var maxJ = Math.min(k, num.length - 1);\n            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){\n                var i = k - j;\n                var a = self.words[i] | 0;\n                var b = num.words[j] | 0;\n                var r = a * b;\n                var lo = r & 0x3ffffff;\n                ncarry = ncarry + (r / 0x4000000 | 0) | 0;\n                lo = lo + rword | 0;\n                rword = lo & 0x3ffffff;\n                ncarry = ncarry + (lo >>> 26) | 0;\n                hncarry += ncarry >>> 26;\n                ncarry &= 0x3ffffff;\n            }\n            out.words[k] = rword;\n            carry = ncarry;\n            ncarry = hncarry;\n        }\n        if (carry !== 0) {\n            out.words[k] = carry;\n        } else {\n            out.length--;\n        }\n        return out._strip();\n    }\n    function jumboMulTo(self, num, out) {\n        // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n        // var fftm = new FFTM();\n        // return fftm.mulp(self, num, out);\n        return bigMulTo(self, num, out);\n    }\n    BN.prototype.mulTo = function mulTo(num, out) {\n        var res;\n        var len = this.length + num.length;\n        if (this.length === 10 && num.length === 10) {\n            res = comb10MulTo(this, num, out);\n        } else if (len < 63) {\n            res = smallMulTo(this, num, out);\n        } else if (len < 1024) {\n            res = bigMulTo(this, num, out);\n        } else {\n            res = jumboMulTo(this, num, out);\n        }\n        return res;\n    };\n    // Cooley-Tukey algorithm for FFT\n    // slightly revisited to rely on looping instead of recursion\n    function FFTM(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    FFTM.prototype.makeRBT = function makeRBT(N) {\n        var t = new Array(N);\n        var l = BN.prototype._countBits(N) - 1;\n        for(var i = 0; i < N; i++){\n            t[i] = this.revBin(i, l, N);\n        }\n        return t;\n    };\n    // Returns binary-reversed representation of `x`\n    FFTM.prototype.revBin = function revBin(x, l, N) {\n        if (x === 0 || x === N - 1) return x;\n        var rb = 0;\n        for(var i = 0; i < l; i++){\n            rb |= (x & 1) << l - i - 1;\n            x >>= 1;\n        }\n        return rb;\n    };\n    // Performs \"tweedling\" phase, therefore 'emulating'\n    // behaviour of the recursive algorithm\n    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {\n        for(var i = 0; i < N; i++){\n            rtws[i] = rws[rbt[i]];\n            itws[i] = iws[rbt[i]];\n        }\n    };\n    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {\n        this.permute(rbt, rws, iws, rtws, itws, N);\n        for(var s = 1; s < N; s <<= 1){\n            var l = s << 1;\n            var rtwdf = Math.cos(2 * Math.PI / l);\n            var itwdf = Math.sin(2 * Math.PI / l);\n            for(var p = 0; p < N; p += l){\n                var rtwdf_ = rtwdf;\n                var itwdf_ = itwdf;\n                for(var j = 0; j < s; j++){\n                    var re = rtws[p + j];\n                    var ie = itws[p + j];\n                    var ro = rtws[p + j + s];\n                    var io = itws[p + j + s];\n                    var rx = rtwdf_ * ro - itwdf_ * io;\n                    io = rtwdf_ * io + itwdf_ * ro;\n                    ro = rx;\n                    rtws[p + j] = re + ro;\n                    itws[p + j] = ie + io;\n                    rtws[p + j + s] = re - ro;\n                    itws[p + j + s] = ie - io;\n                    /* jshint maxdepth : false */ if (j !== l) {\n                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n                        rtwdf_ = rx;\n                    }\n                }\n            }\n        }\n    };\n    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {\n        var N = Math.max(m, n) | 1;\n        var odd = N & 1;\n        var i = 0;\n        for(N = N / 2 | 0; N; N = N >>> 1){\n            i++;\n        }\n        return 1 << i + 1 + odd;\n    };\n    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {\n        if (N <= 1) return;\n        for(var i = 0; i < N / 2; i++){\n            var t = rws[i];\n            rws[i] = rws[N - i - 1];\n            rws[N - i - 1] = t;\n            t = iws[i];\n            iws[i] = -iws[N - i - 1];\n            iws[N - i - 1] = -t;\n        }\n    };\n    FFTM.prototype.normalize13b = function normalize13b(ws, N) {\n        var carry = 0;\n        for(var i = 0; i < N / 2; i++){\n            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;\n            ws[i] = w & 0x3ffffff;\n            if (w < 0x4000000) {\n                carry = 0;\n            } else {\n                carry = w / 0x4000000 | 0;\n            }\n        }\n        return ws;\n    };\n    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {\n        var carry = 0;\n        for(var i = 0; i < len; i++){\n            carry = carry + (ws[i] | 0);\n            rws[2 * i] = carry & 0x1fff;\n            carry = carry >>> 13;\n            rws[2 * i + 1] = carry & 0x1fff;\n            carry = carry >>> 13;\n        }\n        // Pad with zeroes\n        for(i = 2 * len; i < N; ++i){\n            rws[i] = 0;\n        }\n        assert(carry === 0);\n        assert((carry & ~0x1fff) === 0);\n    };\n    FFTM.prototype.stub = function stub(N) {\n        var ph = new Array(N);\n        for(var i = 0; i < N; i++){\n            ph[i] = 0;\n        }\n        return ph;\n    };\n    FFTM.prototype.mulp = function mulp(x, y, out) {\n        var N = 2 * this.guessLen13b(x.length, y.length);\n        var rbt = this.makeRBT(N);\n        var _ = this.stub(N);\n        var rws = new Array(N);\n        var rwst = new Array(N);\n        var iwst = new Array(N);\n        var nrws = new Array(N);\n        var nrwst = new Array(N);\n        var niwst = new Array(N);\n        var rmws = out.words;\n        rmws.length = N;\n        this.convert13b(x.words, x.length, rws, N);\n        this.convert13b(y.words, y.length, nrws, N);\n        this.transform(rws, _, rwst, iwst, N, rbt);\n        this.transform(nrws, _, nrwst, niwst, N, rbt);\n        for(var i = 0; i < N; i++){\n            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n            rwst[i] = rx;\n        }\n        this.conjugate(rwst, iwst, N);\n        this.transform(rwst, iwst, rmws, _, N, rbt);\n        this.conjugate(rmws, _, N);\n        this.normalize13b(rmws, N);\n        out.negative = x.negative ^ y.negative;\n        out.length = x.length + y.length;\n        return out._strip();\n    };\n    // Multiply `this` by `num`\n    BN.prototype.mul = function mul(num) {\n        var out = new BN(null);\n        out.words = new Array(this.length + num.length);\n        return this.mulTo(num, out);\n    };\n    // Multiply employing FFT\n    BN.prototype.mulf = function mulf(num) {\n        var out = new BN(null);\n        out.words = new Array(this.length + num.length);\n        return jumboMulTo(this, num, out);\n    };\n    // In-place Multiplication\n    BN.prototype.imul = function imul(num) {\n        return this.clone().mulTo(num, this);\n    };\n    BN.prototype.imuln = function imuln(num) {\n        var isNegNum = num < 0;\n        if (isNegNum) num = -num;\n        assert(typeof num === \"number\");\n        assert(num < 0x4000000);\n        // Carry\n        var carry = 0;\n        for(var i = 0; i < this.length; i++){\n            var w = (this.words[i] | 0) * num;\n            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n            carry >>= 26;\n            carry += w / 0x4000000 | 0;\n            // NOTE: lo is 27bit maximum\n            carry += lo >>> 26;\n            this.words[i] = lo & 0x3ffffff;\n        }\n        if (carry !== 0) {\n            this.words[i] = carry;\n            this.length++;\n        }\n        return isNegNum ? this.ineg() : this;\n    };\n    BN.prototype.muln = function muln(num) {\n        return this.clone().imuln(num);\n    };\n    // `this` * `this`\n    BN.prototype.sqr = function sqr() {\n        return this.mul(this);\n    };\n    // `this` * `this` in-place\n    BN.prototype.isqr = function isqr() {\n        return this.imul(this.clone());\n    };\n    // Math.pow(`this`, `num`)\n    BN.prototype.pow = function pow(num) {\n        var w = toBitArray(num);\n        if (w.length === 0) return new BN(1);\n        // Skip leading zeroes\n        var res = this;\n        for(var i = 0; i < w.length; i++, res = res.sqr()){\n            if (w[i] !== 0) break;\n        }\n        if (++i < w.length) {\n            for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){\n                if (w[i] === 0) continue;\n                res = res.mul(q);\n            }\n        }\n        return res;\n    };\n    // Shift-left in-place\n    BN.prototype.iushln = function iushln(bits) {\n        assert(typeof bits === \"number\" && bits >= 0);\n        var r = bits % 26;\n        var s = (bits - r) / 26;\n        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;\n        var i;\n        if (r !== 0) {\n            var carry = 0;\n            for(i = 0; i < this.length; i++){\n                var newCarry = this.words[i] & carryMask;\n                var c = (this.words[i] | 0) - newCarry << r;\n                this.words[i] = c | carry;\n                carry = newCarry >>> 26 - r;\n            }\n            if (carry) {\n                this.words[i] = carry;\n                this.length++;\n            }\n        }\n        if (s !== 0) {\n            for(i = this.length - 1; i >= 0; i--){\n                this.words[i + s] = this.words[i];\n            }\n            for(i = 0; i < s; i++){\n                this.words[i] = 0;\n            }\n            this.length += s;\n        }\n        return this._strip();\n    };\n    BN.prototype.ishln = function ishln(bits) {\n        // TODO(indutny): implement me\n        assert(this.negative === 0);\n        return this.iushln(bits);\n    };\n    // Shift-right in-place\n    // NOTE: `hint` is a lowest bit before trailing zeroes\n    // NOTE: if `extended` is present - it will be filled with destroyed bits\n    BN.prototype.iushrn = function iushrn(bits, hint, extended) {\n        assert(typeof bits === \"number\" && bits >= 0);\n        var h;\n        if (hint) {\n            h = (hint - hint % 26) / 26;\n        } else {\n            h = 0;\n        }\n        var r = bits % 26;\n        var s = Math.min((bits - r) / 26, this.length);\n        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;\n        var maskedWords = extended;\n        h -= s;\n        h = Math.max(0, h);\n        // Extended mode, copy masked part\n        if (maskedWords) {\n            for(var i = 0; i < s; i++){\n                maskedWords.words[i] = this.words[i];\n            }\n            maskedWords.length = s;\n        }\n        if (s === 0) {\n        // No-op, we should not move anything at all\n        } else if (this.length > s) {\n            this.length -= s;\n            for(i = 0; i < this.length; i++){\n                this.words[i] = this.words[i + s];\n            }\n        } else {\n            this.words[0] = 0;\n            this.length = 1;\n        }\n        var carry = 0;\n        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){\n            var word = this.words[i] | 0;\n            this.words[i] = carry << 26 - r | word >>> r;\n            carry = word & mask;\n        }\n        // Push carried bits as a mask\n        if (maskedWords && carry !== 0) {\n            maskedWords.words[maskedWords.length++] = carry;\n        }\n        if (this.length === 0) {\n            this.words[0] = 0;\n            this.length = 1;\n        }\n        return this._strip();\n    };\n    BN.prototype.ishrn = function ishrn(bits, hint, extended) {\n        // TODO(indutny): implement me\n        assert(this.negative === 0);\n        return this.iushrn(bits, hint, extended);\n    };\n    // Shift-left\n    BN.prototype.shln = function shln(bits) {\n        return this.clone().ishln(bits);\n    };\n    BN.prototype.ushln = function ushln(bits) {\n        return this.clone().iushln(bits);\n    };\n    // Shift-right\n    BN.prototype.shrn = function shrn(bits) {\n        return this.clone().ishrn(bits);\n    };\n    BN.prototype.ushrn = function ushrn(bits) {\n        return this.clone().iushrn(bits);\n    };\n    // Test if n bit is set\n    BN.prototype.testn = function testn(bit) {\n        assert(typeof bit === \"number\" && bit >= 0);\n        var r = bit % 26;\n        var s = (bit - r) / 26;\n        var q = 1 << r;\n        // Fast case: bit is much higher than all existing words\n        if (this.length <= s) return false;\n        // Check bit and return\n        var w = this.words[s];\n        return !!(w & q);\n    };\n    // Return only lowers bits of number (in-place)\n    BN.prototype.imaskn = function imaskn(bits) {\n        assert(typeof bits === \"number\" && bits >= 0);\n        var r = bits % 26;\n        var s = (bits - r) / 26;\n        assert(this.negative === 0, \"imaskn works only with positive numbers\");\n        if (this.length <= s) {\n            return this;\n        }\n        if (r !== 0) {\n            s++;\n        }\n        this.length = Math.min(s, this.length);\n        if (r !== 0) {\n            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;\n            this.words[this.length - 1] &= mask;\n        }\n        return this._strip();\n    };\n    // Return only lowers bits of number\n    BN.prototype.maskn = function maskn(bits) {\n        return this.clone().imaskn(bits);\n    };\n    // Add plain number `num` to `this`\n    BN.prototype.iaddn = function iaddn(num) {\n        assert(typeof num === \"number\");\n        assert(num < 0x4000000);\n        if (num < 0) return this.isubn(-num);\n        // Possible sign change\n        if (this.negative !== 0) {\n            if (this.length === 1 && (this.words[0] | 0) <= num) {\n                this.words[0] = num - (this.words[0] | 0);\n                this.negative = 0;\n                return this;\n            }\n            this.negative = 0;\n            this.isubn(num);\n            this.negative = 1;\n            return this;\n        }\n        // Add without checks\n        return this._iaddn(num);\n    };\n    BN.prototype._iaddn = function _iaddn(num) {\n        this.words[0] += num;\n        // Carry\n        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){\n            this.words[i] -= 0x4000000;\n            if (i === this.length - 1) {\n                this.words[i + 1] = 1;\n            } else {\n                this.words[i + 1]++;\n            }\n        }\n        this.length = Math.max(this.length, i + 1);\n        return this;\n    };\n    // Subtract plain number `num` from `this`\n    BN.prototype.isubn = function isubn(num) {\n        assert(typeof num === \"number\");\n        assert(num < 0x4000000);\n        if (num < 0) return this.iaddn(-num);\n        if (this.negative !== 0) {\n            this.negative = 0;\n            this.iaddn(num);\n            this.negative = 1;\n            return this;\n        }\n        this.words[0] -= num;\n        if (this.length === 1 && this.words[0] < 0) {\n            this.words[0] = -this.words[0];\n            this.negative = 1;\n        } else {\n            // Carry\n            for(var i = 0; i < this.length && this.words[i] < 0; i++){\n                this.words[i] += 0x4000000;\n                this.words[i + 1] -= 1;\n            }\n        }\n        return this._strip();\n    };\n    BN.prototype.addn = function addn(num) {\n        return this.clone().iaddn(num);\n    };\n    BN.prototype.subn = function subn(num) {\n        return this.clone().isubn(num);\n    };\n    BN.prototype.iabs = function iabs() {\n        this.negative = 0;\n        return this;\n    };\n    BN.prototype.abs = function abs() {\n        return this.clone().iabs();\n    };\n    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {\n        var len = num.length + shift;\n        var i;\n        this._expand(len);\n        var w;\n        var carry = 0;\n        for(i = 0; i < num.length; i++){\n            w = (this.words[i + shift] | 0) + carry;\n            var right = (num.words[i] | 0) * mul;\n            w -= right & 0x3ffffff;\n            carry = (w >> 26) - (right / 0x4000000 | 0);\n            this.words[i + shift] = w & 0x3ffffff;\n        }\n        for(; i < this.length - shift; i++){\n            w = (this.words[i + shift] | 0) + carry;\n            carry = w >> 26;\n            this.words[i + shift] = w & 0x3ffffff;\n        }\n        if (carry === 0) return this._strip();\n        // Subtraction overflow\n        assert(carry === -1);\n        carry = 0;\n        for(i = 0; i < this.length; i++){\n            w = -(this.words[i] | 0) + carry;\n            carry = w >> 26;\n            this.words[i] = w & 0x3ffffff;\n        }\n        this.negative = 1;\n        return this._strip();\n    };\n    BN.prototype._wordDiv = function _wordDiv(num, mode) {\n        var shift = this.length - num.length;\n        var a = this.clone();\n        var b = num;\n        // Normalize\n        var bhi = b.words[b.length - 1] | 0;\n        var bhiBits = this._countBits(bhi);\n        shift = 26 - bhiBits;\n        if (shift !== 0) {\n            b = b.ushln(shift);\n            a.iushln(shift);\n            bhi = b.words[b.length - 1] | 0;\n        }\n        // Initialize quotient\n        var m = a.length - b.length;\n        var q;\n        if (mode !== \"mod\") {\n            q = new BN(null);\n            q.length = m + 1;\n            q.words = new Array(q.length);\n            for(var i = 0; i < q.length; i++){\n                q.words[i] = 0;\n            }\n        }\n        var diff = a.clone()._ishlnsubmul(b, 1, m);\n        if (diff.negative === 0) {\n            a = diff;\n            if (q) {\n                q.words[m] = 1;\n            }\n        }\n        for(var j = m - 1; j >= 0; j--){\n            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);\n            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n            // (0x7ffffff)\n            qj = Math.min(qj / bhi | 0, 0x3ffffff);\n            a._ishlnsubmul(b, qj, j);\n            while(a.negative !== 0){\n                qj--;\n                a.negative = 0;\n                a._ishlnsubmul(b, 1, j);\n                if (!a.isZero()) {\n                    a.negative ^= 1;\n                }\n            }\n            if (q) {\n                q.words[j] = qj;\n            }\n        }\n        if (q) {\n            q._strip();\n        }\n        a._strip();\n        // Denormalize\n        if (mode !== \"div\" && shift !== 0) {\n            a.iushrn(shift);\n        }\n        return {\n            div: q || null,\n            mod: a\n        };\n    };\n    // NOTE: 1) `mode` can be set to `mod` to request mod only,\n    //       to `div` to request div only, or be absent to\n    //       request both div & mod\n    //       2) `positive` is true if unsigned mod is requested\n    BN.prototype.divmod = function divmod(num, mode, positive) {\n        assert(!num.isZero());\n        if (this.isZero()) {\n            return {\n                div: new BN(0),\n                mod: new BN(0)\n            };\n        }\n        var div, mod, res;\n        if (this.negative !== 0 && num.negative === 0) {\n            res = this.neg().divmod(num, mode);\n            if (mode !== \"mod\") {\n                div = res.div.neg();\n            }\n            if (mode !== \"div\") {\n                mod = res.mod.neg();\n                if (positive && mod.negative !== 0) {\n                    mod.iadd(num);\n                }\n            }\n            return {\n                div: div,\n                mod: mod\n            };\n        }\n        if (this.negative === 0 && num.negative !== 0) {\n            res = this.divmod(num.neg(), mode);\n            if (mode !== \"mod\") {\n                div = res.div.neg();\n            }\n            return {\n                div: div,\n                mod: res.mod\n            };\n        }\n        if ((this.negative & num.negative) !== 0) {\n            res = this.neg().divmod(num.neg(), mode);\n            if (mode !== \"div\") {\n                mod = res.mod.neg();\n                if (positive && mod.negative !== 0) {\n                    mod.isub(num);\n                }\n            }\n            return {\n                div: res.div,\n                mod: mod\n            };\n        }\n        // Both numbers are positive at this point\n        // Strip both numbers to approximate shift value\n        if (num.length > this.length || this.cmp(num) < 0) {\n            return {\n                div: new BN(0),\n                mod: this\n            };\n        }\n        // Very short reduction\n        if (num.length === 1) {\n            if (mode === \"div\") {\n                return {\n                    div: this.divn(num.words[0]),\n                    mod: null\n                };\n            }\n            if (mode === \"mod\") {\n                return {\n                    div: null,\n                    mod: new BN(this.modrn(num.words[0]))\n                };\n            }\n            return {\n                div: this.divn(num.words[0]),\n                mod: new BN(this.modrn(num.words[0]))\n            };\n        }\n        return this._wordDiv(num, mode);\n    };\n    // Find `this` / `num`\n    BN.prototype.div = function div(num) {\n        return this.divmod(num, \"div\", false).div;\n    };\n    // Find `this` % `num`\n    BN.prototype.mod = function mod(num) {\n        return this.divmod(num, \"mod\", false).mod;\n    };\n    BN.prototype.umod = function umod(num) {\n        return this.divmod(num, \"mod\", true).mod;\n    };\n    // Find Round(`this` / `num`)\n    BN.prototype.divRound = function divRound(num) {\n        var dm = this.divmod(num);\n        // Fast case - exact division\n        if (dm.mod.isZero()) return dm.div;\n        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n        var half = num.ushrn(1);\n        var r2 = num.andln(1);\n        var cmp = mod.cmp(half);\n        // Round down\n        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n        // Round up\n        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n    };\n    BN.prototype.modrn = function modrn(num) {\n        var isNegNum = num < 0;\n        if (isNegNum) num = -num;\n        assert(num <= 0x3ffffff);\n        var p = (1 << 26) % num;\n        var acc = 0;\n        for(var i = this.length - 1; i >= 0; i--){\n            acc = (p * acc + (this.words[i] | 0)) % num;\n        }\n        return isNegNum ? -acc : acc;\n    };\n    // WARNING: DEPRECATED\n    BN.prototype.modn = function modn(num) {\n        return this.modrn(num);\n    };\n    // In-place division by number\n    BN.prototype.idivn = function idivn(num) {\n        var isNegNum = num < 0;\n        if (isNegNum) num = -num;\n        assert(num <= 0x3ffffff);\n        var carry = 0;\n        for(var i = this.length - 1; i >= 0; i--){\n            var w = (this.words[i] | 0) + carry * 0x4000000;\n            this.words[i] = w / num | 0;\n            carry = w % num;\n        }\n        this._strip();\n        return isNegNum ? this.ineg() : this;\n    };\n    BN.prototype.divn = function divn(num) {\n        return this.clone().idivn(num);\n    };\n    BN.prototype.egcd = function egcd(p) {\n        assert(p.negative === 0);\n        assert(!p.isZero());\n        var x = this;\n        var y = p.clone();\n        if (x.negative !== 0) {\n            x = x.umod(p);\n        } else {\n            x = x.clone();\n        }\n        // A * x + B * y = x\n        var A = new BN(1);\n        var B = new BN(0);\n        // C * x + D * y = y\n        var C = new BN(0);\n        var D = new BN(1);\n        var g = 0;\n        while(x.isEven() && y.isEven()){\n            x.iushrn(1);\n            y.iushrn(1);\n            ++g;\n        }\n        var yp = y.clone();\n        var xp = x.clone();\n        while(!x.isZero()){\n            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n            if (i > 0) {\n                x.iushrn(i);\n                while(i-- > 0){\n                    if (A.isOdd() || B.isOdd()) {\n                        A.iadd(yp);\n                        B.isub(xp);\n                    }\n                    A.iushrn(1);\n                    B.iushrn(1);\n                }\n            }\n            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n            if (j > 0) {\n                y.iushrn(j);\n                while(j-- > 0){\n                    if (C.isOdd() || D.isOdd()) {\n                        C.iadd(yp);\n                        D.isub(xp);\n                    }\n                    C.iushrn(1);\n                    D.iushrn(1);\n                }\n            }\n            if (x.cmp(y) >= 0) {\n                x.isub(y);\n                A.isub(C);\n                B.isub(D);\n            } else {\n                y.isub(x);\n                C.isub(A);\n                D.isub(B);\n            }\n        }\n        return {\n            a: C,\n            b: D,\n            gcd: y.iushln(g)\n        };\n    };\n    // This is reduced incarnation of the binary EEA\n    // above, designated to invert members of the\n    // _prime_ fields F(p) at a maximal speed\n    BN.prototype._invmp = function _invmp(p) {\n        assert(p.negative === 0);\n        assert(!p.isZero());\n        var a = this;\n        var b = p.clone();\n        if (a.negative !== 0) {\n            a = a.umod(p);\n        } else {\n            a = a.clone();\n        }\n        var x1 = new BN(1);\n        var x2 = new BN(0);\n        var delta = b.clone();\n        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){\n            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n            if (i > 0) {\n                a.iushrn(i);\n                while(i-- > 0){\n                    if (x1.isOdd()) {\n                        x1.iadd(delta);\n                    }\n                    x1.iushrn(1);\n                }\n            }\n            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n            if (j > 0) {\n                b.iushrn(j);\n                while(j-- > 0){\n                    if (x2.isOdd()) {\n                        x2.iadd(delta);\n                    }\n                    x2.iushrn(1);\n                }\n            }\n            if (a.cmp(b) >= 0) {\n                a.isub(b);\n                x1.isub(x2);\n            } else {\n                b.isub(a);\n                x2.isub(x1);\n            }\n        }\n        var res;\n        if (a.cmpn(1) === 0) {\n            res = x1;\n        } else {\n            res = x2;\n        }\n        if (res.cmpn(0) < 0) {\n            res.iadd(p);\n        }\n        return res;\n    };\n    BN.prototype.gcd = function gcd(num) {\n        if (this.isZero()) return num.abs();\n        if (num.isZero()) return this.abs();\n        var a = this.clone();\n        var b = num.clone();\n        a.negative = 0;\n        b.negative = 0;\n        // Remove common factor of two\n        for(var shift = 0; a.isEven() && b.isEven(); shift++){\n            a.iushrn(1);\n            b.iushrn(1);\n        }\n        do {\n            while(a.isEven()){\n                a.iushrn(1);\n            }\n            while(b.isEven()){\n                b.iushrn(1);\n            }\n            var r = a.cmp(b);\n            if (r < 0) {\n                // Swap `a` and `b` to make `a` always bigger than `b`\n                var t = a;\n                a = b;\n                b = t;\n            } else if (r === 0 || b.cmpn(1) === 0) {\n                break;\n            }\n            a.isub(b);\n        }while (true);\n        return b.iushln(shift);\n    };\n    // Invert number in the field F(num)\n    BN.prototype.invm = function invm(num) {\n        return this.egcd(num).a.umod(num);\n    };\n    BN.prototype.isEven = function isEven() {\n        return (this.words[0] & 1) === 0;\n    };\n    BN.prototype.isOdd = function isOdd() {\n        return (this.words[0] & 1) === 1;\n    };\n    // And first word and num\n    BN.prototype.andln = function andln(num) {\n        return this.words[0] & num;\n    };\n    // Increment at the bit position in-line\n    BN.prototype.bincn = function bincn(bit) {\n        assert(typeof bit === \"number\");\n        var r = bit % 26;\n        var s = (bit - r) / 26;\n        var q = 1 << r;\n        // Fast case: bit is much higher than all existing words\n        if (this.length <= s) {\n            this._expand(s + 1);\n            this.words[s] |= q;\n            return this;\n        }\n        // Add bit and propagate, if needed\n        var carry = q;\n        for(var i = s; carry !== 0 && i < this.length; i++){\n            var w = this.words[i] | 0;\n            w += carry;\n            carry = w >>> 26;\n            w &= 0x3ffffff;\n            this.words[i] = w;\n        }\n        if (carry !== 0) {\n            this.words[i] = carry;\n            this.length++;\n        }\n        return this;\n    };\n    BN.prototype.isZero = function isZero() {\n        return this.length === 1 && this.words[0] === 0;\n    };\n    BN.prototype.cmpn = function cmpn(num) {\n        var negative = num < 0;\n        if (this.negative !== 0 && !negative) return -1;\n        if (this.negative === 0 && negative) return 1;\n        this._strip();\n        var res;\n        if (this.length > 1) {\n            res = 1;\n        } else {\n            if (negative) {\n                num = -num;\n            }\n            assert(num <= 0x3ffffff, \"Number is too big\");\n            var w = this.words[0] | 0;\n            res = w === num ? 0 : w < num ? -1 : 1;\n        }\n        if (this.negative !== 0) return -res | 0;\n        return res;\n    };\n    // Compare two numbers and return:\n    // 1 - if `this` > `num`\n    // 0 - if `this` == `num`\n    // -1 - if `this` < `num`\n    BN.prototype.cmp = function cmp(num) {\n        if (this.negative !== 0 && num.negative === 0) return -1;\n        if (this.negative === 0 && num.negative !== 0) return 1;\n        var res = this.ucmp(num);\n        if (this.negative !== 0) return -res | 0;\n        return res;\n    };\n    // Unsigned comparison\n    BN.prototype.ucmp = function ucmp(num) {\n        // At this point both numbers have the same sign\n        if (this.length > num.length) return 1;\n        if (this.length < num.length) return -1;\n        var res = 0;\n        for(var i = this.length - 1; i >= 0; i--){\n            var a = this.words[i] | 0;\n            var b = num.words[i] | 0;\n            if (a === b) continue;\n            if (a < b) {\n                res = -1;\n            } else if (a > b) {\n                res = 1;\n            }\n            break;\n        }\n        return res;\n    };\n    BN.prototype.gtn = function gtn(num) {\n        return this.cmpn(num) === 1;\n    };\n    BN.prototype.gt = function gt(num) {\n        return this.cmp(num) === 1;\n    };\n    BN.prototype.gten = function gten(num) {\n        return this.cmpn(num) >= 0;\n    };\n    BN.prototype.gte = function gte(num) {\n        return this.cmp(num) >= 0;\n    };\n    BN.prototype.ltn = function ltn(num) {\n        return this.cmpn(num) === -1;\n    };\n    BN.prototype.lt = function lt(num) {\n        return this.cmp(num) === -1;\n    };\n    BN.prototype.lten = function lten(num) {\n        return this.cmpn(num) <= 0;\n    };\n    BN.prototype.lte = function lte(num) {\n        return this.cmp(num) <= 0;\n    };\n    BN.prototype.eqn = function eqn(num) {\n        return this.cmpn(num) === 0;\n    };\n    BN.prototype.eq = function eq(num) {\n        return this.cmp(num) === 0;\n    };\n    //\n    // A reduce context, could be using montgomery or something better, depending\n    // on the `m` itself.\n    //\n    BN.red = function red(num) {\n        return new Red(num);\n    };\n    BN.prototype.toRed = function toRed(ctx) {\n        assert(!this.red, \"Already a number in reduction context\");\n        assert(this.negative === 0, \"red works only with positives\");\n        return ctx.convertTo(this)._forceRed(ctx);\n    };\n    BN.prototype.fromRed = function fromRed() {\n        assert(this.red, \"fromRed works only with numbers in reduction context\");\n        return this.red.convertFrom(this);\n    };\n    BN.prototype._forceRed = function _forceRed(ctx) {\n        this.red = ctx;\n        return this;\n    };\n    BN.prototype.forceRed = function forceRed(ctx) {\n        assert(!this.red, \"Already a number in reduction context\");\n        return this._forceRed(ctx);\n    };\n    BN.prototype.redAdd = function redAdd(num) {\n        assert(this.red, \"redAdd works only with red numbers\");\n        return this.red.add(this, num);\n    };\n    BN.prototype.redIAdd = function redIAdd(num) {\n        assert(this.red, \"redIAdd works only with red numbers\");\n        return this.red.iadd(this, num);\n    };\n    BN.prototype.redSub = function redSub(num) {\n        assert(this.red, \"redSub works only with red numbers\");\n        return this.red.sub(this, num);\n    };\n    BN.prototype.redISub = function redISub(num) {\n        assert(this.red, \"redISub works only with red numbers\");\n        return this.red.isub(this, num);\n    };\n    BN.prototype.redShl = function redShl(num) {\n        assert(this.red, \"redShl works only with red numbers\");\n        return this.red.shl(this, num);\n    };\n    BN.prototype.redMul = function redMul(num) {\n        assert(this.red, \"redMul works only with red numbers\");\n        this.red._verify2(this, num);\n        return this.red.mul(this, num);\n    };\n    BN.prototype.redIMul = function redIMul(num) {\n        assert(this.red, \"redMul works only with red numbers\");\n        this.red._verify2(this, num);\n        return this.red.imul(this, num);\n    };\n    BN.prototype.redSqr = function redSqr() {\n        assert(this.red, \"redSqr works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.sqr(this);\n    };\n    BN.prototype.redISqr = function redISqr() {\n        assert(this.red, \"redISqr works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.isqr(this);\n    };\n    // Square root over p\n    BN.prototype.redSqrt = function redSqrt() {\n        assert(this.red, \"redSqrt works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.sqrt(this);\n    };\n    BN.prototype.redInvm = function redInvm() {\n        assert(this.red, \"redInvm works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.invm(this);\n    };\n    // Return negative clone of `this` % `red modulo`\n    BN.prototype.redNeg = function redNeg() {\n        assert(this.red, \"redNeg works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.neg(this);\n    };\n    BN.prototype.redPow = function redPow(num) {\n        assert(this.red && !num.red, \"redPow(normalNum)\");\n        this.red._verify1(this);\n        return this.red.pow(this, num);\n    };\n    // Prime numbers with efficient reduction\n    var primes = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n    };\n    // Pseudo-Mersenne prime\n    function MPrime(name, p) {\n        // P = 2 ^ N - K\n        this.name = name;\n        this.p = new BN(p, 16);\n        this.n = this.p.bitLength();\n        this.k = new BN(1).iushln(this.n).isub(this.p);\n        this.tmp = this._tmp();\n    }\n    MPrime.prototype._tmp = function _tmp() {\n        var tmp = new BN(null);\n        tmp.words = new Array(Math.ceil(this.n / 13));\n        return tmp;\n    };\n    MPrime.prototype.ireduce = function ireduce(num) {\n        // Assumes that `num` is less than `P^2`\n        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n        var r = num;\n        var rlen;\n        do {\n            this.split(r, this.tmp);\n            r = this.imulK(r);\n            r = r.iadd(this.tmp);\n            rlen = r.bitLength();\n        }while (rlen > this.n);\n        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n        if (cmp === 0) {\n            r.words[0] = 0;\n            r.length = 1;\n        } else if (cmp > 0) {\n            r.isub(this.p);\n        } else {\n            if (r.strip !== undefined) {\n                // r is a BN v4 instance\n                r.strip();\n            } else {\n                // r is a BN v5 instance\n                r._strip();\n            }\n        }\n        return r;\n    };\n    MPrime.prototype.split = function split(input, out) {\n        input.iushrn(this.n, 0, out);\n    };\n    MPrime.prototype.imulK = function imulK(num) {\n        return num.imul(this.k);\n    };\n    function K256() {\n        MPrime.call(this, \"k256\", \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\");\n    }\n    inherits(K256, MPrime);\n    K256.prototype.split = function split(input, output) {\n        // 256 = 9 * 26 + 22\n        var mask = 0x3fffff;\n        var outLen = Math.min(input.length, 9);\n        for(var i = 0; i < outLen; i++){\n            output.words[i] = input.words[i];\n        }\n        output.length = outLen;\n        if (input.length <= 9) {\n            input.words[0] = 0;\n            input.length = 1;\n            return;\n        }\n        // Shift by 9 limbs\n        var prev = input.words[9];\n        output.words[output.length++] = prev & mask;\n        for(i = 10; i < input.length; i++){\n            var next = input.words[i] | 0;\n            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;\n            prev = next;\n        }\n        prev >>>= 22;\n        input.words[i - 10] = prev;\n        if (prev === 0 && input.length > 10) {\n            input.length -= 10;\n        } else {\n            input.length -= 9;\n        }\n    };\n    K256.prototype.imulK = function imulK(num) {\n        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n        num.words[num.length] = 0;\n        num.words[num.length + 1] = 0;\n        num.length += 2;\n        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n        var lo = 0;\n        for(var i = 0; i < num.length; i++){\n            var w = num.words[i] | 0;\n            lo += w * 0x3d1;\n            num.words[i] = lo & 0x3ffffff;\n            lo = w * 0x40 + (lo / 0x4000000 | 0);\n        }\n        // Fast length reduction\n        if (num.words[num.length - 1] === 0) {\n            num.length--;\n            if (num.words[num.length - 1] === 0) {\n                num.length--;\n            }\n        }\n        return num;\n    };\n    function P224() {\n        MPrime.call(this, \"p224\", \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\");\n    }\n    inherits(P224, MPrime);\n    function P192() {\n        MPrime.call(this, \"p192\", \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\");\n    }\n    inherits(P192, MPrime);\n    function P25519() {\n        // 2 ^ 255 - 19\n        MPrime.call(this, \"25519\", \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\");\n    }\n    inherits(P25519, MPrime);\n    P25519.prototype.imulK = function imulK(num) {\n        // K = 0x13\n        var carry = 0;\n        for(var i = 0; i < num.length; i++){\n            var hi = (num.words[i] | 0) * 0x13 + carry;\n            var lo = hi & 0x3ffffff;\n            hi >>>= 26;\n            num.words[i] = lo;\n            carry = hi;\n        }\n        if (carry !== 0) {\n            num.words[num.length++] = carry;\n        }\n        return num;\n    };\n    // Exported mostly for testing purposes, use plain name instead\n    BN._prime = function prime(name) {\n        // Cached version of prime\n        if (primes[name]) return primes[name];\n        var prime;\n        if (name === \"k256\") {\n            prime = new K256();\n        } else if (name === \"p224\") {\n            prime = new P224();\n        } else if (name === \"p192\") {\n            prime = new P192();\n        } else if (name === \"p25519\") {\n            prime = new P25519();\n        } else {\n            throw new Error(\"Unknown prime \" + name);\n        }\n        primes[name] = prime;\n        return prime;\n    };\n    //\n    // Base reduction engine\n    //\n    function Red(m) {\n        if (typeof m === \"string\") {\n            var prime = BN._prime(m);\n            this.m = prime.p;\n            this.prime = prime;\n        } else {\n            assert(m.gtn(1), \"modulus must be greater than 1\");\n            this.m = m;\n            this.prime = null;\n        }\n    }\n    Red.prototype._verify1 = function _verify1(a) {\n        assert(a.negative === 0, \"red works only with positives\");\n        assert(a.red, \"red works only with red numbers\");\n    };\n    Red.prototype._verify2 = function _verify2(a, b) {\n        assert((a.negative | b.negative) === 0, \"red works only with positives\");\n        assert(a.red && a.red === b.red, \"red works only with red numbers\");\n    };\n    Red.prototype.imod = function imod(a) {\n        if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n        move(a, a.umod(this.m)._forceRed(this));\n        return a;\n    };\n    Red.prototype.neg = function neg(a) {\n        if (a.isZero()) {\n            return a.clone();\n        }\n        return this.m.sub(a)._forceRed(this);\n    };\n    Red.prototype.add = function add(a, b) {\n        this._verify2(a, b);\n        var res = a.add(b);\n        if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n        }\n        return res._forceRed(this);\n    };\n    Red.prototype.iadd = function iadd(a, b) {\n        this._verify2(a, b);\n        var res = a.iadd(b);\n        if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n        }\n        return res;\n    };\n    Red.prototype.sub = function sub(a, b) {\n        this._verify2(a, b);\n        var res = a.sub(b);\n        if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n        }\n        return res._forceRed(this);\n    };\n    Red.prototype.isub = function isub(a, b) {\n        this._verify2(a, b);\n        var res = a.isub(b);\n        if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n        }\n        return res;\n    };\n    Red.prototype.shl = function shl(a, num) {\n        this._verify1(a);\n        return this.imod(a.ushln(num));\n    };\n    Red.prototype.imul = function imul(a, b) {\n        this._verify2(a, b);\n        return this.imod(a.imul(b));\n    };\n    Red.prototype.mul = function mul(a, b) {\n        this._verify2(a, b);\n        return this.imod(a.mul(b));\n    };\n    Red.prototype.isqr = function isqr(a) {\n        return this.imul(a, a.clone());\n    };\n    Red.prototype.sqr = function sqr(a) {\n        return this.mul(a, a);\n    };\n    Red.prototype.sqrt = function sqrt(a) {\n        if (a.isZero()) return a.clone();\n        var mod3 = this.m.andln(3);\n        assert(mod3 % 2 === 1);\n        // Fast case\n        if (mod3 === 3) {\n            var pow = this.m.add(new BN(1)).iushrn(2);\n            return this.pow(a, pow);\n        }\n        // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n        //\n        // Find Q and S, that Q * 2 ^ S = (P - 1)\n        var q = this.m.subn(1);\n        var s = 0;\n        while(!q.isZero() && q.andln(1) === 0){\n            s++;\n            q.iushrn(1);\n        }\n        assert(!q.isZero());\n        var one = new BN(1).toRed(this);\n        var nOne = one.redNeg();\n        // Find quadratic non-residue\n        // NOTE: Max is such because of generalized Riemann hypothesis.\n        var lpow = this.m.subn(1).iushrn(1);\n        var z = this.m.bitLength();\n        z = new BN(2 * z * z).toRed(this);\n        while(this.pow(z, lpow).cmp(nOne) !== 0){\n            z.redIAdd(nOne);\n        }\n        var c = this.pow(z, q);\n        var r = this.pow(a, q.addn(1).iushrn(1));\n        var t = this.pow(a, q);\n        var m = s;\n        while(t.cmp(one) !== 0){\n            var tmp = t;\n            for(var i = 0; tmp.cmp(one) !== 0; i++){\n                tmp = tmp.redSqr();\n            }\n            assert(i < m);\n            var b = this.pow(c, new BN(1).iushln(m - i - 1));\n            r = r.redMul(b);\n            c = b.redSqr();\n            t = t.redMul(c);\n            m = i;\n        }\n        return r;\n    };\n    Red.prototype.invm = function invm(a) {\n        var inv = a._invmp(this.m);\n        if (inv.negative !== 0) {\n            inv.negative = 0;\n            return this.imod(inv).redNeg();\n        } else {\n            return this.imod(inv);\n        }\n    };\n    Red.prototype.pow = function pow(a, num) {\n        if (num.isZero()) return new BN(1).toRed(this);\n        if (num.cmpn(1) === 0) return a.clone();\n        var windowSize = 4;\n        var wnd = new Array(1 << windowSize);\n        wnd[0] = new BN(1).toRed(this);\n        wnd[1] = a;\n        for(var i = 2; i < wnd.length; i++){\n            wnd[i] = this.mul(wnd[i - 1], a);\n        }\n        var res = wnd[0];\n        var current = 0;\n        var currentLen = 0;\n        var start = num.bitLength() % 26;\n        if (start === 0) {\n            start = 26;\n        }\n        for(i = num.length - 1; i >= 0; i--){\n            var word = num.words[i];\n            for(var j = start - 1; j >= 0; j--){\n                var bit = word >> j & 1;\n                if (res !== wnd[0]) {\n                    res = this.sqr(res);\n                }\n                if (bit === 0 && current === 0) {\n                    currentLen = 0;\n                    continue;\n                }\n                current <<= 1;\n                current |= bit;\n                currentLen++;\n                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n                res = this.mul(res, wnd[current]);\n                currentLen = 0;\n                current = 0;\n            }\n            start = 26;\n        }\n        return res;\n    };\n    Red.prototype.convertTo = function convertTo(num) {\n        var r = num.umod(this.m);\n        return r === num ? r.clone() : r;\n    };\n    Red.prototype.convertFrom = function convertFrom(num) {\n        var res = num.clone();\n        res.red = null;\n        return res;\n    };\n    //\n    // Montgomery method engine\n    //\n    BN.mont = function mont(num) {\n        return new Mont(num);\n    };\n    function Mont(m) {\n        Red.call(this, m);\n        this.shift = this.m.bitLength();\n        if (this.shift % 26 !== 0) {\n            this.shift += 26 - this.shift % 26;\n        }\n        this.r = new BN(1).iushln(this.shift);\n        this.r2 = this.imod(this.r.sqr());\n        this.rinv = this.r._invmp(this.m);\n        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n        this.minv = this.minv.umod(this.r);\n        this.minv = this.r.sub(this.minv);\n    }\n    inherits(Mont, Red);\n    Mont.prototype.convertTo = function convertTo(num) {\n        return this.imod(num.ushln(this.shift));\n    };\n    Mont.prototype.convertFrom = function convertFrom(num) {\n        var r = this.imod(num.mul(this.rinv));\n        r.red = null;\n        return r;\n    };\n    Mont.prototype.imul = function imul(a, b) {\n        if (a.isZero() || b.isZero()) {\n            a.words[0] = 0;\n            a.length = 1;\n            return a;\n        }\n        var t = a.imul(b);\n        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        var u = t.isub(c).iushrn(this.shift);\n        var res = u;\n        if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n        } else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n        }\n        return res._forceRed(this);\n    };\n    Mont.prototype.mul = function mul(a, b) {\n        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n        var t = a.mul(b);\n        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        var u = t.isub(c).iushrn(this.shift);\n        var res = u;\n        if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n        } else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n        }\n        return res._forceRed(this);\n    };\n    Mont.prototype.invm = function invm(a) {\n        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n        var res = this.imod(a._invmp(this.m).mul(this.r2));\n        return res._forceRed(this);\n    };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanMiLCJtYXBwaW5ncyI6IjtBQUFDLFVBQVVBLE9BQU0sRUFBRUMsT0FBTztJQUN4QjtJQUVBLFFBQVE7SUFDUixTQUFTQyxPQUFRQyxHQUFHLEVBQUVDLEdBQUc7UUFDdkIsSUFBSSxDQUFDRCxLQUFLLE1BQU0sSUFBSUUsTUFBTUQsT0FBTztJQUNuQztJQUVBLHVFQUF1RTtJQUN2RSxvQkFBb0I7SUFDcEIsU0FBU0UsU0FBVUMsSUFBSSxFQUFFQyxTQUFTO1FBQ2hDRCxLQUFLRSxNQUFNLEdBQUdEO1FBQ2QsSUFBSUUsV0FBVyxZQUFhO1FBQzVCQSxTQUFTQyxTQUFTLEdBQUdILFVBQVVHLFNBQVM7UUFDeENKLEtBQUtJLFNBQVMsR0FBRyxJQUFJRDtRQUNyQkgsS0FBS0ksU0FBUyxDQUFDQyxXQUFXLEdBQUdMO0lBQy9CO0lBRUEsS0FBSztJQUVMLFNBQVNNLEdBQUlDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1FBQy9CLElBQUlILEdBQUdJLElBQUksQ0FBQ0gsU0FBUztZQUNuQixPQUFPQTtRQUNUO1FBRUEsSUFBSSxDQUFDSSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUVkLG9CQUFvQjtRQUNwQixJQUFJLENBQUNDLEdBQUcsR0FBRztRQUVYLElBQUlQLFdBQVcsTUFBTTtZQUNuQixJQUFJQyxTQUFTLFFBQVFBLFNBQVMsTUFBTTtnQkFDbENDLFNBQVNEO2dCQUNUQSxPQUFPO1lBQ1Q7WUFFQSxJQUFJLENBQUNPLEtBQUssQ0FBQ1IsVUFBVSxHQUFHQyxRQUFRLElBQUlDLFVBQVU7UUFDaEQ7SUFDRjtJQUNBLElBQUksT0FBT2hCLFlBQVcsVUFBVTtRQUM5QkEsUUFBT0MsT0FBTyxHQUFHWTtJQUNuQixPQUFPO1FBQ0xaLFFBQVFZLEVBQUUsR0FBR0E7SUFDZjtJQUVBQSxH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QUFJclUsRUFBRW9DLElBQUksQ0FBQ2xHLEdBQUc4UCxNQUFNLENBQUMsSUFBSSxDQUFDcE0sS0FBSztRQUNuQyxJQUFJSixNQUFNNlU7UUFDVixJQUFJQSxFQUFFeFosR0FBRyxDQUFDLElBQUksQ0FBQ3VQLENBQUMsS0FBSyxHQUFHO1lBQ3RCNUssTUFBTTZVLEVBQUVqUyxJQUFJLENBQUMsSUFBSSxDQUFDZ0ksQ0FBQztRQUNyQixPQUFPLElBQUlpSyxFQUFFaEYsSUFBSSxDQUFDLEtBQUssR0FBRztZQUN4QjdQLE1BQU02VSxFQUFFbFMsSUFBSSxDQUFDLElBQUksQ0FBQ2lJLENBQUM7UUFDckI7UUFFQSxPQUFPNUssSUFBSStRLFNBQVMsQ0FBQyxJQUFJO0lBQzNCO0lBRUEyRCxLQUFLNWEsU0FBUyxDQUFDZ1csSUFBSSxHQUFHLFNBQVNBLEtBQU0xTixDQUFDO1FBQ3BDLGlEQUFpRDtRQUNqRCxJQUFJcEMsTUFBTSxJQUFJLENBQUM4VCxJQUFJLENBQUMxUixFQUFFcU4sTUFBTSxDQUFDLElBQUksQ0FBQzdFLENBQUMsRUFBRXpOLEdBQUcsQ0FBQyxJQUFJLENBQUNxUixFQUFFO1FBQ2hELE9BQU94TyxJQUFJK1EsU0FBUyxDQUFDLElBQUk7SUFDM0I7QUFDRixHQUFHLE1BQWtCLElBQWU1WCxRQUFRLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanM/YmVlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIEJ1ZmZlciA9IHdpbmRvdy5CdWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPCBudW1iZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgZW5kaWFuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW251bWJlciAmIDB4M2ZmZmZmZl07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4NEJpdHMgKHN0cmluZywgaW5kZXgpIHtcbiAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAvLyAnMCcgLSAnOSdcbiAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICByZXR1cm4gYyAtIDQ4O1xuICAgIC8vICdBJyAtICdGJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA2NSAmJiBjIDw9IDcwKSB7XG4gICAgICByZXR1cm4gYyAtIDU1O1xuICAgIC8vICdhJyAtICdmJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA5NyAmJiBjIDw9IDEwMikge1xuICAgICAgcmV0dXJuIGMgLSA4NztcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gJyArIHN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXhCeXRlIChzdHJpbmcsIGxvd2VyQm91bmQsIGluZGV4KSB7XG4gICAgdmFyIHIgPSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAtIDEgPj0gbG93ZXJCb3VuZCkge1xuICAgICAgciB8PSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXggLSAxKSA8PCA0O1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQsIGVuZGlhbikge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDI0LWJpdHMgY2h1bmtzXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZUxlbmd0aCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIGIgPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIGIgPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IGM7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYyA+PSAwICYmIGIgPCBtdWwsICdJbnZhbGlkIGNoYXJhY3RlcicpO1xuICAgICAgciArPSBiO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBmdW5jdGlvbiBtb3ZlIChkZXN0LCBzcmMpIHtcbiAgICBkZXN0LndvcmRzID0gc3JjLndvcmRzO1xuICAgIGRlc3QubGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gc3JjLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gc3JjLnJlZDtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uIF9tb3ZlIChkZXN0KSB7XG4gICAgbW92ZShkZXN0LCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLl9zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBDaGVjayBTeW1ib2wuZm9yIGJlY2F1c2Ugbm90IGV2ZXJ5d2hlcmUgd2hlcmUgU3ltYm9sIGRlZmluZWRcbiAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bWJvbCNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIEJOLnByb3RvdHlwZVtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGluc3BlY3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfVxuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZHJuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcbiAgfTtcblxuICBpZiAoQnVmZmVyKSB7XG4gICAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUgKEFycmF5VHlwZSwgc2l6ZSkge1xuICAgIGlmIChBcnJheVR5cGUuYWxsb2NVbnNhZmUpIHtcbiAgICAgIHJldHVybiBBcnJheVR5cGUuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHNpemUpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHZhciByZXMgPSBhbGxvY2F0ZShBcnJheVR5cGUsIHJlcUxlbmd0aCk7XG4gICAgdmFyIHBvc3RmaXggPSBlbmRpYW4gPT09ICdsZScgPyAnTEUnIDogJ0JFJztcbiAgICB0aGlzWydfdG9BcnJheUxpa2UnICsgcG9zdGZpeF0ocmVzLCBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VMRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUxFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICByZXNbcG9zaXRpb24rK10gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlQkUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VCRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24tLV0gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICByZXNbcG9zaXRpb24tLV0gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdID4+PiB3Yml0KSAmIDB4MDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgLy8gVGVtcG9yYXJ5IGRpc2FibGUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy9pc3N1ZXMvMjExXG4gICAgLy8gdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIC8vIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICAgIHJldHVybiBiaWdNdWxUbyhzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8PSBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLl9zdHJpcCgpO1xuICAgIH1cbiAgICBhLl9zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCAocjIgPT09IDEgJiYgY21wID09PSAwKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kcm4gPSBmdW5jdGlvbiBtb2RybiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyAtYWNjIDogYWNjO1xuICB9O1xuXG4gIC8vIFdBUk5JTkc6IERFUFJFQ0FURURcbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5tb2RybihudW0pO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY0IGluc3RhbmNlXG4gICAgICAgIHIuc3RyaXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NSBpbnN0YW5jZVxuICAgICAgICByLl9zdHJpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgbW92ZShhLCBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcykpO1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJhc3NlcnQiLCJ2YWwiLCJtc2ciLCJFcnJvciIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJCTiIsIm51bWJlciIsImJhc2UiLCJlbmRpYW4iLCJpc0JOIiwibmVnYXRpdmUiLCJ3b3JkcyIsImxlbmd0aCIsInJlZCIsIl9pbml0Iiwid29yZFNpemUiLCJCdWZmZXIiLCJ3aW5kb3ciLCJyZXF1aXJlIiwiZSIsIm51bSIsIkFycmF5IiwiaXNBcnJheSIsIm1heCIsImxlZnQiLCJyaWdodCIsImNtcCIsIm1pbiIsImluaXQiLCJfaW5pdE51bWJlciIsIl9pbml0QXJyYXkiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJzdGFydCIsIl9wYXJzZUhleCIsIl9wYXJzZUJhc2UiLCJ0b0FycmF5IiwiTWF0aCIsImNlaWwiLCJpIiwiaiIsInciLCJvZmYiLCJfc3RyaXAiLCJwYXJzZUhleDRCaXRzIiwic3RyaW5nIiwiaW5kZXgiLCJjIiwiY2hhckNvZGVBdCIsInBhcnNlSGV4Qnl0ZSIsImxvd2VyQm91bmQiLCJyIiwicGFyc2VMZW5ndGgiLCJwYXJzZUJhc2UiLCJzdHIiLCJlbmQiLCJtdWwiLCJiIiwibGVuIiwibGltYkxlbiIsImxpbWJQb3ciLCJ0b3RhbCIsIm1vZCIsIndvcmQiLCJpbXVsbiIsIl9pYWRkbiIsInBvdyIsImNvcHkiLCJkZXN0IiwibW92ZSIsInNyYyIsIl9tb3ZlIiwiY2xvbmUiLCJfZXhwYW5kIiwic2l6ZSIsInN0cmlwIiwiX25vcm1TaWduIiwiU3ltYm9sIiwiZm9yIiwiaW5zcGVjdCIsInplcm9zIiwiZ3JvdXBTaXplcyIsImdyb3VwQmFzZXMiLCJwYWRkaW5nIiwib3V0IiwiY2FycnkiLCJncm91cFNpemUiLCJncm91cEJhc2UiLCJpc1plcm8iLCJtb2RybiIsImlkaXZuIiwidG9OdW1iZXIiLCJyZXQiLCJ0b0pTT04iLCJ0b0J1ZmZlciIsInRvQXJyYXlMaWtlIiwiYWxsb2NhdGUiLCJBcnJheVR5cGUiLCJhbGxvY1Vuc2FmZSIsImJ5dGVMZW5ndGgiLCJyZXFMZW5ndGgiLCJyZXMiLCJwb3N0Zml4IiwiX3RvQXJyYXlMaWtlTEUiLCJwb3NpdGlvbiIsInNoaWZ0IiwiX3RvQXJyYXlMaWtlQkUiLCJjbHozMiIsIl9jb3VudEJpdHMiLCJ0IiwiX3plcm9CaXRzIiwiYml0TGVuZ3RoIiwiaGkiLCJ0b0JpdEFycmF5IiwiYml0Iiwid2JpdCIsInplcm9CaXRzIiwidG9Ud29zIiwid2lkdGgiLCJhYnMiLCJpbm90biIsImlhZGRuIiwiZnJvbVR3b3MiLCJ0ZXN0biIsIm5vdG4iLCJpbmVnIiwiaXNOZWciLCJuZWciLCJpdW9yIiwiaW9yIiwib3IiLCJ1b3IiLCJpdWFuZCIsImlhbmQiLCJhbmQiLCJ1YW5kIiwiaXV4b3IiLCJhIiwiaXhvciIsInhvciIsInV4b3IiLCJieXRlc05lZWRlZCIsImJpdHNMZWZ0Iiwic2V0biIsImlhZGQiLCJpc3ViIiwiYWRkIiwic3ViIiwic21hbGxNdWxUbyIsInNlbGYiLCJsbyIsImsiLCJuY2FycnkiLCJyd29yZCIsIm1heEoiLCJjb21iMTBNdWxUbyIsIm8iLCJtaWQiLCJhMCIsImFsMCIsImFoMCIsImExIiwiYWwxIiwiYWgxIiwiYTIiLCJhbDIiLCJhaDIiLCJhMyIsImFsMyIsImFoMyIsImE0IiwiYWw0IiwiYWg0IiwiYTUiLCJhbDUiLCJhaDUiLCJhNiIsImFsNiIsImFoNiIsImE3IiwiYWw3IiwiYWg3IiwiYTgiLCJhbDgiLCJhaDgiLCJhOSIsImFsOSIsImFoOSIsImIwIiwiYmwwIiwiYmgwIiwiYjEiLCJibDEiLCJiaDEiLCJiMiIsImJsMiIsImJoMiIsImIzIiwiYmwzIiwiYmgzIiwiYjQiLCJibDQiLCJiaDQiLCJiNSIsImJsNSIsImJoNSIsImI2IiwiYmw2IiwiYmg2IiwiYjciLCJibDciLCJiaDciLCJiOCIsImJsOCIsImJoOCIsImI5IiwiYmw5IiwiYmg5IiwiaW11bCIsIncwIiwidzEiLCJ3MiIsInczIiwidzQiLCJ3NSIsInc2IiwidzciLCJ3OCIsInc5IiwidzEwIiwidzExIiwidzEyIiwidzEzIiwidzE0IiwidzE1IiwidzE2IiwidzE3IiwidzE4IiwiYmlnTXVsVG8iLCJobmNhcnJ5IiwianVtYm9NdWxUbyIsIm11bFRvIiwiRkZUTSIsIngiLCJ5IiwibWFrZVJCVCIsIk4iLCJsIiwicmV2QmluIiwicmIiLCJwZXJtdXRlIiwicmJ0IiwicndzIiwiaXdzIiwicnR3cyIsIml0d3MiLCJ0cmFuc2Zvcm0iLCJzIiwicnR3ZGYiLCJjb3MiLCJQSSIsIml0d2RmIiwic2luIiwicCIsInJ0d2RmXyIsIml0d2RmXyIsInJlIiwiaWUiLCJybyIsImlvIiwicngiLCJndWVzc0xlbjEzYiIsIm4iLCJtIiwib2RkIiwiY29uanVnYXRlIiwibm9ybWFsaXplMTNiIiwid3MiLCJyb3VuZCIsImNvbnZlcnQxM2IiLCJzdHViIiwicGgiLCJtdWxwIiwiXyIsInJ3c3QiLCJpd3N0IiwibnJ3cyIsIm5yd3N0Iiwibml3c3QiLCJybXdzIiwibXVsZiIsImlzTmVnTnVtIiwibXVsbiIsInNxciIsImlzcXIiLCJxIiwiaXVzaGxuIiwiYml0cyIsImNhcnJ5TWFzayIsIm5ld0NhcnJ5IiwiaXNobG4iLCJpdXNocm4iLCJoaW50IiwiZXh0ZW5kZWQiLCJoIiwibWFzayIsIm1hc2tlZFdvcmRzIiwiaXNocm4iLCJzaGxuIiwidXNobG4iLCJzaHJuIiwidXNocm4iLCJpbWFza24iLCJtYXNrbiIsImlzdWJuIiwiYWRkbiIsInN1Ym4iLCJpYWJzIiwiX2lzaGxuc3VibXVsIiwiX3dvcmREaXYiLCJtb2RlIiwiYmhpIiwiYmhpQml0cyIsImRpZmYiLCJxaiIsImRpdiIsImRpdm1vZCIsInBvc2l0aXZlIiwiZGl2biIsInVtb2QiLCJkaXZSb3VuZCIsImRtIiwiaGFsZiIsInIyIiwiYW5kbG4iLCJhY2MiLCJtb2RuIiwiZWdjZCIsIkEiLCJCIiwiQyIsIkQiLCJnIiwiaXNFdmVuIiwieXAiLCJ4cCIsImltIiwiaXNPZGQiLCJqbSIsImdjZCIsIl9pbnZtcCIsIngxIiwieDIiLCJkZWx0YSIsImNtcG4iLCJpbnZtIiwiYmluY24iLCJ1Y21wIiwiZ3RuIiwiZ3QiLCJndGVuIiwiZ3RlIiwibHRuIiwibHQiLCJsdGVuIiwibHRlIiwiZXFuIiwiZXEiLCJSZWQiLCJ0b1JlZCIsImN0eCIsImNvbnZlcnRUbyIsIl9mb3JjZVJlZCIsImZyb21SZWQiLCJjb252ZXJ0RnJvbSIsImZvcmNlUmVkIiwicmVkQWRkIiwicmVkSUFkZCIsInJlZFN1YiIsInJlZElTdWIiLCJyZWRTaGwiLCJzaGwiLCJyZWRNdWwiLCJfdmVyaWZ5MiIsInJlZElNdWwiLCJyZWRTcXIiLCJfdmVyaWZ5MSIsInJlZElTcXIiLCJyZWRTcXJ0Iiwic3FydCIsInJlZEludm0iLCJyZWROZWciLCJyZWRQb3ciLCJwcmltZXMiLCJrMjU2IiwicDIyNCIsInAxOTIiLCJwMjU1MTkiLCJNUHJpbWUiLCJuYW1lIiwidG1wIiwiX3RtcCIsImlyZWR1Y2UiLCJybGVuIiwic3BsaXQiLCJpbXVsSyIsInVuZGVmaW5lZCIsImlucHV0IiwiSzI1NiIsImNhbGwiLCJvdXRwdXQiLCJvdXRMZW4iLCJwcmV2IiwibmV4dCIsIlAyMjQiLCJQMTkyIiwiUDI1NTE5IiwiX3ByaW1lIiwicHJpbWUiLCJpbW9kIiwibW9kMyIsIm9uZSIsIm5PbmUiLCJscG93IiwieiIsImludiIsIndpbmRvd1NpemUiLCJ3bmQiLCJjdXJyZW50IiwiY3VycmVudExlbiIsIm1vbnQiLCJNb250IiwicmludiIsIm1pbnYiLCJ1Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWalletAdapter: () => (/* binding */ BaseWalletAdapter),\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ eventemitter3__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   WalletReadyState: () => (/* binding */ WalletReadyState),\n/* harmony export */   isIosAndRedirectable: () => (/* binding */ isIosAndRedirectable),\n/* harmony export */   scopePollingDetectionStrategy: () => (/* binding */ scopePollingDetectionStrategy)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"eventemitter3\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\n\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */ var WalletReadyState;\n(function(WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */ WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */ WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */ WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nclass BaseWalletAdapter extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__ {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey) throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({\n            commitment: options.preflightCommitment,\n            minContextSlot: options.minContextSlot\n        })).blockhash;\n        return transaction;\n    }\n}\nfunction scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (true) return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers){\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(()=>clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (// Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", detectAndDispose, {\n            once: true\n        });\n        disposers.push(()=>document.removeEventListener(\"DOMContentLoaded\", detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (// If the `complete` state has been reached, we're too late.\n    document.readyState !== \"complete\") {\n        window.addEventListener(\"load\", detectAndDispose, {\n            once: true\n        });\n        disposers.push(()=>window.removeEventListener(\"load\", detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */ function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator) return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes(\"iphone\") || userAgent.includes(\"ipad\");\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes(\"safari\");\n    return isIos && isSafari;\n} //# sourceMappingURL=adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ3lDO0FBQytCO0FBR2hEO0FBdUN4Qjs7Ozs7Ozs7SUFTQSxJQUFZRSxpQkFrQlg7QUFsQkQsVUFBWUEsZ0JBQWdCO0lBQ3hCOzs7O1FBS0FBLGdCQUFBO0lBQ0FBLGdCQUFBO0lBQ0E7OztRQUlBQSxnQkFBQTtJQUNBOzs7UUFJQUEsZ0JBQUE7QUFDSixHQWxCWUEsb0JBQUFBLENBQUFBLG1CQUFnQjtBQW9CdEIsTUFBZ0JDLDBCQUNWSCwwQ0FBQUE7SUFXUixJQUFJSSxZQUFTO1FBQ1QsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDQyxTQUFTO0lBQzNCO0lBRUEsTUFBTUMsY0FBVztRQUNiLE1BQU0sSUFBSSxDQUFDQyxPQUFPO0lBQ3RCO0lBV1UsTUFBTUMsbUJBQ1pDLFdBQXdCLEVBQ3hCQyxVQUFzQixFQUN0QkMsVUFBdUIsRUFBRTtRQUV6QixNQUFNTixZQUFZLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxJQUFJLENBQUNBLFdBQVcsTUFBTSxJQUFJSiwrREFBQUE7UUFFMUJRLFlBQVlHLFFBQVEsR0FBR0gsWUFBWUcsUUFBUSxJQUFJUDtRQUMvQ0ksWUFBWUksZUFBZSxHQUN2QkosWUFBWUksZUFBZSxJQUMzQixDQUNJLE1BQU1ILFdBQVdJLGtCQUFrQixDQUFDO1lBQ2hDQyxZQUFZSixRQUFRSyxtQkFBbUI7WUFDdkNDLGdCQUFnQk4sUUFBUU0sY0FBYztVQUN6QyxFQUNIQyxTQUFTO1FBRWYsT0FBT1Q7SUFDWDs7QUFHRSxTQUFVVSw4QkFBOEJDLE1BQXFCO0lBQy9ELDBDQUEwQztJQUMxQyxJQUFJLElBQXFELEVBQWE7SUFFdEUsTUFBTUUsWUFBNEIsRUFBRTtJQUVwQyxTQUFTQztRQUNMLE1BQU1DLFdBQVdKO1FBQ2pCLElBQUlJLFVBQVU7WUFDVixLQUFLLE1BQU1DLFdBQVdILFVBQVc7Z0JBQzdCRzs7O0lBR1o7SUFFQSwyQ0FBMkM7SUFDM0MsTUFBTUMsV0FDRixrREFBa0Q7SUFDbERDLFlBQVlKLGtCQUFrQjtJQUNsQ0QsVUFBVU0sSUFBSSxDQUFDLElBQU1DLGNBQWNIO0lBRW5DLHdFQUF3RTtJQUN4RSxJQUNJLHFEQUFxRDtJQUNyREwsU0FBU1MsVUFBVSxLQUFLLFdBQzFCO1FBQ0VULFNBQVNVLGdCQUFnQixDQUFDLG9CQUFvQlIsa0JBQWtCO1lBQUVTLE1BQU07UUFBSTtRQUM1RVYsVUFBVU0sSUFBSSxDQUFDLElBQU1QLFNBQVNZLG1CQUFtQixDQUFDLG9CQUFvQlY7O0lBRzFFLDJEQUEyRDtJQUMzRCxJQUNJLDREQUE0RDtJQUM1REYsU0FBU1MsVUFBVSxLQUFLLFlBQzFCO1FBQ0VJLE9BQU9ILGdCQUFnQixDQUFDLFFBQVFSLGtCQUFrQjtZQUFFUyxNQUFNO1FBQUk7UUFDOURWLFVBQVVNLElBQUksQ0FBQyxJQUFNTSxPQUFPRCxtQkFBbUIsQ0FBQyxRQUFRVjs7SUFHNUQsMENBQTBDO0lBQzFDQTtBQUNKO0FBRUE7Ozs7Ozs7O0lBU00sU0FBVVk7SUFDWixvQkFBb0I7SUFDcEIsSUFBSSxDQUFDQyxXQUFXLE9BQU87SUFFdkIsTUFBTUMsWUFBWUQsVUFBVUMsU0FBUyxDQUFDQyxXQUFXO0lBRWpELDhEQUE4RDtJQUM5RCwwREFBMEQ7SUFDMUQsTUFBTUMsUUFBUUYsVUFBVUcsUUFBUSxDQUFDLGFBQWFILFVBQVVHLFFBQVEsQ0FBQztJQUVqRSxrREFBa0Q7SUFDbEQsbURBQW1EO0lBQ25ELHNEQUFzRDtJQUN0RCxNQUFNQyxXQUFXSixVQUFVRyxRQUFRLENBQUM7SUFFcEMsT0FBT0QsU0FBU0U7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL2FkYXB0ZXIudHM/NTVjNCJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJXYWxsZXROb3RDb25uZWN0ZWRFcnJvciIsIldhbGxldFJlYWR5U3RhdGUiLCJCYXNlV2FsbGV0QWRhcHRlciIsImNvbm5lY3RlZCIsInB1YmxpY0tleSIsImF1dG9Db25uZWN0IiwiY29ubmVjdCIsInByZXBhcmVUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJmZWVQYXllciIsInJlY2VudEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsImNvbW1pdG1lbnQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwibWluQ29udGV4dFNsb3QiLCJibG9ja2hhc2giLCJzY29wZVBvbGxpbmdEZXRlY3Rpb25TdHJhdGVneSIsImRldGVjdCIsImRvY3VtZW50IiwiZGlzcG9zZXJzIiwiZGV0ZWN0QW5kRGlzcG9zZSIsImRldGVjdGVkIiwiZGlzcG9zZSIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJwdXNoIiwiY2xlYXJJbnRlcnZhbCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ3aW5kb3ciLCJpc0lvc0FuZFJlZGlyZWN0YWJsZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiaXNJb3MiLCJpbmNsdWRlcyIsImlzU2FmYXJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAccountError: () => (/* binding */ WalletAccountError),\n/* harmony export */   WalletConfigError: () => (/* binding */ WalletConfigError),\n/* harmony export */   WalletConnectionError: () => (/* binding */ WalletConnectionError),\n/* harmony export */   WalletDisconnectedError: () => (/* binding */ WalletDisconnectedError),\n/* harmony export */   WalletDisconnectionError: () => (/* binding */ WalletDisconnectionError),\n/* harmony export */   WalletError: () => (/* binding */ WalletError),\n/* harmony export */   WalletKeypairError: () => (/* binding */ WalletKeypairError),\n/* harmony export */   WalletLoadError: () => (/* binding */ WalletLoadError),\n/* harmony export */   WalletNotConnectedError: () => (/* binding */ WalletNotConnectedError),\n/* harmony export */   WalletNotReadyError: () => (/* binding */ WalletNotReadyError),\n/* harmony export */   WalletPublicKeyError: () => (/* binding */ WalletPublicKeyError),\n/* harmony export */   WalletSendTransactionError: () => (/* binding */ WalletSendTransactionError),\n/* harmony export */   WalletSignInError: () => (/* binding */ WalletSignInError),\n/* harmony export */   WalletSignMessageError: () => (/* binding */ WalletSignMessageError),\n/* harmony export */   WalletSignTransactionError: () => (/* binding */ WalletSignTransactionError),\n/* harmony export */   WalletTimeoutError: () => (/* binding */ WalletTimeoutError),\n/* harmony export */   WalletWindowBlockedError: () => (/* binding */ WalletWindowBlockedError),\n/* harmony export */   WalletWindowClosedError: () => (/* binding */ WalletWindowClosedError)\n/* harmony export */ });\nclass WalletError extends Error {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message, error){\n        super(message);\n        this.error = error;\n    }\n}\nclass WalletNotReadyError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotReadyError\";\n    }\n}\nclass WalletLoadError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletLoadError\";\n    }\n}\nclass WalletConfigError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletConfigError\";\n    }\n}\nclass WalletConnectionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletConnectionError\";\n    }\n}\nclass WalletDisconnectedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletDisconnectedError\";\n    }\n}\nclass WalletDisconnectionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletDisconnectionError\";\n    }\n}\nclass WalletAccountError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletAccountError\";\n    }\n}\nclass WalletPublicKeyError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletPublicKeyError\";\n    }\n}\nclass WalletKeypairError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletKeypairError\";\n    }\n}\nclass WalletNotConnectedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotConnectedError\";\n    }\n}\nclass WalletSendTransactionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSendTransactionError\";\n    }\n}\nclass WalletSignTransactionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignTransactionError\";\n    }\n}\nclass WalletSignMessageError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignMessageError\";\n    }\n}\nclass WalletSignInError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignInError\";\n    }\n}\nclass WalletTimeoutError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletTimeoutError\";\n    }\n}\nclass WalletWindowBlockedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletWindowBlockedError\";\n    }\n}\nclass WalletWindowClosedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletWindowClosedError\";\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFNLE1BQU9BLG9CQUFvQkM7SUFHN0IsNkVBQTZFO0lBQzdFQyxZQUFZQyxPQUFnQixFQUFFQyxLQUFXO1FBQ3JDLEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDakI7O0FBR0UsTUFBT0MsNEJBQTRCTDtJQUF6Q0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPQyx3QkFBd0JQO0lBQXJDRSxhQUFBOztRQUNJLEtBQUFJLElBQUksR0FBRztJQUNYOztBQUVNLE1BQU9FLDBCQUEwQlI7SUFBdkNFLGFBQUE7O1FBQ0ksS0FBQUksSUFBSSxHQUFHO0lBQ1g7O0FBRU0sTUFBT0csOEJBQThCVDtJQUEzQ0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPSSxnQ0FBZ0NWO0lBQTdDRSxhQUFBOztRQUNJLEtBQUFJLElBQUksR0FBRztJQUNYOztBQUVNLE1BQU9LLGlDQUFpQ1g7SUFBOUNFLGFBQUE7O1FBQ0ksS0FBQUksSUFBSSxHQUFHO0lBQ1g7O0FBRU0sTUFBT00sMkJBQTJCWjtJQUF4Q0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPTyw2QkFBNkJiO0lBQTFDRSxhQUFBOztRQUNJLEtBQUFJLElBQUksR0FBRztJQUNYOztBQUVNLE1BQU9RLDJCQUEyQmQ7SUFBeENFLGFBQUE7O1FBQ0ksS0FBQUksSUFBSSxHQUFHO0lBQ1g7O0FBRU0sTUFBT1MsZ0NBQWdDZjtJQUE3Q0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPVSxtQ0FBbUNoQjtJQUFoREUsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPVyxtQ0FBbUNqQjtJQUFoREUsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPWSwrQkFBK0JsQjtJQUE1Q0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPYSwwQkFBMEJuQjtJQUF2Q0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPYywyQkFBMkJwQjtJQUF4Q0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPZSxpQ0FBaUNyQjtJQUE5Q0UsYUFBQTs7UUFDSSxLQUFBSSxJQUFJLEdBQUc7SUFDWDs7QUFFTSxNQUFPZ0IsZ0NBQWdDdEI7SUFBN0NFLGFBQUE7O1FBQ0ksS0FBQUksSUFBSSxHQUFHO0lBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL2Vycm9ycy50cz85NzFiIl0sIm5hbWVzIjpbIldhbGxldEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJlcnJvciIsIldhbGxldE5vdFJlYWR5RXJyb3IiLCJuYW1lIiwiV2FsbGV0TG9hZEVycm9yIiwiV2FsbGV0Q29uZmlnRXJyb3IiLCJXYWxsZXRDb25uZWN0aW9uRXJyb3IiLCJXYWxsZXREaXNjb25uZWN0ZWRFcnJvciIsIldhbGxldERpc2Nvbm5lY3Rpb25FcnJvciIsIldhbGxldEFjY291bnRFcnJvciIsIldhbGxldFB1YmxpY0tleUVycm9yIiwiV2FsbGV0S2V5cGFpckVycm9yIiwiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvciIsIldhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIiwiV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciIsIldhbGxldFNpZ25JbkVycm9yIiwiV2FsbGV0VGltZW91dEVycm9yIiwiV2FsbGV0V2luZG93QmxvY2tlZEVycm9yIiwiV2FsbGV0V2luZG93Q2xvc2VkRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-base/lib/esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/index.js ***!
  \*******************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _adapter_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _adapter_js__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _errors_js__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _errors_js__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _signer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signer.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _signer_js__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _signer_js__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _standard_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./standard.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transaction.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _transaction_js__WEBPACK_IMPORTED_MODULE_4__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _transaction_js__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/types.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types_js__WEBPACK_IMPORTED_MODULE_5__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types_js__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_standard_js__WEBPACK_IMPORTED_MODULE_3__]);\n_standard_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _standard_js__WEBPACK_IMPORTED_MODULE_3__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _standard_js__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUNEO0FBQ0E7QUFDRTtBQUNHO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL2luZGV4LnRzPzY3NDQiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-base/lib/esm/index.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessageSignerWalletAdapter: () => (/* binding */ BaseMessageSignerWalletAdapter),\n/* harmony export */   BaseSignInMessageSignerWalletAdapter: () => (/* binding */ BaseSignInMessageSignerWalletAdapter),\n/* harmony export */   BaseSignerWalletAdapter: () => (/* binding */ BaseSignerWalletAdapter)\n/* harmony export */ });\n/* harmony import */ var _adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transaction.js */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n\n\n\nclass BaseSignerWalletAdapter extends _adapter_js__WEBPACK_IMPORTED_MODULE_0__.BaseWalletAdapter {\n    async sendTransaction(transaction, connection, options = {}) {\n        let emit = true;\n        try {\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version)) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n                try {\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                } catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            } else {\n                try {\n                    const { signers, ...sendOptions } = options;\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                } catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            }\n        } catch (error) {\n            if (emit) {\n                this.emit(\"error\", error);\n            }\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        for (const transaction of transactions){\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version)) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n            }\n        }\n        const signedTransactions = [];\n        for (const transaction of transactions){\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\nclass BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\nclass BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {\n} //# sourceMappingURL=signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vc2lnbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQU9zQjtBQUMrRDtBQUNhO0FBYTVGLE1BQWdCSSxnQ0FDVkosMERBQUFBO0lBR1IsTUFBTUssZ0JBQ0ZDLFdBQW9GLEVBQ3BGQyxVQUFzQixFQUN0QkMsVUFBa0MsRUFBRTtRQUVwQyxJQUFJQyxPQUFPO1FBQ1gsSUFBSTtZQUNBLElBQUlOLHVFQUFBQSxDQUF1QkcsY0FBYztnQkFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ0ksNEJBQTRCLEVBQ2xDLE1BQU0sSUFBSVQsa0VBQUFBLENBQ04sK0RBQStEO2dCQUd2RSxJQUFJLENBQUMsSUFBSSxDQUFDUyw0QkFBNEIsQ0FBQ0MsR0FBRyxDQUFDTCxZQUFZTSxPQUFPLEdBQzFELE1BQU0sSUFBSVgsa0VBQUFBLENBQ04sK0JBQStCSyxZQUFZTSxPQUFPLGlDQUFpQztnQkFHM0YsSUFBSTtvQkFDQU4sY0FBYyxNQUFNLElBQUksQ0FBQ08sZUFBZSxDQUFDUDtvQkFFekMsTUFBTVEsaUJBQWlCUixZQUFZUyxTQUFTO29CQUU1QyxPQUFPLE1BQU1SLFdBQVdTLGtCQUFrQixDQUFDRixnQkFBZ0JOO2tCQUM3RCxPQUFPUyxPQUFZO29CQUNqQiw0RkFBNEY7b0JBQzVGLElBQUlBLGlCQUFpQmYsa0VBQUFBLEVBQTRCO3dCQUM3Q08sT0FBTzt3QkFDUCxNQUFNUTs7b0JBRVYsTUFBTSxJQUFJaEIsa0VBQUFBLENBQTJCZ0IsT0FBT0MsU0FBU0Q7O21CQUV0RDtnQkFDSCxJQUFJO29CQUNBLE1BQU0sRUFBRUUsT0FBTyxFQUFFLEdBQUdDLGFBQWEsR0FBR1o7b0JBRXBDRixjQUFjLE1BQU0sSUFBSSxDQUFDZSxrQkFBa0IsQ0FBQ2YsYUFBYUMsWUFBWWE7b0JBRXJFRCxTQUFTRyxVQUFVaEIsWUFBWWlCLFdBQVcsSUFBSUo7b0JBRTlDYixjQUFjLE1BQU0sSUFBSSxDQUFDTyxlQUFlLENBQUNQO29CQUV6QyxNQUFNUSxpQkFBaUJSLFlBQVlTLFNBQVM7b0JBRTVDLE9BQU8sTUFBTVIsV0FBV1Msa0JBQWtCLENBQUNGLGdCQUFnQk07a0JBQzdELE9BQU9ILE9BQVk7b0JBQ2pCLDRGQUE0RjtvQkFDNUYsSUFBSUEsaUJBQWlCZixrRUFBQUEsRUFBNEI7d0JBQzdDTyxPQUFPO3dCQUNQLE1BQU1ROztvQkFFVixNQUFNLElBQUloQixrRUFBQUEsQ0FBMkJnQixPQUFPQyxTQUFTRDs7O1VBRy9ELE9BQU9BLE9BQVk7WUFDakIsSUFBSVIsTUFBTTtnQkFDTixJQUFJLENBQUNBLElBQUksQ0FBQyxTQUFTUTs7WUFFdkIsTUFBTUE7O0lBRWQ7SUFNQSxNQUFNTyxvQkFDRkMsWUFBaUI7UUFFakIsS0FBSyxNQUFNbkIsZUFBZW1CLGFBQWM7WUFDcEMsSUFBSXRCLHVFQUFBQSxDQUF1QkcsY0FBYztnQkFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ0ksNEJBQTRCLEVBQ2xDLE1BQU0sSUFBSVIsa0VBQUFBLENBQ04sK0RBQStEO2dCQUd2RSxJQUFJLENBQUMsSUFBSSxDQUFDUSw0QkFBNEIsQ0FBQ0MsR0FBRyxDQUFDTCxZQUFZTSxPQUFPLEdBQzFELE1BQU0sSUFBSVYsa0VBQUFBLENBQ04sK0JBQStCSSxZQUFZTSxPQUFPLGlDQUFpQzs7O1FBS25HLE1BQU1jLHFCQUEwQixFQUFFO1FBQ2xDLEtBQUssTUFBTXBCLGVBQWVtQixhQUFjO1lBQ3BDQyxtQkFBbUJDLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQ2QsZUFBZSxDQUFDUDs7UUFFdkQsT0FBT29CO0lBQ1g7O0FBVUUsTUFBZ0JFLHVDQUNWeEI7O0FBYU4sTUFBZ0J5Qiw2Q0FDVkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL3NpZ25lci50cz81MmNkIl0sIm5hbWVzIjpbIkJhc2VXYWxsZXRBZGFwdGVyIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciIsImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJCYXNlU2lnbmVyV2FsbGV0QWRhcHRlciIsInNlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJlbWl0Iiwic3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyIsImhhcyIsInZlcnNpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJyYXdUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsInNlbmRSYXdUcmFuc2FjdGlvbiIsImVycm9yIiwibWVzc2FnZSIsInNpZ25lcnMiLCJzZW5kT3B0aW9ucyIsInByZXBhcmVUcmFuc2FjdGlvbiIsImxlbmd0aCIsInBhcnRpYWxTaWduIiwic2lnbkFsbFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9ucyIsInB1c2giLCJCYXNlTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiLCJCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js ***!
  \**********************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWalletAdapterCompatibleStandardWallet: () => (/* binding */ isWalletAdapterCompatibleStandardWallet)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"@solana/wallet-standard-features\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wallet-standard/features */ \"@wallet-standard/features\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__, _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__]);\n([_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__, _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\nfunction isWalletAdapterCompatibleStandardWallet(wallet) {\n    return _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__.StandardConnect in wallet.features && _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__.StandardEvents in wallet.features && (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__.SolanaSignAndSendTransaction in wallet.features || _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__.SolanaSignTransaction in wallet.features);\n} //# sourceMappingURL=standard.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vc3RhbmRhcmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBTzBDO0FBUVA7QUFrQjdCLFNBQVVJLHdDQUNaQyxNQUFzQjtJQUV0QixPQUNJSCxzRUFBQUEsSUFBbUJHLE9BQU9DLFFBQVEsSUFDbENILHFFQUFBQSxJQUFrQkUsT0FBT0MsUUFBUSxJQUNoQ04sQ0FBQUEsMEZBQUFBLElBQWdDSyxPQUFPQyxRQUFRLElBQUlMLG1GQUFBQSxJQUF5QkksT0FBT0MsUUFBUTtBQUVwRyIsInNvdXJjZXMiOlsid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi8uLi9zcmMvc3RhbmRhcmQudHM/MjQzOCJdLCJuYW1lcyI6WyJTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwiU29sYW5hU2lnblRyYW5zYWN0aW9uIiwiU3RhbmRhcmRDb25uZWN0IiwiU3RhbmRhcmRFdmVudHMiLCJpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXQiLCJ3YWxsZXQiLCJmZWF0dXJlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionedTransaction: () => (/* binding */ isVersionedTransaction)\n/* harmony export */ });\nfunction isVersionedTransaction(transaction) {\n    return \"version\" in transaction;\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQVFNLFNBQVVBLHVCQUNaQyxXQUErQztJQUUvQyxPQUFPLGFBQWFBO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy90cmFuc2FjdGlvbi50cz80ODZkIl0sIm5hbWVzIjpbImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-base/lib/esm/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAdapterNetwork: () => (/* binding */ WalletAdapterNetwork)\n/* harmony export */ });\nvar WalletAdapterNetwork;\n(function(WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet-beta\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQVdBLElBQVlBLHFCQUlYO0FBSkQsVUFBWUEsb0JBQW9CO0lBQzVCQSxvQkFBQTtJQUNBQSxvQkFBQTtJQUNBQSxvQkFBQTtBQUNKLEdBSllBLHdCQUFBQSxDQUFBQSx1QkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL3R5cGVzLnRzPzQ3OWQiXSwibmFtZXMiOlsiV2FsbGV0QWRhcHRlck5ldHdvcmsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-base/lib/esm/types.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionProvider: () => (/* binding */ ConnectionProvider)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.cjs.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useConnection.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n\n\n\nconst ConnectionProvider = ({ children, endpoint, config = {\n    commitment: \"confirmed\"\n} })=>{\n    const connection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(endpoint, config), [\n        endpoint,\n        config\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_useConnection_js__WEBPACK_IMPORTED_MODULE_2__.ConnectionContext.Provider, {\n        value: {\n            connection\n        }\n    }, children);\n}; //# sourceMappingURL=ConnectionProvider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL0Nvbm5lY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9FO0FBQ0o7QUFDVDtBQVFoRCxNQUFNSSxxQkFBa0QsQ0FBQyxFQUM1REMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLFNBQVM7SUFBRUMsWUFBWTtBQUFXLENBQUUsRUFDdkM7SUFDRyxNQUFNQyxhQUFhUCw4Q0FBQUEsQ0FBUSxJQUFNLElBQUlGLHVEQUFBQSxDQUFXTSxVQUFVQyxTQUFTO1FBQUNEO1FBQVVDO0tBQU87SUFFckYscUJBQU9OLGdEQUFBLENBQUNFLGdFQUFBQSxDQUFrQlEsUUFBUTtRQUFDQyxPQUFPO1lBQUVIO1FBQVU7SUFBRSxHQUFHSjtBQUMvRCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy9Db25uZWN0aW9uUHJvdmlkZXIudHN4PzAyMzkiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIlJlYWN0IiwidXNlTWVtbyIsIkNvbm5lY3Rpb25Db250ZXh0IiwiQ29ubmVjdGlvblByb3ZpZGVyIiwiY2hpbGRyZW4iLCJlbmRwb2ludCIsImNvbmZpZyIsImNvbW1pdG1lbnQiLCJjb25uZWN0aW9uIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js ***!
  \*****************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProvider: () => (/* binding */ WalletProvider)\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-react */ \"@solana/wallet-standard-wallet-adapter-react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var _getEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getEnvironment.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\");\n/* harmony import */ var _getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getInferredClusterFromEndpoint.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useConnection.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./useLocalStorage.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\");\n/* harmony import */ var _WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WalletProviderBase.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__, _solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_1__, _getEnvironment_js__WEBPACK_IMPORTED_MODULE_3__, _WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__]);\n([_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__, _solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_1__, _getEnvironment_js__WEBPACK_IMPORTED_MODULE_3__, _WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\nlet _userAgent;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\nfunction getIsMobile(adapters) {\n    const userAgentString = getUserAgent();\n    return (0,_getEnvironment_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n        adapters,\n        userAgentString\n    }) === _getEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (!location) return;\n    return `${location.protocol}//${location.host}`;\n}\nfunction WalletProvider({ children, wallets: adapters, autoConnect, localStorageKey = \"walletName\", onError }) {\n    const { connection } = (0,_useConnection_js__WEBPACK_IMPORTED_MODULE_4__.useConnection)();\n    const adaptersWithStandardAdapters = (0,_solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_1__.useStandardWalletAdapters)(adapters);\n    const mobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>{\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find((adapter)=>adapter.name === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName);\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapter({\n            addressSelector: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAddressSelector)(),\n            appIdentity: {\n                uri: getUriForAppIdentity()\n            },\n            authorizationResultCache: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAuthorizationResultCache)(),\n            cluster: (0,_getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(connection?.rpcEndpoint),\n            onWalletNotFound: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultWalletNotFoundHandler)()\n        });\n    }, [\n        adaptersWithStandardAdapters,\n        connection?.rpcEndpoint\n    ]);\n    const adaptersWithMobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>{\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [\n            mobileWalletAdapter,\n            ...adaptersWithStandardAdapters\n        ];\n    }, [\n        adaptersWithStandardAdapters,\n        mobileWalletAdapter\n    ]);\n    const [walletName, setWalletName] = (0,_useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__.useLocalStorage)(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName : null);\n    const adapter = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>adaptersWithMobileWalletAdapter.find((a)=>a.name === walletName) ?? null, [\n        adaptersWithMobileWalletAdapter,\n        walletName\n    ]);\n    const changeWallet = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((nextWalletName)=>{\n        if (walletName === nextWalletName) return;\n        if (adapter && // Selecting a wallet other than the mobile wallet adapter is not\n        // sufficient reason to call `disconnect` on the mobile wallet adapter.\n        // Calling `disconnect` on the mobile wallet adapter causes the entire\n        // authorization store to be wiped.\n        adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName) {\n            adapter.disconnect();\n        }\n        setWalletName(nextWalletName);\n    }, [\n        adapter,\n        setWalletName,\n        walletName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (!adapter) return;\n        function handleDisconnect() {\n            if (isUnloadingRef.current) return;\n            // Leave the adapter selected in the event of a disconnection.\n            if (walletName === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) return;\n            setWalletName(null);\n        }\n        adapter.on(\"disconnect\", handleDisconnect);\n        return ()=>{\n            adapter.off(\"disconnect\", handleDisconnect);\n        };\n    }, [\n        adapter,\n        adaptersWithStandardAdapters,\n        setWalletName,\n        walletName\n    ]);\n    const hasUserSelectedAWallet = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(false);\n    const handleAutoConnectRequest = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>{\n        if (!autoConnect || !adapter) return;\n        return async ()=>{\n            // If autoConnect is true or returns true, use the default autoConnect behavior.\n            if (autoConnect === true || await autoConnect(adapter)) {\n                if (hasUserSelectedAWallet.current) {\n                    await adapter.connect();\n                } else {\n                    await adapter.autoConnect();\n                }\n            }\n        };\n    }, [\n        autoConnect,\n        adapter\n    ]);\n    const isUnloadingRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (walletName === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */ window.addEventListener(\"beforeunload\", handleBeforeUnload);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n        };\n    }, [\n        adaptersWithStandardAdapters,\n        walletName\n    ]);\n    const handleConnectError = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        if (adapter && adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [\n        adapter,\n        changeWallet\n    ]);\n    const selectWallet = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((walletName)=>{\n        hasUserSelectedAWallet.current = true;\n        changeWallet(walletName);\n    }, [\n        changeWallet\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__.WalletProviderBase, {\n        wallets: adaptersWithMobileWalletAdapter,\n        adapter: adapter,\n        isUnloadingRef: isUnloadingRef,\n        onAutoConnectRequest: handleAutoConnectRequest,\n        onConnectError: handleConnectError,\n        onError: onError,\n        onSelectWallet: selectWallet\n    }, children);\n} //# sourceMappingURL=WalletProvider.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL1dhbGxldFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQU04QztBQUUyQztBQUNGO0FBQ3JCO0FBQ2U7QUFDOUI7QUFDSTtBQUNNO0FBVTdELElBQUlpQjtBQUNKLFNBQVNDO0lBQ0wsSUFBSUQsZUFBZUUsV0FBVztRQUMxQkYsYUFBYUcsV0FBV0MsU0FBUyxFQUFFQyxhQUFhOztJQUVwRCxPQUFPTDtBQUNYO0FBRUEsU0FBU00sWUFBWUMsUUFBbUI7SUFDcEMsTUFBTUMsa0JBQWtCUDtJQUN4QixPQUFPUCw4REFBQUEsQ0FBZTtRQUFFYTtRQUFVQztJQUFlLE9BQVFiLDJEQUFBQSxDQUFZYyxVQUFVO0FBQ25GO0FBRUEsU0FBU0M7SUFDTCxNQUFNQyxXQUFXUixXQUFXUSxRQUFRO0lBQ3BDLElBQUksQ0FBQ0EsVUFBVTtJQUNmLE9BQU8sR0FBR0EsU0FBU0MsUUFBUSxLQUFLRCxTQUFTRSxJQUFJLEVBQUU7QUFDbkQ7QUFFTSxTQUFVQyxlQUFlLEVBQzNCQyxRQUFRLEVBQ1JDLFNBQVNULFFBQVEsRUFDakJVLFdBQVcsRUFDWEMsa0JBQWtCLFlBQVksRUFDOUJDLE9BQU8sRUFDVztJQUNsQixNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHdkIsZ0VBQUFBO0lBQ3ZCLE1BQU13QiwrQkFBK0JqQyx1R0FBQUEsQ0FBMEJtQjtJQUMvRCxNQUFNZSxzQkFBc0I5Qiw4Q0FBQUEsQ0FBUTtRQUNoQyxJQUFJLENBQUNjLFlBQVllLCtCQUErQjtZQUM1QyxPQUFPOztRQUVYLE1BQU1FLDhCQUE4QkYsNkJBQTZCRyxJQUFJLENBQ2pFLENBQUNDLFVBQVlBLFFBQVFDLElBQUksS0FBS3ZDLHFHQUFBQTtRQUVsQyxJQUFJb0MsNkJBQTZCO1lBQzdCLE9BQU9BOztRQUVYLE9BQU8sSUFBSXJDLDJGQUFBQSxDQUEwQjtZQUNqQ3lDLGlCQUFpQjVDLGtHQUFBQTtZ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QUFHO1FBQ2pDTCxhQUFhSDtJQUNqQixHQUNBO1FBQUNHO0tBQWE7SUFFbEIscUJBQ0lsRCxnREFBQSxDQUFDVSxzRUFBQUEsRUFBa0I7UUFDZmlCLFNBQVNrQjtRQUNUVCxTQUFTQTtRQUNUa0IsZ0JBQWdCQTtRQUNoQmMsc0JBQXNCVDtRQUN0QlUsZ0JBQWdCSjtRQUNoQm5DLFNBQVNBO1FBQ1R3QyxnQkFBZ0JKO0lBQVksR0FFM0J4QztBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy9XYWxsZXRQcm92aWRlci50c3g/NTUyYyJdLCJuYW1lcyI6WyJjcmVhdGVEZWZhdWx0QWRkcmVzc1NlbGVjdG9yIiwiY3JlYXRlRGVmYXVsdEF1dGhvcml6YXRpb25SZXN1bHRDYWNoZSIsImNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUiLCJ1c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzIiwiUmVhY3QiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJnZXRFbnZpcm9ubWVudCIsIkVudmlyb25tZW50IiwiZ2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50IiwidXNlQ29ubmVjdGlvbiIsInVzZUxvY2FsU3RvcmFnZSIsIldhbGxldFByb3ZpZGVyQmFzZSIsIl91c2VyQWdlbnQiLCJnZXRVc2VyQWdlbnQiLCJ1bmRlZmluZWQiLCJnbG9iYWxUaGlzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiZ2V0SXNNb2JpbGUiLCJhZGFwdGVycyIsInVzZXJBZ2VudFN0cmluZyIsIk1PQklMRV9XRUIiLCJnZXRVcmlGb3JBcHBJZGVudGl0eSIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJob3N0IiwiV2FsbGV0UHJvdmlkZXIiLCJjaGlsZHJlbiIsIndhbGxldHMiLCJhdXRvQ29ubmVjdCIsImxvY2FsU3RvcmFnZUtleSIsIm9uRXJyb3IiLCJjb25uZWN0aW9uIiwiYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycyIsIm1vYmlsZVdhbGxldEFkYXB0ZXIiLCJleGlzdGluZ01vYmlsZVdhbGxldEFkYXB0ZXIiLCJmaW5kIiwiYWRhcHRlciIsIm5hbWUiLCJhZGRyZXNzU2VsZWN0b3IiLCJhcHBJZGVudGl0eSIsInVyaSIsImF1dGhvcml6YXRpb25SZXN1bHRDYWNoZSIsImNsdXN0ZXIiLCJycGNFbmRwb2ludCIsIm9uV2FsbGV0Tm90Rm91bmQiLCJhZGFwdGVyc1dpdGhNb2JpbGVXYWxsZXRBZGFwdGVyIiwiaW5kZXhPZiIsIndhbGxldE5hbWUiLCJzZXRXYWxsZXROYW1lIiwiYSIsImNoYW5nZVdhbGxldCIsIm5leHRXYWxsZXROYW1lIiwiZGlzY29ubmVjdCIsImhhbmRsZURpc2Nvbm5lY3QiLCJpc1VubG9hZGluZ1JlZiIsImN1cnJlbnQiLCJvbiIsIm9mZiIsImhhc1VzZXJTZWxlY3RlZEFXYWxsZXQiLCJoYW5kbGVBdXRvQ29ubmVjdFJlcXVlc3QiLCJjb25uZWN0IiwiaGFuZGxlQmVmb3JlVW5sb2FkIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVDb25uZWN0RXJyb3IiLCJzZWxlY3RXYWxsZXQiLCJjcmVhdGVFbGVtZW50Iiwib25BdXRvQ29ubmVjdFJlcXVlc3QiLCJvbkNvbm5lY3RFcnJvciIsIm9uU2VsZWN0V2FsbGV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js ***!
  \*********************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProviderBase: () => (/* binding */ WalletProviderBase)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\");\n/* harmony import */ var _useWallet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWallet.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__, _errors_js__WEBPACK_IMPORTED_MODULE_2__]);\n([_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__, _errors_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\nfunction WalletProviderBase({ children, wallets: adapters, adapter, isUnloadingRef, onAutoConnectRequest, onConnectError, onError, onSelectWallet }) {\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [connecting, setConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const isDisconnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [disconnecting, setDisconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [publicKey, setPublicKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapter?.publicKey ?? null);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapter?.connected ?? false);\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */ const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        onErrorRef.current = onError;\n        return ()=>{\n            onErrorRef.current = undefined;\n        };\n    }, [\n        onError\n    ]);\n    const handleErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((error, adapter)=>{\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            } else {\n                console.error(error, adapter);\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError && \"undefined\" !== \"undefined\" && 0) {}\n            }\n        }\n        return error;\n    });\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapters.map((adapter)=>({\n                adapter,\n                readyState: adapter.readyState\n            })).filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Unsupported));\n    // When the adapters change, start to listen for changes to their `readyState`\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets)=>adapters.map((adapter, index)=>{\n                const wallet = wallets[index];\n                // If the wallet hasn't changed, return the same instance\n                return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n                    adapter: adapter,\n                    readyState: adapter.readyState\n                };\n            }).filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Unsupported));\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets)=>{\n                const index = prevWallets.findIndex(({ adapter })=>adapter === this);\n                if (index === -1) return prevWallets;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index];\n                return [\n                    ...prevWallets.slice(0, index),\n                    {\n                        adapter,\n                        readyState\n                    },\n                    ...prevWallets.slice(index + 1)\n                ].filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter)=>adapter.on(\"readyStateChange\", handleReadyStateChange, adapter));\n        return ()=>{\n            adapters.forEach((adapter)=>adapter.off(\"readyStateChange\", handleReadyStateChange, adapter));\n        };\n    }, [\n        adapter,\n        adapters\n    ]);\n    const wallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>wallets.find((wallet)=>wallet.adapter === adapter) ?? null, [\n        adapter,\n        wallets\n    ]);\n    // Setup and teardown event listeners when the adapter changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!adapter) return;\n        const handleConnect = (publicKey)=>{\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleDisconnect = ()=>{\n            if (isUnloadingRef.current) return;\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleError = (error)=>{\n            handleErrorRef.current(error, adapter);\n        };\n        adapter.on(\"connect\", handleConnect);\n        adapter.on(\"disconnect\", handleDisconnect);\n        adapter.on(\"error\", handleError);\n        return ()=>{\n            adapter.off(\"connect\", handleConnect);\n            adapter.off(\"disconnect\", handleDisconnect);\n            adapter.off(\"error\", handleError);\n            handleDisconnect();\n        };\n    }, [\n        adapter,\n        isUnloadingRef\n    ]);\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [\n        adapter\n    ]);\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !(wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Installed || wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Loadable)) return;\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function() {\n            try {\n                await onAutoConnectRequest();\n            } catch  {\n                onConnectError();\n            // Drop the error. It will be caught by `handleError` anyway.\n            } finally{\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [\n        connected,\n        onAutoConnectRequest,\n        onConnectError,\n        wallet\n    ]);\n    // Send a transaction using the provided connection\n    const sendTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (transaction, connection, options)=>{\n        if (!adapter) throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletNotSelectedError());\n        if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n        return await adapter.sendTransaction(transaction, connection, options);\n    }, [\n        adapter,\n        connected\n    ]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signTransaction\" in adapter ? async (transaction)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signTransaction(transaction);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signAllTransactions\" in adapter ? async (transactions)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signAllTransactions(transactions);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signMessage\" in adapter ? async (message)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signMessage(message);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign in if the wallet supports it\n    const signIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signIn\" in adapter ? async (input)=>{\n            return await adapter.signIn(input);\n        } : undefined, [\n        adapter\n    ]);\n    const handleConnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n        if (!wallet) throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Installed || readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Loadable)) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (e) {\n            onConnectError();\n            throw e;\n        } finally{\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [\n        onConnectError,\n        wallet\n    ]);\n    const handleDisconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isDisconnectingRef.current) return;\n        if (!adapter) return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } finally{\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [\n        adapter\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_useWallet_js__WEBPACK_IMPORTED_MODULE_3__.WalletContext.Provider, {\n        value: {\n            autoConnect: !!onAutoConnectRequest,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: onSelectWallet,\n            connect: handleConnect,\n            disconnect: handleDisconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n            signIn\n        }\n    }, children);\n} //# sourceMappingURL=WalletProviderBase.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL1dhbGxldFByb3ZpZGVyQmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQVdxQztBQUU0RDtBQUM1QztBQUNOO0FBY3pDLFNBQVVXLG1CQUFtQixFQUMvQkMsUUFBUSxFQUNSQyxTQUFTQyxRQUFRLEVBQ2pCQyxPQUFPLEVBQ1BDLGNBQWMsRUFDZEMsb0JBQW9CLEVBQ3BCQyxjQUFjLEVBQ2RDLE9BQU8sRUFDUEMsY0FBYyxFQUNRO0lBQ3RCLE1BQU1DLGtCQUFrQmQsNkNBQUFBLENBQU87SUFDL0IsTUFBTSxDQUFDZSxZQUFZQyxjQUFjLEdBQUdmLCtDQUFBQSxDQUFTO0lBQzdDLE1BQU1nQixxQkFBcUJqQiw2Q0FBQUEsQ0FBTztJQUNsQyxNQUFNLENBQUNrQixlQUFlQyxpQkFBaUIsR0FBR2xCLCtDQUFBQSxDQUFTO0lBQ25ELE1BQU0sQ0FBQ21CLFdBQVdDLGFBQWEsR0FBR3BCLCtDQUFBQSxDQUFTLElBQU1PLFNBQVNZLGFBQWE7SUFDdkUsTUFBTSxDQUFDRSxXQUFXQyxhQUFhLEdBQUd0QiwrQ0FBQUEsQ0FBUyxJQUFNTyxTQUFTYyxhQUFhO0lBRXZFOzs7UUFJQSxNQUFNRSxhQUFheEIsNkNBQUFBLENBQU9ZO0lBQzFCZCxnREFBQUEsQ0FBVTtRQUNOMEIsV0FBV0MsT0FBTyxHQUFHYjtRQUNyQixPQUFPO1lBQ0hZLFdBQVdDLE9BQU8sR0FBR0M7UUFDekI7SUFDSixHQUFHO1FBQUNkO0tBQVE7SUFDWixNQUFNZSxpQkFBaUIzQiw2Q0FBQUEsQ0FBTyxDQUFDNEIsT0FBb0JwQjtRQUMvQyxJQUFJLENBQUNDLGVBQWVnQixPQUFPLEVBQUU7WUFDekIsSUFBSUQsV0FBV0MsT0FBTyxFQUFFO2dCQUNwQkQsV0FBV0MsT0FBTyxDQUFDRyxPQUFPcEI7bUJBQ3ZCO2dCQUNIcUIsUUFBUUQsS0FBSyxDQUFDQSxPQUFPcEI7Z0JBQ3JCLElBQUlvQixpQkFBaUJs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c291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy9XYWxsZXRQcm92aWRlckJhc2UudHN4PzY4ZWMiXSwibmFtZXMiOlsiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0UmVhZHlTdGF0ZSIsIlJlYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJXYWxsZXROb3RTZWxlY3RlZEVycm9yIiwiV2FsbGV0Q29udGV4dCIsIldhbGxldFByb3ZpZGVyQmFzZSIsImNoaWxkcmVuIiwid2FsbGV0cyIsImFkYXB0ZXJzIiwiYWRhcHRlciIsImlzVW5sb2FkaW5nUmVmIiwib25BdXRvQ29ubmVjdFJlcXVlc3QiLCJvbkNvbm5lY3RFcnJvciIsIm9uRXJyb3IiLCJvblNlbGVjdFdhbGxldCIsImlzQ29ubmVjdGluZ1JlZiIsImNvbm5lY3RpbmciLCJzZXRDb25uZWN0aW5nIiwiaXNEaXNjb25uZWN0aW5nUmVmIiwiZGlzY29ubmVjdGluZyIsInNldERpc2Nvbm5lY3RpbmciLCJwdWJsaWNLZXkiLCJzZXRQdWJsaWNLZXkiLCJjb25uZWN0ZWQiLCJzZXRDb25uZWN0ZWQiLCJvbkVycm9yUmVmIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImhhbmRsZUVycm9yUmVmIiwiZXJyb3IiLCJjb25zb2xlIiwid2luZG93Iiwib3BlbiIsInVybCIsInNldFdhbGxldHMiLCJtYXAiLCJyZWFkeVN0YXRlIiwiZmlsdGVyIiwiVW5zdXBwb3J0ZWQiLCJpbmRleCIsIndhbGxldCIsImhhbmRsZVJlYWR5U3RhdGVDaGFuZ2UiLCJwcmV2V2FsbGV0cyIsImZpbmRJbmRleCIsInNsaWNlIiwiZm9yRWFjaCIsIm9uIiwib2ZmIiwiZmluZCIsImhhbmRsZUNvbm5lY3QiLCJoYW5kbGVEaXNjb25uZWN0IiwiaGFuZGxlRXJyb3IiLCJkaWRBdHRlbXB0QXV0b0Nvbm5lY3RSZWYiLCJJbnN0YWxsZWQiLCJMb2FkYWJsZSIsInNlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25zIiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlIiwic2lnbkluIiwiaW5wdXQiLCJjb25uZWN0IiwiZSIsImRpc2Nvbm5lY3QiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImF1dG9Db25uZWN0Iiwic2VsZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js ***!
  \*********************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletNotSelectedError: () => (/* binding */ WalletNotSelectedError)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__]);\n_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nclass WalletNotSelectedError extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__.WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotSelectedError\";\n    }\n} //# sourceMappingURL=errors.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRDtBQUVwRCxNQUFPQywrQkFBK0JELG9FQUFBQTtJQUE1Q0UsYUFBQTs7UUFDSSxLQUFBQyxJQUFJLEdBQUc7SUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2FybWVuaS1sZWRzLXNvbC8uLi8uLi9zcmMvZXJyb3JzLnRzPzk3MWIiXSwibmFtZXMiOlsiV2FsbGV0RXJyb3IiLCJXYWxsZXROb3RTZWxlY3RlZEVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js ***!
  \*****************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   \"default\": () => (/* binding */ getEnvironment)\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"./node_modules/@solana/wallet-adapter-base/lib/esm/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__, _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__]);\n([_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__, _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\nvar Environment;\n(function(Environment) {\n    Environment[Environment[\"DESKTOP_WEB\"] = 0] = \"DESKTOP_WEB\";\n    Environment[Environment[\"MOBILE_WEB\"] = 1] = \"MOBILE_WEB\";\n})(Environment || (Environment = {}));\nfunction isWebView(userAgentString) {\n    return /(WebView|Version\\/.+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)|; wv\\).+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+))/i.test(userAgentString);\n}\nfunction getEnvironment({ adapters, userAgentString }) {\n    if (adapters.some((adapter)=>adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && adapter.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Installed)) {\n        /**\n         * There are only two ways a browser extension adapter should be able to reach `Installed` status:\n         *\n         *     1. Its browser extension is installed.\n         *     2. The app is running on a mobile wallet's in-app browser.\n         *\n         * In either case, we consider the environment to be desktop-like.\n         */ return Environment.DESKTOP_WEB;\n    }\n    if (userAgentString && // Step 1: Check whether we're on a platform that supports MWA at all.\n    /android/i.test(userAgentString) && // Step 2: Determine that we are *not* running in a WebView.\n    !isWebView(userAgentString)) {\n        return Environment.MOBILE_WEB;\n    } else {\n        return Environment.DESKTOP_WEB;\n    }\n} //# sourceMappingURL=getEnvironment.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2dldEVudmlyb25tZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMkY7QUFDZDtBQUU3RSxJQUFZRSxZQUdYO0FBSEQsVUFBWUEsV0FBVztJQUNuQkEsV0FBQSxDQUFBQSxXQUFBO0lBQ0FBLFdBQUEsQ0FBQUEsV0FBQTtBQUNKLEdBSFlBLGVBQUFBLENBQUFBLGNBQVc7QUFVdkIsU0FBU0MsVUFBVUMsZUFBdUI7SUFDdEMsT0FBTywwR0FBMEdDLElBQUksQ0FDakhEO0FBRVI7QUFFYyxTQUFVRSxlQUFlLEVBQUVDLFFBQVEsRUFBRUgsZUFBZSxFQUFVO0lBQ3hFLElBQ0lHLFNBQVNDLElBQUksQ0FDVCxDQUFDQyxVQUNHQSxRQUFRQyxJQUFJLEtBQUtWLHFHQUFBQSxJQUNqQlMsUUFBUUUsVUFBVSxLQUFLVix5RUFBQUEsQ0FBaUJXLFNBQVMsR0FFM0Q7UUFDRTs7Ozs7OztZQVFBLE9BQU9WLFlBQVlXLFdBQVc7O0lBRWxDLElBQ0lULG1CQUNBLHNFQUFzRTtJQUN0RSxXQUFXQyxJQUFJLENBQUNELG9CQUNoQiw0REFBNEQ7SUFDNUQsQ0FBQ0QsVUFBVUMsa0JBQ2I7UUFDRSxPQUFPRixZQUFZWSxVQUFVO1dBQzFCO1FBQ0gsT0FBT1osWUFBWVcsV0FBVzs7QUFFdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL2dldEVudmlyb25tZW50LnRzPzVjYzMiXSwibmFtZXMiOlsiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUiLCJXYWxsZXRSZWFkeVN0YXRlIiwiRW52aXJvbm1lbnQiLCJpc1dlYlZpZXciLCJ1c2VyQWdlbnRTdHJpbmciLCJ0ZXN0IiwiZ2V0RW52aXJvbm1lbnQiLCJhZGFwdGVycyIsInNvbWUiLCJhZGFwdGVyIiwibmFtZSIsInJlYWR5U3RhdGUiLCJJbnN0YWxsZWQiLCJERVNLVE9QX1dFQiIsIk1PQklMRV9XRUIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getInferredClusterFromEndpoint)\n/* harmony export */ });\nfunction getInferredClusterFromEndpoint(endpoint) {\n    if (!endpoint) {\n        return \"mainnet-beta\";\n    }\n    if (/devnet/i.test(endpoint)) {\n        return \"devnet\";\n    } else if (/testnet/i.test(endpoint)) {\n        return \"testnet\";\n    } else {\n        return \"mainnet-beta\";\n    }\n} //# sourceMappingURL=getInferredClusterFromEndpoint.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2dldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBRWMsU0FBVUEsK0JBQStCQyxRQUFpQjtJQUNwRSxJQUFJLENBQUNBLFVBQVU7UUFDWCxPQUFPOztJQUVYLElBQUksVUFBVUMsSUFBSSxDQUFDRCxXQUFXO1FBQzFCLE9BQU87V0FDSixJQUFJLFdBQVdDLElBQUksQ0FBQ0QsV0FBVztRQUNsQyxPQUFPO1dBQ0o7UUFDSCxPQUFPOztBQUVmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy9nZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQudHM/ZGYxMCJdLCJuYW1lcyI6WyJnZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQiLCJlbmRwb2ludCIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/index.js ***!
  \********************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ConnectionProvider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConnectionProvider.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _ConnectionProvider_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _ConnectionProvider_js__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\");\n/* harmony import */ var _useAnchorWallet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useAnchorWallet.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useAnchorWallet.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _useAnchorWallet_js__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _useAnchorWallet_js__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useConnection.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _useConnection_js__WEBPACK_IMPORTED_MODULE_3__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _useConnection_js__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _useLocalStorage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useLocalStorage.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _useLocalStorage_js__WEBPACK_IMPORTED_MODULE_4__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _useLocalStorage_js__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _useWallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./useWallet.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _useWallet_js__WEBPACK_IMPORTED_MODULE_5__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _useWallet_js__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _WalletProvider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WalletProvider.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_errors_js__WEBPACK_IMPORTED_MODULE_1__, _WalletProvider_js__WEBPACK_IMPORTED_MODULE_6__]);\n([_errors_js__WEBPACK_IMPORTED_MODULE_1__, _WalletProvider_js__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _errors_js__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _errors_js__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _WalletProvider_js__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _WalletProvider_js__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ1o7QUFDUztBQUNGO0FBQ0U7QUFDTjtBQUNLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy9pbmRleC50cz82NzQ0Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/index.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/useAnchorWallet.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useAnchorWallet.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAnchorWallet: () => (/* binding */ useAnchorWallet)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var _useWallet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useWallet.js */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n\n\nfunction useAnchorWallet() {\n    const { publicKey, signTransaction, signAllTransactions } = (0,_useWallet_js__WEBPACK_IMPORTED_MODULE_1__.useWallet)();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>publicKey && signTransaction && signAllTransactions ? {\n            publicKey,\n            signTransaction,\n            signAllTransactions\n        } : undefined, [\n        publicKey,\n        signTransaction,\n        signAllTransactions\n    ]);\n} //# sourceMappingURL=useAnchorWallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZUFuY2hvcldhbGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDZ0M7QUFDVztBQVFyQyxTQUFVRTtJQUNaLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxlQUFlLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdKLHdEQUFBQTtJQUM1RCxPQUFPRCw4Q0FBQUEsQ0FDSCxJQUNJRyxhQUFhQyxtQkFBbUJDLHNCQUMxQjtZQUFFRjtZQUFXQztZQUFpQkM7UUFBbUIsSUFDakRDLFdBQ1Y7UUFBQ0g7UUFBV0M7UUFBaUJDO0tBQW9CO0FBRXpEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy91c2VBbmNob3JXYWxsZXQudHM/YTRlMSJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwidXNlV2FsbGV0IiwidXNlQW5jaG9yV2FsbGV0IiwicHVibGljS2V5Iiwic2lnblRyYW5zYWN0aW9uIiwic2lnbkFsbFRyYW5zYWN0aW9ucyIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/useAnchorWallet.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionContext: () => (/* binding */ ConnectionContext),\n/* harmony export */   useConnection: () => (/* binding */ useConnection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n\nconst ConnectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useConnection() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ConnectionContext);\n} //# sourceMappingURL=useConnection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZUNvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ2tEO0FBTTNDLE1BQU1FLGtDQUFvQkYsb0RBQUFBLENBQXNDLElBQThCO0FBRS9GLFNBQVVHO0lBQ1osT0FBT0YsaURBQUFBLENBQVdDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJtZW5pLWxlZHMtc29sLy4uLy4uL3NyYy91c2VDb25uZWN0aW9uLnRzPzExMDIiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJDb25uZWN0aW9uQ29udGV4dCIsInVzZUNvbm5lY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLocalStorage: () => (/* binding */ useLocalStorage)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n\nfunction useLocalStorage(key, defaultState) {\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        try {\n            const value = localStorage.getItem(key);\n            if (value) return JSON.parse(value);\n        } catch (error) {\n            if (false) {}\n        }\n        return defaultState;\n    });\n    const value = state[0];\n    const isFirstRenderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isFirstRenderRef.current) {\n            isFirstRenderRef.current = false;\n            return;\n        }\n        try {\n            if (value === null) {\n                localStorage.removeItem(key);\n            } else {\n                localStorage.setItem(key, JSON.stringify(value));\n            }\n        } catch (error) {\n            if (false) {}\n        }\n    }, [\n        value,\n        key\n    ]);\n    return state;\n} //# sourceMappingURL=useLocalStorage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZUxvY2FsU3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RjtBQUVsRixTQUFVRyxnQkFBbUJDLEdBQVcsRUFBRUMsWUFBZTtJQUMzRCxNQUFNQyxRQUFRSiwrQ0FBQUEsQ0FBWTtRQUN0QixJQUFJO1lBQ0EsTUFBTUssUUFBUUMsYUFBYUMsT0FBTyxDQUFDTDtZQUNuQyxJQUFJRyxPQUFPLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0o7VUFDL0IsT0FBT0ssT0FBWTtZQUNqQixJQUFJLEtBQWtCLEVBQWE7O1FBS3ZDLE9BQU9QO0lBQ1g7SUFDQSxNQUFNRSxRQUFRRCxLQUFLLENBQUMsRUFBRTtJQUV0QixNQUFNUSxtQkFBbUJiLDZDQUFBQSxDQUFPO0lBQ2hDRCxnREFBQUEsQ0FBVTtRQUNOLElBQUljLGlCQUFpQkMsT0FBTyxFQUFFO1lBQzFCRCxpQkFBaUJDLE9BQU8sR0FBRztZQUMzQjs7UUFFSixJQUFJO1lBQ0EsSUFBSVIsVUFBVSxNQUFNO2dCQUNoQkMsYUFBYVEsVUFBVSxDQUFDWjttQkFDckI7Z0JBQ0hJLGFBQWFTLE9BQU8sQ0FBQ2IsS0FBS00sS0FBS1EsU0FBUyxDQUFDWDs7VUFFL0MsT0FBT0ssT0FBWTtZQUNqQixJQUFJLEtBQWtCLEVBQWE7O0lBSTNDLEdBQUc7UUFBQ0w7UUFBT0g7S0FBSTtJQUVmLE9BQU9FO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL3VzZUxvY2FsU3RvcmFnZS50cz8yY2VjIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlTG9jYWxTdG9yYWdlIiwia2V5IiwiZGVmYXVsdFN0YXRlIiwic3RhdGUiLCJ2YWx1ZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImNvbnNvbGUiLCJpc0ZpcnN0UmVuZGVyUmVmIiwiY3VycmVudCIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\n");

/***/ }),

/***/ "./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js":
/*!************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletContext: () => (/* binding */ WalletContext),\n/* harmony export */   useWallet: () => (/* binding */ useWallet)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n\nconst EMPTY_ARRAY = [];\nconst DEFAULT_CONTEXT = {\n    autoConnect: false,\n    connecting: false,\n    connected: false,\n    disconnecting: false,\n    select () {\n        logMissingProviderError(\"call\", \"select\");\n    },\n    connect () {\n        return Promise.reject(logMissingProviderError(\"call\", \"connect\"));\n    },\n    disconnect () {\n        return Promise.reject(logMissingProviderError(\"call\", \"disconnect\"));\n    },\n    sendTransaction () {\n        return Promise.reject(logMissingProviderError(\"call\", \"sendTransaction\"));\n    },\n    signTransaction () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signTransaction\"));\n    },\n    signAllTransactions () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signAllTransactions\"));\n    },\n    signMessage () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signMessage\"));\n    },\n    signIn () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signIn\"));\n    }\n};\nObject.defineProperty(DEFAULT_CONTEXT, \"wallets\", {\n    get () {\n        logMissingProviderError(\"read\", \"wallets\");\n        return EMPTY_ARRAY;\n    }\n});\nObject.defineProperty(DEFAULT_CONTEXT, \"wallet\", {\n    get () {\n        logMissingProviderError(\"read\", \"wallet\");\n        return null;\n    }\n});\nObject.defineProperty(DEFAULT_CONTEXT, \"publicKey\", {\n    get () {\n        logMissingProviderError(\"read\", \"publicKey\");\n        return null;\n    }\n});\nfunction logMissingProviderError(action, property) {\n    const error = new Error(`You have tried to ${action} \"${property}\" on a WalletContext without providing one. ` + \"Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.\");\n    console.error(error);\n    return error;\n}\nconst WalletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(DEFAULT_CONTEXT);\nfunction useWallet() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(WalletContext);\n} //# sourceMappingURL=useWallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZVdhbGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFVa0Q7QUEyQmxELE1BQU1FLGNBQW9DLEVBQUU7QUFFNUMsTUFBTUMsa0JBQStDO0lBQ2pEQyxhQUFhO0lBQ2JDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxlQUFlO0lBQ2ZDO1FBQ0lDLHdCQUF3QixRQUFRO0lBQ3BDO0lBQ0FDO1FBQ0ksT0FBT0MsUUFBUUMsTUFBTSxDQUFDSCx3QkFBd0IsUUFBUTtJQUMxRDtJQUNBSTtRQUNJLE9BQU9GLFFBQVFDLE1BQU0sQ0FBQ0gsd0JBQXdCLFFBQVE7SUFDMUQ7SUFDQUs7UUFDSSxPQUFPSCxRQUFRQyxNQUFNLENBQUNILHdCQUF3QixRQUFRO0lBQzFEO0lBQ0FNO1FBQ0ksT0FBT0osUUFBUUMsTUFBTSxDQUFDSCx3QkFBd0IsUUFBUTtJQUMxRDtJQUNBTztRQUNJLE9BQU9MLFFBQVFDLE1BQU0sQ0FBQ0gsd0JBQXdCLFFBQVE7SUFDMUQ7SUFDQVE7UUFDSSxPQUFPTixRQUFRQyxNQUFNLENBQUNILHdCQUF3QixRQUFRO0lBQzFEO0lBQ0FTO1FBQ0ksT0FBT1AsUUFBUUMsTUFBTSxDQUFDSCx3QkFBd0IsUUFBUTtJQUMxRDs7QUFFSlUsT0FBT0MsY0FBYyxDQUFDakIsaUJBQWlCLFdBQVc7SUFDOUNrQjtRQUNJWix3QkFBd0IsUUFBUTtRQUNoQyxPQUFPUDtJQUNYOztBQUVKaUIsT0FBT0MsY0FBYyxDQUFDakIsaUJBQWlCLFVBQVU7SUFDN0NrQjtRQUNJWix3QkFBd0IsUUFBUTtRQUNoQyxPQUFPO0lBQ1g7O0FBRUpVLE9BQU9DLGNBQWMsQ0FBQ2pCLGlCQUFpQixhQUFhO0lBQ2hEa0I7UUFDSVosd0JBQXdCLFFBQVE7UUFDaEMsT0FBTztJQUNYOztBQUdKLFNBQVNBLHdCQUF3QmEsTUFBYyxFQUFFQyxRQUFnQjtJQUM3RCxNQUFNQyxRQUFRLElBQUlDLE1BQ2QscUJBQXFCSCxPQUFNLElBQUtDLFNBQVEsNkNBQThDLEdBQ2xGO0lBRVJHLFFBQVFGLEtBQUssQ0FBQ0E7SUFDZCxPQUFPQTtBQUNYO0FBRU8sTUFBTUcsOEJBQWdCM0Isb0RBQUFBLENBQWtDRyxpQkFBdUM7QUFFaEcsU0FBVXlCO0lBQ1osT0FBTzNCLGlEQUFBQSxDQUFXMEI7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcm1lbmktbGVkcy1zb2wvLi4vLi4vc3JjL3VzZVdhbGxldC50cz8wNmVjIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiRU1QVFlfQVJSQVkiLCJERUZBVUxUX0NPTlRFWFQiLCJhdXRvQ29ubmVjdCIsImNvbm5lY3RpbmciLCJjb25uZWN0ZWQiLCJkaXNjb25uZWN0aW5nIiwic2VsZWN0IiwibG9nTWlzc2luZ1Byb3ZpZGVyRXJyb3IiLCJjb25uZWN0IiwiUHJvbWlzZSIsInJlamVjdCIsImRpc2Nvbm5lY3QiLCJzZW5kVHJhbnNhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwic2lnbk1lc3NhZ2UiLCJzaWduSW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFjdGlvbiIsInByb3BlcnR5IiwiZXJyb3IiLCJFcnJvciIsImNvbnNvbGUiLCJXYWxsZXRDb250ZXh0IiwidXNlV2FsbGV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\n");

/***/ })

};
;